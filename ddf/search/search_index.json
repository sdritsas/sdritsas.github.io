{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#digital-design-and-fabrication","title":"Digital Design and Fabrication","text":"<p>The weekly topics presented in the Digital Design and Fabrication (DDF) subject are listed below. DDF assumes some familiarity with mathematics, python programming and parametric modeling from terms 1, 2 and 3. Nevertheless, refresher content is provided in the first week and additional material for self study. Practice questions and answers are provided in the constructions section.</p>"},{"location":"#schedule","title":"Schedule","text":"Week Topics 01 Computational Geometry of Points and Vectors 02 Coordinate Systems and Spatial Transformations 03 Explicit, Implicit and Parametric Spatial Curves 04 Euclidean and Computational Surfaces 05 Triangulation and Mesh Geometry and Topology 06 Solid and Volume Object Representations"},{"location":"#supplementary","title":"Supplementary","text":"Topics Content Parametrics Computer Aided Design / Visual Programming / Python Components / Python Template Programming Lists and Dictionaries / Functions and Lambdas / Objects and Classes Mathematics Points and Vectors / Distance and Length / Addition / Subtraction / Multiplication / Normalization / Dot Product / Cross Product"},{"location":"dev/addition/","title":"Points and Vectors Addition","text":"<p>Point and vector addition has the same properties as regular real numbers. It is performed element-wise for each of the <code>X</code>, <code>Y</code> and <code>Z</code> coordinates / components. Specifically, suppose the following two points and vectors are defined:</p> <pre><code>p = Point3d( px, py, pz )\nq = Point3d( qx, qy, qz )\n\nu = Vector3d( ux, uy, uz )\nv = Vector3d( vx, vy, vz )\n</code></pre> <p>The results of adding those respectively are seen below. Note that Rhino's geometry library support natively the addition of points and vectors using the <code>+</code> operator.</p>"},{"location":"geometry/constructions/angles/","title":"Angles","text":"<p>The objective of this section is to cover geometric constructions using points and vectors. In particular, this section focuses on computing angles.</p>"},{"location":"geometry/constructions/angles/#between-vectors","title":"Between Vectors","text":"<p>Provided with two vectors <code>u</code> and <code>v</code>, determine the angle <code>a</code> spanned between them.</p> <pre><code>\"\"\" Inputs\n\"\"\"\nu = Vector3d( ux, uy, uz )\nv = Vector3d( vx, vy, vz )\n</code></pre> Solution <p>Computing the angle between vectors is based on the trigonometric definition of the dot product <code>u \u00b7 v = |u| * |v| * cos( t )</code>. Note that the angle computed is in radians.</p> <p></p> <ol> <li>Normalize both <code>u</code> and <code>v</code> vectors.</li> <li>Use the arc-cosine of the dot product.</li> </ol> <pre><code>\"\"\" Outputs\n\"\"\"\nu.Unitize( )\nv.Unitize( )\n\na = math.acos( u * v )\n</code></pre> <p>Using Rhino's geometry library requires invoking the <code>Vector3d</code> static method <code>VectorAngle( )</code>. See the relevant documentation.</p> <pre><code>\"\"\" Outputs\n\"\"\"\na = Vector3d.VectorAngle( u, v )\n</code></pre>"},{"location":"geometry/constructions/angles/#angle-bisector","title":"Angle Bisector","text":"<p>Provided three points <code>a</code>, <code>b</code>, and <code>c</code>, determine the location of a point <code>p</code> on the bisector of the angle of the triangle <code>( a, b, c )</code> from point <code>a</code>.</p> <pre><code>\"\"\" Inputs\n\"\"\"\na = Point3d( ax, ay, az )\nb = Point3d( bx, by, bz )\nc = Point3d( cx, cy, cz )\n</code></pre> Solution <p>A simple solution for this construction requires noticing that the problem is trivial for isosceles triangles, where two sides <code>ab</code> and  <code>ac</code> are equal. For these triangles the line from <code>a</code> to the mid-point of the opposite side, namely <code>( b + c ) / 2</code>, is bisecting the angle.</p> <p>We create two vectors from <code>a</code> to the other points <code>b</code> and <code>c</code>, namely <code>u = b - a</code> and <code>v = c - a</code> and then normalize them <code>U = u / |u|</code> and <code>V = v / |v|</code>. This is equivalent to making them the same size <code>|U| = |V|</code>, as if they were produced from a unit-length isosceles triangle.</p> <p>Adding <code>w = U + V</code> forms a vector pointing to the opposite corner of the parallelogram spanned form <code>a</code>. This direction is bisecting the angle as required. The last step is to translate point <code>a</code> by adding the bisecting vector <code>p = a + w</code>.</p> <p></p> <ol> <li>Create the vectors from <code>a</code> to <code>b</code> and <code>c</code>.</li> <li>Normalize and add the two vectors.</li> <li>Translate <code>a</code> by the bisecting direction.</li> </ol> <pre><code>\"\"\" Outputs\n\"\"\"\nu = b - a; u.Unitize( )\nv = c - a; v.Unitize( )\np = a + u + v\n</code></pre>"},{"location":"geometry/constructions/angles/#point-in-plane","title":"Point in Plane","text":"<p>Provided with a plane <code>( o, u, v )</code> with origin <code>o</code> and orthonormal directions <code>u</code> and <code>v</code>, and another point <code>p</code> in space, determine its angle <code>a</code> in <code>[0, 2\u03c0]</code> with respect to the plane.</p> <pre><code>\"\"\" Inputs\n\"\"\"\no =  Point3d( ox, oy, oz )\nu = Vector3d( ux, uy, uz )\nv = Vector3d( vx, vy, vz )\np =  Point3d( px, py, pz )\n</code></pre> Solution <p>This question has conceptually two different parts. First the point provided is in space so we need to associate it with the plane. This can be done by projecting it onto the plane as seen in projections.</p> <p>Alternatively, we can construct a vector <code>w = p - o</code> from the origin to the point and compute the dot products <code>x = u \u00b7 w</code> and <code>y = v \u00b7 w</code>. Notice that the point <code>q = [x, y]</code> represents the local coordinates version of the original point. In a sense we performed the projection for each of the plane's axes individually.</p> <p>To compute the angle in a 360deg sense we need use the two-parameter arctangent method which provides an angle in the <code>[-\u03c0, \u03c0]</code> range. Finally, we need to check if the angle is negative and adjust it such that it is within the desired <code>[0, 2\u03c0]</code> angle range.</p> <p></p> <ol> <li>Create a vector <code>w = p - o</code> from the plane's origin <code>o</code> to the spatial point <code>p</code>.</li> <li>Compute the local coordinates <code>[u \u00b7 w, v \u00b7 w]</code> by dot product projections.</li> <li>Compute the angle <code>a = tan-1( y, x )</code> and adjust its range if it is negative.</li> </ol> <pre><code>#-- Outputs\n#--\nw = p - o\nx = u * w\ny = v * W\na = math.atan2( y, x )\nif( a &lt; 0 ): a += 2 * math.pi\n</code></pre>"},{"location":"geometry/constructions/areas/","title":"Areas","text":"<p>The objective of this section is to cover geometric constructions using points and vectors. In particular, this section focuses on computing areas.</p>"},{"location":"geometry/constructions/areas/#parallelogram","title":"Parallelogram","text":"<p>Provided with two vectors <code>u</code> and <code>v</code>, determine the area of the parallelogram spanned by them.</p> <pre><code>\"\"\" Inputs\n\"\"\"\nu = Vector3d( ux, uy, uz )\nv = Vector3d( vx, vy, vz )\n</code></pre> Solution <p>The magnitude of the cross product between two vectors measures the area of the parallelogram spanned.</p> <p></p> <ol> <li>Compute the cross product of the <code>u</code> and <code>v</code> vectors.</li> <li>Measure the length of the normal vector.</li> </ol> <pre><code>\"\"\" Outputs\n\"\"\"\na = Vector3d.CrossProduct( u, v ).Length\n</code></pre>"},{"location":"geometry/constructions/areas/#triangle","title":"Triangle","text":"<p>Provided three points <code>a</code>, <code>b</code>, and <code>c</code>, determine the area of triangle <code>( a, b, c )</code>.</p> <pre><code>\"\"\" Inputs\n\"\"\"\na = Point3d( ax, ay, az )\nb = Point3d( bx, by, bz )\nc = Point3d( cx, cy, cz )\n</code></pre> Solution <p>The solution requires noticing that we can compute the area of a triangle if we half the area of the parallelogram spanned by two vectors encoded in their cross product.</p> <p></p> <ol> <li>Construct two vectors <code>u = b - a</code> and <code>v = c - a</code>along the triangle's sides.</li> <li>Compute the cross product of the <code>u</code> and <code>v</code> vectors.</li> <li>Measure half of the length of the normal vector.</li> </ol> <pre><code>\"\"\" Outputs\n\"\"\"\nu = b - a\nv = c - a\na = Vector3d.CrossProduct( u, v ).Length * 0.5\n</code></pre>"},{"location":"geometry/constructions/areas/#polygon","title":"Polygon","text":"<p>Provided with a plane <code>( o, n )</code> defined by its origin <code>o</code> and unit normal <code>n</code>, and a list of <code>n</code> points <code>[p1, p2, ..., pn]</code> compute the area of the polygon.</p> <pre><code>\"\"\" Inputs\n\"\"\"\norigin =  Point3d( ox, oy, oz )\nnormal = Vector3d( nx, ny, nz )\npoints = [Point3d( x1, y1, z1 ),\n          Point3d( x2, y2, z2 ),\n          #...\n          Point3d( xn, yn, zn )]\n</code></pre> Solution <p>Computing the area of an arbitrary spatial polygon requires first to project its points to a plane. To compute its area we can either use the shoelace algorithm or Rhino's area and mass properties.</p> <ol> <li>Project the points on the plane</li> <li>Compute the area of the 2D polygon</li> </ol> <p>Note that we need to create a polyline curve in order to use the area and mass properties compute method.</p> <pre><code>\"\"\" Outputs\n\"\"\"\nprojected = []\nfor point in points:\n    projected.append( point - normal * ( point - origin ) * normal )\n\nprops = AreaMassProperties.Compute(\n    PolylineCurve( projected )\narea = props.Area\n</code></pre> <p>The shoelace algorithm is presented below. Note that we need to ensure that the polygon is closed. Therefore, the first point in appended at the end of the list. Then we iterate all points pair-wise and accumulate the discriminants. The area computed using this method is also known as the signed area of the polygon because it is positive or negative depending on whether the points are ordered clockwise or anticlockwise.</p> <pre><code>\"\"\" Outputs\n\"\"\"\nprojected = [point - normal * ( point - origin ) * normal\n    for point in points]\nprojected.append( projected[0] )\n\narea = 0.0\nfor p, q in zip( points[:-1], points[1:] ):\n    area += ( p.X + q.X ) * ( p.Y - q.Y )\narea = abs( area / 2 )\n</code></pre>"},{"location":"geometry/constructions/centroids/","title":"Centroids","text":"<p>The objective of this section is to cover geometric constructions using points and vectors. In particular, this section focuses on computing geometric center points or centroids.</p>"},{"location":"geometry/constructions/centroids/#parallelogram","title":"Parallelogram","text":"<p>Provided with a parallelogram <code>( a, b, c, d )</code> defined by its four points <code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code>, determine the point <code>o</code> at its center.</p> <pre><code>\"\"\" Inputs\n\"\"\"\na = Point3d( ax, ay, az )\nb = Point3d( bx, by, bz )\nc = Point3d( cx, cy, cz )\nd = Point3d( dx, dy, dz )\n</code></pre> Solution <p>The solution requires noticing that the sum of two vectors spans a parallelogram with direction along its diagonal. A vector with half that length points to the center of the parallelogram.</p> <ol> <li>Compute two vectors along the parallelogram's sides <code>u = b - a</code> and <code>v = d - a</code>.</li> <li>Compute the sum of the vectors and half it <code>w = ( u + v ) / 2</code>.</li> <li>Translate the point <code>a</code> by the vector <code>o = a + w</code>.</li> </ol> <pre><code>\"\"\" Outputs\n\"\"\"\nu = b - a\nv = d - a\nw = ( u + v ) / 2\no = a + w\n</code></pre> <p>Alternatively, notice that the point in the center of the parallelogram is where its diagonals cross. Moreover, the point at the center splits the diagonals in two equal parts. Thus a simpler solution involves only computing the mid-point of either diagonal points.</p> <pre><code>\"\"\" Middle of Diagonals\n\"\"\"\no = ( a + c ) / 2\n''' or '''\no = ( b + d ) / 2\n</code></pre>"},{"location":"geometry/constructions/centroids/#triangle","title":"Triangle","text":"<p>Provided with a triangle <code>( a, b, d )</code> defined by three points <code>a</code>, <code>b</code>, and <code>c</code>, determine the location of the point <code>o</code> at the triangle's centroid.</p> <pre><code>\"\"\" Inputs\n\"\"\"\na = Point3d( ax, ay, az )\nb = Point3d( bx, by, bz )\nc = Point3d( cx, cy, cz )\n</code></pre> Solution <p>Triangles have many centers from which the centroid is the simplest to compute. The centroid is situated at the point of intersection between its medians, that is the lines that connects its points with the middle of its opposite sides. It can be computed as the mean of its points.</p> <pre><code>\"\"\" Outputs\n\"\"\"\no = ( a + b + c ) / 3\n</code></pre>"},{"location":"geometry/constructions/centroids/#point-list","title":"Point List","text":"<p>Provided with a list of <code>n</code> points in space, <code>[p1, p2, ..., pn]</code> determine the location of the point <code>o</code> at its center.</p> <pre><code>\"\"\" Inputs\n\"\"\"\npoints = [Point3d( x1, y1, z1 ),\n          Point3d( x2, y2, z2 ),\n          #...\n          Point3d( xn, yn, zn )]\n</code></pre> Solution <p>The centroid for a list of points can be computed as the mean among its coordinates. The following implementation sets up a zero point and accumulates the coordinates using point addition. Finally, the centroid is computed by dividing the coordinates with the number of points.</p> <pre><code>\"\"\" Outputs\n\"\"\"\no = Point3d( 0.0, 0.0, 0.0 )\nfor point in points:\n    o += point\no *= 1.0 / len( points )\n</code></pre>"},{"location":"geometry/constructions/clashes/","title":"Clash Detection","text":"<p>The objective of this section is to cover geometric constructions using points and vectors. In particular, this section focuses on detecting whether two geometric objects are clashing with one another.</p>"},{"location":"geometry/constructions/clashes/#sphere-and-sphere","title":"Sphere and Sphere","text":"<p>Provided with two spheres <code>( p, s )</code> and <code>( q, t )</code> with centers <code>p</code> and <code>q</code>, and radii <code>s</code> and <code>t</code>, determine the condition such that the two spheres have clearance <code>d</code> (are spaced apart by at least <code>d</code>).</p> <pre><code>\"\"\" Inputs\n\"\"\"\np, s = Point3d( px, py, pz ), 1.0\nq, t = Point3d( qx, qy, qz ), 2.0\nd = 1e-5\n</code></pre> Solution <p>Two spheres overlap, if the distance between their centers is smaller than the sum of their radii. By adding the clearance term the concept is extended to clash detection.</p> <pre><code>\"\"\" Outputs\n\"\"\"\ndistance = p.DistanceTo( q )\noverlap  = distance &lt; s + t\nclashing = distance &lt; s + t + d\n</code></pre>"},{"location":"geometry/constructions/clashes/#sphere-and-plane","title":"Sphere and Plane","text":"<p>Provided with a sphere <code>( p, r )</code> with center <code>p</code> and radius <code>r</code>, and a plane <code>( o, n )</code> with origin <code>o</code> and unit normal <code>n</code>, determine the condition such that the two objects have clearance <code>d</code> (are spaced apart by at least <code>d</code>).</p> <pre><code>\"\"\" Inputs\n\"\"\"\np, r = Point3d( px, py, pz ), 1.0\no, n = Point3d( ox, oy, oz ), Vector3d( nx, ny, nz )\nd = 1e-5\n</code></pre> Solution <p>A plane and a sphere overlap if the distance between the sphere's center and the plane is smaller than the sphere's radius. The distance is computed from the absolute value of the dot product, assuming we don't care about the side of the plane. By adding the clearance term the concept is extended to clash detection.</p> <pre><code>\"\"\" Outputs\n\"\"\"\ndistance = abs( n * ( p - o ) )\noverlap  = distance &lt; r\nclashing = distance &lt; r + d\n</code></pre>"},{"location":"geometry/constructions/clashes/#sphere-and-line","title":"Sphere and Line","text":"<p>Provided with a sphere <code>( c, r )</code> with center <code>c</code> and radius <code>r</code>, and a line <code>( p, u )</code> with origin point <code>p</code> and unit direction <code>u</code>, determine the condition such that the two objects have clearance <code>d</code> (are spaced apart by at least <code>d</code>).</p> <pre><code>\"\"\" Inputs\n\"\"\"\nc, r = Point3d( cx, cy, cz ), 1.0\np, u = Point3d( px, py, pz ), Vector3d( ux, uy, uz )\nd = 1e-5\n</code></pre> Solution <p>A line and a sphere overlap if the distance between the sphere's center and the line is smaller than the sphere's radius. The distance is computed using the dot product. By adding the clearance term the concept is extended to clash detection.</p> <pre><code>\"\"\" Outputs\n\"\"\"\nv = c - p\nw = v - u * v * u\ndistance = w.Length\noverlap  = distance &lt; r\nclashing = distance &lt; r + d\n</code></pre>"},{"location":"geometry/constructions/containment/","title":"Containment","text":"<p>The objective of this section is to cover geometric constructions using points and vectors. In particular, this section focuses on detecting a geometric object is situated inside another.</p>"},{"location":"geometry/constructions/containment/#point-in-interval","title":"Point in Interval","text":"<p>Provided with a real value <code>v</code> and an interval <code>( a, b )</code>, determine the condition such that the value <code>t</code> is inside the interval.</p> <pre><code>\"\"\" Inputs\n\"\"\"\nv = 0.5\na, b = 0.0, 1.0\n</code></pre> Solution <p>Containment is trivially computed using arithmetic and boolean operations as seen below. Note however, that checking for inclusion requires two arithmetic operations because of the use of <code>and</code>, whereas exclusion potentially requires only one when <code>v &lt; a</code> because <code>or</code> short-circuits the rest of the expression.</p> <pre><code>\"\"\" Outputs\n\"\"\"\ninside  = ( v &gt;= a ) and ( v &lt;= b )\noutside = ( v &lt;  a ) or  ( v &gt;  b )\ninside  = not outside\n</code></pre>"},{"location":"geometry/constructions/containment/#point-in-domain","title":"Point in Domain","text":"<p>Provided with a point <code>( u, v )</code> and a surface domain <code>( umin, umax )</code> and <code>( vmin, vmax )</code>, determine the condition such that the point is inside the domain.</p> <pre><code>\"\"\" Inputs\n\"\"\"\nu, v = 0.5, 0.5\numin, umax = 0.0, 1.0\nvmin, vmax = 0.0, 1.0\n</code></pre> Solution <p>Containment is computed using arithmetic and boolean operations in the same sense it is performed for a value in an interval. Note that this approach applies to the scenario of testing whether a 2D point in contained within an axis aligned bounding rectangle.</p> <pre><code>\"\"\" Outputs\n\"\"\"\ninside  = ( ( u &gt;= umin ) and ( u &lt;= umax ) and\n            ( v &gt;= vmin ) and ( v &lt;= vmax ) )\noutside = ( ( u &lt;  umin ) or  ( u &gt;  umax ) or\n            ( v &lt;  vmin ) or  ( v &gt;  vmax ) )\ninside  = not outside\n</code></pre>"},{"location":"geometry/constructions/containment/#point-in-bounding-box","title":"Point in Bounding Box","text":"<p>Provided with an axis aligned bounding box <code>( min, max )</code> where <code>min</code> and <code>max</code> are its extreme points, and a point <code>p</code>, determine the condition such that the point is inside the bounding box.</p> <pre><code>\"\"\" Inputs\n\"\"\"\np = Point3d( px, py, pz )\nmin = Point3d( xmin, ymin, zmin )\nmax = Point3d( xmax, ymax, zmax )\n</code></pre> Solution <p>Containment is computed using arithmetic and boolean operations in the same sense it is performed for a value in an interval and a point in a domain. Note that this approach can be used for checking whether a 3D parameter is within a volume domain.</p> <pre><code>\"\"\" Outputs\n\"\"\"\ninside  = ( ( p.X &gt;= min.X ) and ( p.X &lt;= max.X ) and\n            ( p.Y &gt;= min.Y ) and ( p.Y &lt;= max.Y ) and\n            ( p.Z &gt;= min.Z ) and ( p.Z &lt;= max.Z ) )\n\noutside = ( ( p.X &lt;  min.X ) or  ( p.X &gt;  max.X ) or\n            ( p.Y &lt;  min.Y ) or  ( p.Y &gt;  max.Y ) or\n            ( p.Z &lt;  min.Z ) or  ( p.Z &gt;  max.Z ) )\ninside  = not outside\n</code></pre>"},{"location":"geometry/constructions/containment/#point-in-circle","title":"Point in Circle","text":"<p>Provided with a circle <code>( o, r )</code> with origin <code>o</code> and radius <code>r</code> in the XY-Plane, and a point <code>p</code> determine the condition such that the point <code>p</code> is inside the circle.</p> <pre><code>\"\"\" Inputs\n\"\"\"\no, r = Point3d( ox, oy, oz ), 1.0\np    = Point3d( px, py, pz )\n</code></pre> Solution <p>Containment is computed using the Euclidean distance between the point and the circle's origin. Additionally, for overlap testing it is common to use a tolerance value to overcome potential numerical accuracy issues.</p> <pre><code>\"\"\" Without Tolerance\n\"\"\"\ndistance = p.DistanceTo( o )\ninside   = distance &lt; r\noutside  = distance &gt; r\n\n\"\"\" With Tolerance\n\"\"\"\nepsilon  = 1e-5 #-- Tolerance\noverlap  = abs( distance - r ) &lt;= epsilon\n</code></pre>"},{"location":"geometry/constructions/containment/#point-in-plane","title":"Point in Plane","text":"<p>Provided with a plane <code>( o, n )</code> with origin <code>o</code> and unit normal <code>n</code> and a point <code>p</code>, determine the condition such that the point is inside the plane.</p> <pre><code>\"\"\" Inputs\n\"\"\"\no, n = Point3d( ox, oy, oz ), Vector3d( nx, ny, nz )\np    = Point3d( px, py, pz )\n</code></pre> Solution <p>Containment in this scenario is associated with overlap, as such the projected distance from the point to the plane is computed using the dot product and its value is checked against a tolerance value.</p> <pre><code>\"\"\" Outputs\n\"\"\"\ndistance = n * ( p - o )\nepsilon  = 1e-5 #-- Tolerance\noverlap  = abs( distance ) &lt;= epsilon\n</code></pre>"},{"location":"geometry/constructions/containment/#point-in-half-space","title":"Point in Half-Space","text":"<p>Provided with a plane <code>( o, n )</code> with origin <code>o</code> and unit normal <code>n</code> and a point <code>p</code>, determine the condition such that the point is inside the positive half-space defined by the plane.</p> <pre><code>\"\"\" Inputs\n\"\"\"\no, n = Point3d( ox, oy, oz ), Vector3d( nx, ny, nz )\np    = Point3d( px, py, pz )\n</code></pre> Solution <p>Considering that a plane splits space into two parts, one in the positive direction of its normal and the opposite, this is a matter of computing the signed distance of projection using the dot product and checking its sign.</p> <pre><code>\"\"\" Without Tolerance\n\"\"\"\ndistance = n * ( p - o )\ninside   = distance &gt; 0\noutside  = distance &lt; 0\n\n\"\"\" With Tolerance\n\"\"\"\nepsilon  = 1e-5 #-- Tolerance\ninside   = distance &gt; -epsilon\noutside  = distance &lt;  epsilon\n</code></pre>"},{"location":"geometry/constructions/containment/#point-in-line-segment","title":"Point in Line Segment","text":"<p>Provided with line segment <code>( a, b )</code> defined by two points <code>a</code> and <code>b</code> and a point <code>p</code> on the line, determine the condition such that the point is within the line segment.</p> <pre><code>\"\"\" Inputs\n\"\"\"\na, b = Point3d( ax, ay, az ), Point3d( bx, by, bz )\np    = Point3d( px, py, pz )\n</code></pre> Solution <p>There are several ways to check this condition. One way is to measure the distance between the point and line's start and end points and check if their sum equals the line's length. This is reasonable because if the point is outside the line then the sum of distances will be larger than the line's length.</p> <p>Alternatively, the normalized parameter along the line <code>t</code> of point <code>p</code> can be computed. The point is within the line segment if the parameter is inside the unit-range. Note that this approach, on the positive side, does not compute square roots, but on the negative side, it will fail if the line segment's length is zero.</p> <pre><code>\"\"\" Using Distances\n\"\"\"\nL = a.DistanceTo( b )\nA = a.DistanceTo( p )\nB = b.DistanceTo( p )\n\ninside  = A + B &lt;= L  #- sketchy\noutside = A + B &gt;  L\n\n\"\"\" Using Parameter\n\"\"\"\nu, v = b - a, p - a\nt = ( u * v ) / ( u * u )\ninside  = ( t &gt;= 0.0 ) and ( t &lt;= 1.0 )\noutside = ( t &lt;  0.0 ) or  ( t &gt;  1.0 )\n</code></pre>"},{"location":"geometry/constructions/mappings/","title":"Mapping","text":"<p>The objective of this section is to cover geometric constructions using points and vectors. In particular, this section focuses on transforming or mapping points from local to world coordinates.</p>"},{"location":"geometry/constructions/mappings/#line-to-world","title":"Line to World","text":"<p>Provided with a line <code>( a, b )</code> defined by points <code>a</code> and <code>b</code>, and a point defined by a normalized parameter <code>t</code> along the line, determine its world position <code>p</code>.</p> <pre><code>\"\"\" Inputs\n\"\"\"\nt = 0.1\na = Point3d( ax, ay, az )\nb = Point3d( bx, by, bz )\n</code></pre> Solution <p>Assuming that the parameter is along the <code>a -&gt; b</code> direction, this is just an application of linear interpolation. There are two ways to implement this as seen below.</p> <pre><code>\"\"\" Outputs\n\"\"\"\np = a * ( 1 - t ) + b * t\n''' or '''\np = a + ( b - a ) * t\n</code></pre>"},{"location":"geometry/constructions/mappings/#world-to-line","title":"World to Line","text":"<p>Provided with a line <code>( a, b )</code> defined by points <code>a</code> and <code>b</code>, and another point <code>p</code>, express the point in terms of a normalized parameter <code>t</code> along the line.</p> <pre><code>\"\"\" Inputs\n\"\"\"\na = Point3d( ax, ay, az )\nb = Point3d( bx, by, bz )\np = Point3d( px, py, pz )\n</code></pre> Solution <p>The normalized parameter <code>t</code> represents the ratio between the projected distance of <code>v = p - a</code> onto the line and the line's length <code>|b - a|</code>. For example, when <code>t</code> is <code>0.0</code>, <code>0.5</code>, <code>1.0</code> the points projection coincides with <code>a</code>, the line's mid-point and <code>b</code>, respectively. If <code>t &lt; 0.0</code> or <code>t &gt; 1.0</code>, then the point's projection is outside the line segment.</p> <p>The projected distance can be derived from the dot product. The solution below shows first a step-by-step derivation, where the line's direction <code>u = b - a</code> is constructed, then the signed projected distance is computed using the dot product <code>s = v * u / |u|</code> and finally the parameter <code>t = s / |u|</code>.</p> <p>Note that since the expression involves dividing with the line segment's length twice, this is equivalent to its squared distance, which can be computed from the dot product without using square roots. Also note that this expression can lead to division by zero in case the line has zero length.</p> <pre><code>\"\"\" Outputs\n\"\"\"\nu = b - a\nv = p - a\n\nU = u.Length\ns = v * u / U\nt = s / U\n\n''' or '''\n\nt = ( u * v ) / ( u * u )\n</code></pre>"},{"location":"geometry/constructions/mappings/#plane-to-world","title":"Plane to World","text":"<p>Provided with a plane <code>( o, u, v )</code> with origin <code>o</code> and two orthonormal vectors, <code>u</code> and <code>v</code>, and a 2D point <code>p</code> on the plane, determine its world position <code>q</code>.</p> <pre><code>\"\"\" Inputs\n\"\"\"\no =  Point3d( ax, ay, az )\nu = Vector3d( ux, uy, uz )\nv = Vector3d( vx, vy, vz )\np =  Point2d( px, py )\n</code></pre> Solution <p>Computing the point's world coordinates is a simple application of the linear combinations vector arithmetic concept. Note that if a point is provided in a sense that it is already expressed in relationship with the basis this means that the expression below is a valid even if the basis vectors are not orthonormal.</p> <pre><code>\"\"\" Outputs\n\"\"\"\nq = o + u * p.X + v * p.Y\n</code></pre>"},{"location":"geometry/constructions/mappings/#world-to-plane","title":"World to Plane","text":"<p>Provided with a plane <code>( o, u, v )</code> with origin <code>o</code> and two orthonormal vectors, <code>u</code> and <code>v</code>, and another point <code>p</code>, determine its local coordinates in the plane.</p> <pre><code>\"\"\" Inputs\n\"\"\"\no =  Point3d( ax, ay, az )\nu = Vector3d( ux, uy, uz )\nv = Vector3d( vx, vy, vz )\np =  Point3d( px, py, pz )\n</code></pre> Solution <p>Expressing a world point in relationship with the plane requires first constructing a vector for the plane's origin to the points <code>w = p - o</code>, followed by projecting the vector on each basis vector. Note that this works only if the basis vectors are orthogonal to one another.</p> <pre><code>\"\"\" Outputs\n\"\"\"\nw = p - o\nq = Point2d( u * w, v * w )\n</code></pre>"},{"location":"geometry/constructions/mappings/#basis-to-world","title":"Basis to World","text":"<p>Provided with a basis <code>( o, u, v, n )</code> with origin <code>o</code> and three orthonormal vectors <code>u</code>, <code>v</code> and <code>n</code>, and another point <code>p</code> expressed in reference to basis, determine its world position <code>q</code>.</p> <pre><code>\"\"\" Inputs\n\"\"\"\no =  Point3d( ax, ay, az )\nu = Vector3d( ux, uy, uz )\nv = Vector3d( vx, vy, vz )\nn = Vector3d( nx, ny, nz )\np =  Point3d( px, py, pz )\n</code></pre> Solution <p>Computing the point's world coordinates is a simple application of the linear combinations vector arithmetic concept. Note that if a point is provided in a sense that it is already expressed in relationship with the basis this means that the expression below is a valid even if the basis vectors are not orthonormal.</p> <pre><code>\"\"\" Outputs\n\"\"\"\nq = o + u * p.X + v * p.Y + n * p.Z\n</code></pre>"},{"location":"geometry/constructions/mappings/#world-to-basis","title":"World to Basis","text":"<p>Provided with a basis <code>( o, u, v, n )</code> with origin <code>o</code> and three orthogonal vectors, <code>u</code>, <code>v</code> and <code>n</code>, and another point <code>p</code>, expressed in reference to the world, determine its local position in reference to basis.</p> <pre><code>\"\"\" Inputs\n\"\"\"\no =  Point3d( ax, ay, az )\nu = Vector3d( ux, uy, uz )\nv = Vector3d( vx, vy, vz )\nn = Vector3d( nx, ny, nz )\np =  Point3d( px, py, pz )\n</code></pre> Solution <p>Expressing a world point in relationship with the basis requires first constructing a vector for the basis' origin to the points <code>w = p - o</code>, followed by projecting the vector on each basis vector. Note that this works only if the basis vectors are orthogonal to one another.</p> <pre><code>\"\"\" Outputs\n\"\"\"\nw = p - o\nq = Point3d( u * w, v * w, n * w )\n</code></pre>"},{"location":"geometry/constructions/offsets/","title":"Offsets","text":"<p>The objective of this section is to cover geometric constructions using points and vectors. In particular this section focuses on shape offsets.</p>"},{"location":"geometry/constructions/offsets/#point","title":"Point","text":"<p>Provided with a point <code>p</code> and distance <code>d</code>, determine the shape of all points offset (having the same distance) by <code>d</code> from the point.</p> <pre><code>\"\"\" Inputs\n\"\"\"\nd = 2.0\np = Point3d( px, py, pz )\n</code></pre> Solution <p>The points equidistant from another point describe a sphere 3D space and a circle in 2D plane.</p> <pre><code>\"\"\" Outputs\n\"\"\"\ns = Sphere( p, d )\n</code></pre>"},{"location":"geometry/constructions/offsets/#line","title":"Line","text":"<p>Provided with a line <code>( p, q )</code> defined by two points <code>p</code>, and <code>q</code>, and distance <code>d</code>, determine the shape of all the points offset (having the same distance) by <code>d</code> from the line.</p> <pre><code>\"\"\" Inputs\n\"\"\"\nd = 2.0\np = Point3d( px, py, pz )\nq = Point3d( qx, qy, qz )\n</code></pre> Solution <p>The points equidistant from a line in 3D describe an infinitely long cylinder. The solution below constructs a finite cylindrical surface, since infinite shapes are generally not supported by computer aided design applications.</p> <pre><code>\"\"\" Outputs\n\"\"\"\ncylinder = Cylinder( Circle(\n    Plane( p, n ), q - p ),\n    p.DistanceTo( q ) )\n</code></pre>"},{"location":"geometry/constructions/offsets/#segment","title":"Segment","text":"<p>Provided with a line segment <code>( p, q )</code> defined by two points <code>p</code>, and <code>q</code>, and distance <code>d</code>, determine the shape of all the points offset (having the same distance) by <code>d</code>from the line segment.</p> <pre><code>\"\"\" Inputs\n\"\"\"\nd = 2.0\np = Point3d( px, py, pz )\nq = Point3d( qx, qy, qz )\n</code></pre> Solution <p>The points equidistant from a line segment in 3D describe a capsule shape, where projected points situated within the line segment correspond to a cylindrical surface, whereas points outside correspond to semi-spherical surfaces.</p> <pre><code>\"\"\" Outputs\n\"\"\"\na = Sphere( p, d )\nb = Cylinder( Circle(\n    Plane( p, q - p ), d ),\n    p.DistanceTo( q ) )\nc = Sphere( q, d )\n\ncapsule = Brep.CreateBooleanUnion( [\n    Brep.CreateFromSphere( a ),\n    Brep.CreateFromCylinder( b, True, True ),\n    Brep.CreateFromSphere( c )], 1e-5 )\n</code></pre>"},{"location":"geometry/constructions/offsets/#plane","title":"Plane","text":"<p>Provided with a plane <code>( a, b, c )</code> defined by three points <code>a</code>, <code>b</code>, <code>c</code>, determine all points offset by distance <code>d</code> from the plane.</p> <pre><code>\"\"\" Inputs\n\"\"\"\nd = 2.0\na = Point3d( ax, ay, az )\nb = Point3d( bx, by, bz )\nc = Point3d( cx, cy, cz )\n</code></pre> Solution <p>The points equidistant from a plane are situated on two offset planes, one in front and one at the back at a fixed distance. They are constructed by translating the plane's origin along the normal direction <code>+/-d</code>. Note that the back plane's normal must be flipped which is equivalent to swapping its basis vectors.</p> <pre><code>\"\"\" Outputs\n\"\"\"\no = a\nu = b - a\nv = c - b\nn = Vector3d.CrossProduct( u, v )\n\nu.Unitize( )\nv.Unitize( )\nn.Unitize( )\n\nfront = Plane( o + n * d, u, v )\nback  = Plane( o - n * d, v, u )\n</code></pre>"},{"location":"geometry/constructions/offsets/#triangle","title":"Triangle","text":"<p>Provided with a triangle <code>( a, b, c )</code> defined by three points <code>a</code>, <code>b</code>, <code>c</code>, determine all points offset by distance <code>d</code> from the triangle.</p> <pre><code>\"\"\" Inputs\n\"\"\"\nd = 2.0\na = Point3d( ax, ay, az )\nb = Point3d( bx, by, bz )\nc = Point3d( cx, cy, cz )\n</code></pre> Solution <p>The buffered shape produced by inflating a triangle can be composed using one sphere for each node, one cylinder for each edge and one extrusion for each face. Note that this approach can be used for offsetting a wide range of shapes into solids.</p> <pre><code>\"\"\" Outputs\n\"\"\"\npoints = [a, b, c]\nshapes = []\n\n\"\"\" Offset Direction\n\"\"\"\nn = Vector3d.CrossProduct( b - a, c - b )\nn *= d / n.Length\n\n\"\"\" One Sphere per Node\n\"\"\"\nfor point in points:\n    sphere = Sphere( point, d )\n    shapes.append( sphere.ToBrep( ) )\n\n\"\"\" One Cylinder per Edge\n\"\"\"\npoints.append( points[0] )\nfor s, t in zip( points[:-1], points[1:] ):\n    profile =  Circle( Plane( s, t - s ), d )\n    shape = Cylinder( profile, s.DistanceTo( t ) )\n    shapes.append( shape.ToBrep( True, True ) )\n\n\"\"\" One Extrusion per Face\n\"\"\"\npoints = [p - n for p in points]\nprofile = PolylineCurve( points )\nshapes.append( Extrusion.Create(\n    profile, d * 2, True ).ToBrep( ) )\n\n\"\"\" Inflated Triangle\n\"\"\"\ninflated = Brep.CreateBooleanUnion( shapes, 1e-5 )\n</code></pre>"},{"location":"geometry/constructions/perpendiculars/","title":"Perpendiculars","text":"<p>The objective of this section is to cover geometric constructions using points and vectors. In particular this section focused on raising and dropping perpendicular directions.</p>"},{"location":"geometry/constructions/perpendiculars/#vector-vector","title":"Vector - Vector","text":"<p>Provided with two vectors <code>u</code> and <code>v</code>, determine all vectors which are 90deg to both <code>u</code> and <code>v</code>.</p> <pre><code>\"\"\" Inputs\n\"\"\"\nu = Vector3d( ux, uy, uz )\nv = Vector3d( vx, vy, vz )\n</code></pre> Solution <p>A vector <code>w</code> orthogonal to <code>u</code> and <code>v</code> is produced by the cross product. All vector are multiples of <code>w * s</code> by a scaling factor <code>s</code>.</p> <p></p> <pre><code>\"\"\" Outputs\n\"\"\"\ndef Orthogonal( u, v, s ):\n    #-- u : Vector3d, v : Vector3d, s : float\n    #--\n    return Vector3d.CrossProduct( u, v ) * s\n</code></pre>"},{"location":"geometry/constructions/perpendiculars/#plane-line","title":"Plane - Line","text":"<p>Provided with a line segment <code>( p, q )</code> defined by two points <code>p</code>, and <code>q</code>, determine a plane perpendicular to the line segment at its mid-point.</p> <pre><code>\"\"\" Inputs\n\"\"\"\np = Point3d( px, py, pz )\nq = Point3d( qx, qy, qz )\n</code></pre> Solution <p>The origin of the plane is constructed by the average of the line segment's start and end points. The plane's normal is just the direction of the line.</p> <pre><code>\"\"\" Outputs\n\"\"\"\norigin = ( p + q ) / 2\nnormal = q - p\nplane  = Plane( origin, normal )\n</code></pre>"},{"location":"geometry/constructions/perpendiculars/#basis-vector","title":"Basis - Vector","text":"<p>Provided with a unit vector <code>u</code>, construct an orthonormal basis <code>( u, v, n )</code> by computing the vectors <code>v</code> and <code>n</code>.</p> <pre><code>\"\"\" Inputs\n\"\"\"\nu = Vector3d( ux, uy, uz )\n</code></pre> Solution <p>This is an application of the unary cross product concept, where one of the world's basis vector is used to produce a vector orthogonal to the input. The normal vector is then produced using another cross product between the previous two.</p> <p>Note that since the input vector <code>u</code> is unit-length, and the unary cross product uses another unit-length vector, their result ought to be also unit-length. Therefore, normalization is not required but generally performed to ensure no numerical issues arise.</p> <pre><code>\"\"\" Outputs\n\"\"\"\nv = Vector3d_CrossProductUnary( u )\nn = Vector3d.CrossProduct( u, v )\n\n#-- Optionally\n#--\nv.Unitize( )\nn.Unitize( )\n</code></pre>"},{"location":"geometry/constructions/perpendiculars/#basis-line","title":"Basis - Line","text":"<p>Provided with a line segment <code>( p, q )</code> defined by two points <code>p</code>, and <code>q</code>, determine a basis <code>( m, u, v, n )</code> perpendicular to the line segment at its mid-point <code>m</code>, where <code>u</code>, <code>v</code> and <code>n</code> are three orthonormal vectors.</p> <pre><code>\"\"\" Inputs\n\"\"\"\np = Point3d( px, py, pz )\nq = Point3d( qx, qy, qz )\n</code></pre> Solution <p>The origin of the basis is computed from the average of the points <code>( p + q ) / 2</code>, and the normal direction from their difference <code>q - p</code>. Constructing the orthogonal vectors is achieved by first applying the unary cross product concept to produce <code>u</code>, followed by another cross product <code>n x u</code>. All vectors are finally normalized.</p> <pre><code>\"\"\" Outputs\n\"\"\"\nm = ( p + q ) / 2\nn = ( q - p )\n\nu = Vector3d_CrossProductUnary( n )\nv = Vector3d.CrossProduct( n, u )\n\nu.Unitize( )\nv.Unitize( )\nn.Unitize( )\n</code></pre>"},{"location":"geometry/constructions/perpendiculars/#raise-perp","title":"Raise Perp","text":"<p>Provided with a line segment <code>( p, q )</code> defined by two points <code>p</code>, and <code>q</code>, on the plane <code>( p, n )</code>, where <code>n</code> is the plane's normal vector, determine a point <code>o</code> perpendicular to the line segment, in the plane, at distance <code>d</code> from point <code>q</code>.</p> <pre><code>\"\"\" Inputs\n\"\"\"\np =  Point3d( px, py, pz )\nq =  Point3d( qx, qy, qz )\nn = Vector3d( nx, ny, nz )\nd = 2.0\n</code></pre> Solution <p>The direction of the line segment <code>u = q - p</code> and the plane's normal <code>n</code> must be orthogonal since the segment is in the plane. Therefore, their cross product <code>v = u x n</code> shall produce a direction which is orthogonal to the line and within the plane. A point <code>o</code> therefore can be reached by translating <code>q</code> by either <code>d * v / |v|</code> or <code>-d * v / |v|</code>.</p> <pre><code>\"\"\" Outputs\n\"\"\"\nu = q - p\nv = Vector3d.CrossProduct( u, n )\nv.Unitize( )\n\no = q + v * d\n''' or ''''\no = q - v * d\n</code></pre>"},{"location":"geometry/constructions/polygons/","title":"Polygons","text":"<p>The objective of this section is to cover geometric constructions using points and vectors. In particular, this section focuses on polygons.</p>"},{"location":"geometry/constructions/polygons/#equilateral-triangle","title":"Equilateral Triangle","text":"<p>Determine the points <code>a, b, c</code> of an equilateral triangle in basis <code>( o, u, v, n )</code>, where <code>o</code> is the origin, <code>u</code>, <code>v</code> and <code>n</code> are its orthonormal basis vectors.</p> <pre><code>\"\"\" Inputs\n\"\"\"\no =  Point3d( ox, oy, oz )\nu = Vector3d( ux, uy, uz )\nv = Vector3d( vx, vy, vz )\nn = Vector3d( nx, ny, nz )\n</code></pre> Solution <p>One way to construct an equilateral triangle is to establish its coordinates in the world's XY-plane and then transform it to the arbitrary basis. Therefore, for convenience point <code>a</code> can be set at <code>[0.0, 0.0]</code>, point <code>b</code> at <code>[1.0, 0.0]</code> and point <code>c</code> at <code>[0.5, \u221a3/2]</code>.</p> <pre><code>\"\"\" Output\n\"\"\"\na = o + u * 0.0 + v * 0.0\nb = o + u * 1.0 + v * 0.0\nc = o + u * 0.5 + v * 0.5 * math.sqrt( 3 )\n</code></pre>"},{"location":"geometry/constructions/polygons/#inscribed-hexagon","title":"Inscribed Hexagon","text":"<p>Determine the points <code>a, b, c, d, e, f</code> of a hexagon inscribed in circle <code>( o, u, v, r )</code>, where <code>o</code> is the center, <code>u</code> and <code>v</code> are orthonormal basis vectors and <code>r</code> is the radius of the circle.</p> <pre><code>\"\"\" Inputs\n\"\"\"\no =  Point3d( ox, oy, oz )\nu = Vector3d( ux, uy, uz )\nv = Vector3d( vx, vy, vz )\nr = 2.0\n</code></pre> Solution <p>One way to construct the hexagon is by noticing that if it is conveniently registered in the world's XY-plane it is easy to transform it in any arbitrary basis. By setting the center of the circle to <code>[0, 0]</code> and the first point at <code>[r, 0]</code>, we only need to compute one more point <code>[r/2, r\u221a3/2]</code> and then use reflections about the <code>X</code> and <code>Y</code> axes to determine the locations of the remaining points.</p> <pre><code>\"\"\" Output\n\"\"\"\nx = r / 2\ny = x * math.sqrt( 3 )\n\na = o + u * r + v * 0\nb = o + u * x + v * y\nc = o - u * x + v * y\nd = o - u * r + v * 0\ne = o - u * x - v * y\nf = o + u * x - v * y\n</code></pre>"},{"location":"geometry/constructions/polygons/#regular-polygon","title":"Regular Polygon","text":"<p>Generate the points for a regular polygon of <code>n</code> sides, provided with its side's length <code>s</code> in the plane <code>( o, u, v )</code>, where <code>o</code> is the origin, <code>u</code> and <code>v</code> are its orthonormal basis vectors.</p> <pre><code>\"\"\" Inputs\n\"\"\"\no =  Point3d( ox, oy, oz )\nu = Vector3d( ux, uy, uz )\nv = Vector3d( vx, vy, vz )\ns = 2.0\nn = 12\n</code></pre> Solution <p>The simplest approach involves dividing a circle by the number of sides of the inscribed regular polygon. Thus the angle between consecutive radial line from the circle's center to the points of the polygon is <code>a = 2\u03c0 / n</code>. With a bit of trigonometry, the radius <code>r</code> and side <code>s</code> of the polygon are associated by <code>r = 0.5 * s / sin( a / 2 )</code>.</p> <pre><code>\"\"\" Output\n\"\"\"\ndef RegularPolygon( o, u, v, s, n ):\n    a = 2.0 * math.pi / n\n    r = 0.5 * s / math.sin( a / 2 )\n    return [( o + u * r * math.cos( a * i )\n                + v * r * math.sin( a * i ) )\n        for i in range( n )]\n</code></pre>"},{"location":"geometry/constructions/projections/","title":"Projections","text":"<p>The objective of this section is to cover geometric constructions using points and vectors. In particular, this section focuses on projections.</p>"},{"location":"geometry/constructions/projections/#point-on-sphere","title":"Point on Sphere","text":"<p>Provided with a sphere <code>( c, r )</code>, defined by its center point <code>c</code> and radius <code>r</code>, and a second point <code>p</code>, determine the location of the point of <code>q</code> projection from <code>p</code> onto the sphere.</p> <pre><code>\"\"\" Inputs\n\"\"\"\nc = Point3d( cx, cy, cz )\np = Point3d( px, py, pz )\nr = 2.0\n</code></pre> Solution <p>Geometrically we can consider the projection as a translation from the point in space onto the sphere along the direction between the point and the sphere's center. Alternatively, we can consider moving from the sphere's center towards the point but no more than the sphere's radius. The later approach is actually very simple to compute as follows:</p> <ol> <li>Construct a vector <code>u</code> from the center <code>c</code> of the sphere to the point we wish to project <code>p</code>.</li> <li>Normalize the vector <code>u</code> to retain its direction but set its length to <code>1.0</code>.</li> <li>Translate the center of the sphere <code>c</code> towards <code>u</code> scaled by the radius of the sphere <code>r</code>.</li> </ol> <pre><code>\"\"\" Outputs\n\"\"\"\nu = p - c\nu.Unitize( )\nq = c + u * r\n</code></pre> <p>Using the rhino / grasshopper geometry library requires constructing a <code>Sphere</code> object and the using its <code>ClosestPoint( )</code> method.</p> <pre><code>\"\"\" Outputs\n\"\"\"\ns = Sphere( c, r )\nq = s.ClosestPoint( p )\n</code></pre>"},{"location":"geometry/constructions/projections/#point-on-line","title":"Point on Line","text":"<p>Provided with a line <code>( o, u )</code>, defined by its origin <code>o</code> and a unit direction <code>u</code>, and a point <code>p</code>, determine the location of the point of projection <code>q</code> from <code>p</code> onto the line.</p> <pre><code>\"\"\" Inputs\n\"\"\"\no =  Point3d( ox, oy, oz )\nu = Vector3d( ux, uy, uz )\np =  Point3d( px, py, pz )\n</code></pre> Solution <p>This construction is based on the property of performing a dot product between two vectors one of which is unit-length. From trigonometry, the dot product gives the projected length of the non-unit vector on the unit vector which can use to translate the origin to the point of projection.</p> <ol> <li>Create a vector <code>v</code> from the line's origin <code>o</code> towards the point in space <code>p</code>.</li> <li>Compute the projected length <code>d</code> of <code>v</code> onto <code>u</code> using the dot product.</li> <li>Translate the line's origin <code>o</code> along the line's direction scaled by <code>d</code>.</li> </ol> <pre><code>\"\"\" Outputs\n\"\"\"\nv = p - o\nd = u * v\nq = o + u * d\n</code></pre> <p>Using the rhino / grasshopper geometry library requires constructing a <code>Line</code> object and using the <code>ClosestPoint( )</code> method. Note that the second parameter controls whether the line is considered finite or infinite.</p> <pre><code>\"\"\" Outputs\n\"\"\"\nl = Line( o, u )\nq = l.ClosestPoint( p, False )\n</code></pre>"},{"location":"geometry/constructions/projections/#point-on-plane","title":"Point on Plane","text":"<p>Provided with a plane <code>( o, n )</code> defined by its origin point <code>o</code> and the unit normal vector <code>n</code>, and another point <code>p</code>, determine the location of the point of projection <code>q</code> from <code>p</code> onto the plane.</p> <pre><code>\"\"\" Inputs\n\"\"\"\no =  Point3d( ox, oy, oz )\nn = Vector3d( nx, ny, nz )\np =  Point3d( px, py, pz )\n</code></pre> Solution <p>The logic of this projection is exactly the same as projecting onto a line. It uses the 'projected length' property of the dot product. The only difference is that here we are moving from the point in space onto the plane. Therefore, we need to negate the result of the dot product.</p> <ol> <li>Create a vector <code>v</code> from the plane's origin <code>o</code> towards the point in space <code>p</code>.</li> <li>Compute the projected length <code>d</code> of <code>v</code> onto <code>n</code> using the dot product.</li> <li>Translate the point <code>p</code> against the plane's normal <code>n</code> scaled by <code>d</code>.</li> </ol> <pre><code>\"\"\" Outputs\n\"\"\"\nv = p - o\nd = u * v\nq = p - n * d\n</code></pre> <p>Using the rhino / grasshopper geometry library requires constructing a <code>Plane</code> object and using the <code>ClosestPoint( )</code> method.</p> <pre><code>\"\"\" Outputs\n\"\"\"\nP = Plane( o, n )\nq = P.ClosestPoint( p )\n</code></pre>"},{"location":"geometry/constructions/projections/#point-on-circle","title":"Point on Circle","text":"<p>Provided with a circle <code>( c, n, r )</code>, defined by its center point <code>c</code>, unit normal vector <code>n</code>, and radius <code>r</code>, and another point <code>p</code>, determine the location of the point of projection <code>q</code> from <code>p</code> onto the circle.</p> <pre><code>\"\"\" Inputs\n\"\"\"\nr =  2.0\nc =  Point3d( cx, cy, cz )\nn = Vector3d( nx, ny, nz )\np =  Point3d( px, py, pz )\n</code></pre> Solution <p>Since a circle is a planar curve and the point <code>p</code> is not on the same plane, this requires two projections: first on the plane <code>o = p - n * ( p - c ) * n</code> and next on the circle <code>q = c + r * ( o - c ) / | o - c |</code>.</p> <pre><code>\"\"\" Outputs\n\"\"\"\no = p - n * ( p - c ) * n\nu = o - c; u.Unitize( )\nq = c + r * u\n</code></pre> <p>Another way to think about this is by considering the plane spanned by the normal <code>n</code> and the vector <code>u = p - c</code> intersecting the circle. The vector <code>w = n x u x n</code> expresses the projection of <code>u</code> on the plane, thus the projection can be compute using <code>q = c + r * w / |w|</code>.</p> <pre><code>\"\"\" Outputs\n\"\"\"\nw = Vector3d.CrossProduct(\n        Vector3d.CrossProduct(\n            n, p - c ), n )\nw.Unitize( )\nq = c + r * w\n</code></pre>"},{"location":"geometry/constructions/projections/#point-on-a-cylinder","title":"Point on a Cylinder","text":"<p>Provided with a cylinder <code>( o, u, r )</code>, defined its the origin point <code>o</code>, axis direction <code>u</code>, and radius <code>r</code>, and another point, <code>p</code>, determine the location of the point of projection <code>q</code> from <code>p</code> onto the cylinder.</p> <pre><code>\"\"\" Inputs\n\"\"\"\nr =  2.0\no =  Point3d( ox, oy, oz )\nu = Vector3d( ux, uy, uz )\np =  Point3d( px, py, pz )\n</code></pre> Solution <p>The projection point <code>q</code> can be constructed by first projecting <code>p</code> on the cylinder's axis producing point <code>a</code> and then moving out of the cylinder towards the point in space, <code>w = p - a</code> by distance equal to the radius, and therefore <code>q = a + r * w / |w|</code>. Note that the cylinder's direction is assumed unit-length, otherwise it must be normalized.</p> <pre><code>\"\"\" Outputs\n\"\"\"\nv = p - o           #-- Origin to Point\na = o + u * v * u   #-- Projection on Axis\nw = p - a           #-- Orthogonal to Point\nw.Unitize( )        #--\nq = a + w * r       #-- Point of Projection\n</code></pre>"},{"location":"geometry/constructions/projections/#point-on-a-cone","title":"Point on a Cone","text":"<p>Provided with a cone <code>( o, a, r )</code>, defined by two points of its axis <code>( o, a )</code>, where <code>a</code> is its apex, <code>o</code> is its base point where its radius is <code>r</code>, and another point <code>p</code>, determine the location of the point of projection <code>q</code> from <code>p</code> onto the cone.</p> <pre><code>\"\"\" Inputs\n\"\"\"\nr =  2.0\no =  Point3d( ox, oy, oz )\na =  Point3d( ax, ay, az )\nu = Vector3d( ux, uy, uz )\np =  Point3d( px, py, pz )\n</code></pre> Solution <p>Finding the point of projection <code>q</code> is a two step process: first the line of the intersection <code>a -&gt; b</code> between the cone and the plane spanned by its apex <code>a</code>, origin <code>o</code> and point <code>p</code> is computed, followed by projecting the point <code>p</code> onto the line <code>q = a + x * ( p - a ) * x</code>, where <code>x = ( b - a ) / | b - a |</code>. Therefore, computing the point <code>b</code> requires some consideration.</p> <p>There are several ways to approach this including basic trigonometry, surface-plane intersection and even rotation. However, there is simple solution if we consider that the point <code>b</code>  may be computed by translation from the cylinder's origin <code>o</code> by distance <code>r</code> towards a direction which is orthogonal to its axis and the normal of the plane.</p> <pre><code>\"\"\" Cylinder's Axis and Apex -&gt; Point Vector\n\"\"\"\nu = o - a; u.Unitize( )\nv = p - a\n\n\"\"\" Plane's Normal and Orthogonal to Axis x Normal\n\"\"\"\nn = Vector3d.CrossProduct( u, v )\nw = Vector3d.CrossProduct( n, u ) #-- order matters!\nw.Unitize( )\n\n\"\"\" Point on Generatrix and its Direction\n\"\"\"\nb = o + r * w\nx = b - a; x.Unitize( )\n\n\"\"\" Point of Projection\n\"\"\"\nq = a + x * v * x\n</code></pre>"},{"location":"geometry/constructions/reflections/","title":"Reflections","text":"<p>The objective of this section is to cover geometric constructions using points and vectors. In particular this section focuses on reflecting shapes about other shapes.</p>"},{"location":"geometry/constructions/reflections/#point-about-point","title":"Point about Point","text":"<p>Provided with a point <code>p</code> and another point <code>o</code>, determine the location of the point of reflection <code>q</code> from <code>p</code> about <code>o</code>.</p> <pre><code>\"\"\" Inputs\n\"\"\"\np = Point3d( px, py, pz )\no = Point3d( ox, oy, oz )\n</code></pre> Solution <p>We can consider the reflection in the sense of translating point <code>p</code> against the direction to <code>o</code> by the same length. This is also equivalent to moving from <code>p</code>, twice the distance to <code>o</code> along the same direction. Therefore, first we construct the vector <code>u = p - o</code> and the perform the translation <code>q = p - u</code>, which can be expanded to <code>q = p + ( p - o )</code> or simply <code>q = 2 * p - o</code>.</p> <pre><code>\"\"\" Outputs\n\"\"\"\nu = p - o\nq = p + u\n''' or '''\nq = 2 * p - o\n</code></pre>"},{"location":"geometry/constructions/reflections/#point-about-line","title":"Point about Line","text":"<p>Provided a line <code>( o, u )</code>, defined by its origin point <code>o</code> and the unit direction <code>u</code>, and a second point <code>p</code>, determine the location of the point of reflection from <code>q</code> about the line.</p> <pre><code>\"\"\" Inputs\n\"\"\"\no =  Point3d( ox, oy, oz )\nu = Vector3d( ux, uy, uz )\np =  Point3d( px, py, pz )\n</code></pre> Solution <p>The reflection can be performed by first projecting the point <code>p</code> onto the line by computing the point <code>x = o + u * ( p - o ) * u</code>and the translating it by the same projected distance and direction <code>q = x + ( x - p )</code>.</p> <pre><code>\"\"\" Outputs\n\"\"\"\nx = o + u * ( p - o ) * u\nq = x + ( x - p )\n''' or '''\nq = 2 * x - p\n</code></pre>"},{"location":"geometry/constructions/reflections/#point-about-plane","title":"Point about Plane","text":"<p>Provided with a plane <code>( o, n )</code> defined by its origin point <code>o</code> and the unit normal vector <code>n</code>, and another point <code>p</code>, determine the location of the point of reflection from <code>p</code> about the plane.</p> <pre><code>\"\"\" Inputs\n\"\"\"\no =  Point3d( ox, oy, oz )\nn = Vector3d( nx, ny, nz )\np =  Point3d( px, py, pz )\n</code></pre> Solution <p>The operation can be performed by first projecting the point <code>p</code> onto the plane by computing point <code>x = p - n * ( p - o ) * n</code>, and then translating it about the same direction and distance to <code>q = x + ( x - p )</code>.</p> <p></p> <pre><code>\"\"\" Outputs\n\"\"\"\nx = p - n * ( p - o ) * n\nq = x + ( x - p )\n''' or '''\nq = 2 * x - p\n</code></pre>"},{"location":"geometry/constructions/reflections/#point-about-circle","title":"Point about Circle","text":"<p>Provided with a circle <code>( o, r )</code>, defined by its center point <code>o</code> and radius <code>r</code>, and a second point on the circle, <code>p</code>, determine the location of the point <code>q</code> diametrically opposite from <code>p</code>.</p> <pre><code>\"\"\" Inputs\n\"\"\"\nr =  2.0\no =  Point3d( ox, oy, oz )\np =  Point3d( px, py, pz )\n</code></pre> Solution <p>This problem has exactly the same solution as reflecting a point about another point. Since the point <code>p</code> is already on the circle, its reflection about the center should also land on the circle.</p> <pre><code>\"\"\" Outputs\n\"\"\"\nu = p - o\nq = p + u\n''' or '''\nq = 2 * p - o\n</code></pre>"},{"location":"geometry/constructions/reflections/#the-death-star","title":"The Death Star","text":"<p>Provided with a point <code>s</code>, another point <code>r</code> and a third point <code>t</code>, determine two basis vectors <code>u</code> and <code>v</code> of a plane <code>( r, u, v )</code>, such that a ray emanating from the source point <code>s</code>, reaching a reflector disk on plane at <code>r</code>, will redirect the ray such that it will hit the target point <code>t</code>.</p> <pre><code>\"\"\" Inputs\n\"\"\"\nr =  Point3d( rx, ry, rz )\ns =  Point3d( sx, sy, sz )\nt =  Point3d( tx, ty, tz )\n</code></pre> Solution <p>The problem can be approach by assuming that the angle of incidence on flat reflective surface equals the angle of reflection. Therefore, the normal direction <code>n</code> of the reflector plane must be the bisector of the angle of the triangle <code>( r, s, t )</code> at point <code>r</code>. Furthermore, to compute the basis vectors of a plane defined by its origin and normal direction requires using the unary cross product concept.</p> <pre><code>\"\"\" Outputs\n\"\"\"\nu = s - r; u.Unitize( )\nv = t - r; v.Unitize( )\nn = u + v; n.Unitize( ) #-- Bisector == Normal\nu = Vector3d_UnaryCrossProduct( n )\nv = Vector3d.CrossProduct( n, u )\n</code></pre>"},{"location":"geometry/curves/","title":"Curve Geometry","text":"<p>The objective of this section is to introduce concepts associated with planar and spatial curves. There are three very important operations related to surfaces:</p> <ol> <li>Evaluation: Forward mapping from R \u2192 R<sup>3</sup>, that is <code>t \u2192 [x, y, z]</code>.</li> <li>Derivatives: Geometric properties associated with differential concepts.</li> <li>Projection: Inverse mapping from R<sup>3</sup> \u2192 R, that is <code>[x, y, z] \u2192 t</code>.</li> </ol>"},{"location":"geometry/curves/#representations","title":"Representations","text":"<p>There are several ways to represent curves even for the same underlying geometry. The unit circle for instance can be expressed in at least four different ways. These formulas represent the same shape but offer different intuition and tools for operating with them.</p> <ol> <li>Explicit y = \u00b1sqrt( 1 - x<sup>2</sup> ), where -1 \u2264 x \u2264 1</li> <li>Implicit x<sup>2</sup> + y<sup>2</sup> = 1, where x, y : R</li> <li>Parametric [ x, y ] = [ cos( a ), sin( a ) ], where 0 \u2264 a &lt; 2\u03c0</li> <li>Rational [ x, y ] = [ ( 1 - t<sup>2</sup> ) / ( 1 + t<sup>2</sup> ), 2t / ( 1 + t<sup>2</sup> ) ], where t : R</li> <li>Empirical  [[x1, y1], [x2, y2], ..., [xn, yn]], where x, y : R</li> </ol>"},{"location":"geometry/curves/#explicit","title":"Explicit","text":"<p>The explicit form describes the unit circle in the sense of a bar graph expressing the height, or by how much we need to move up and down along the Y-axis, as we move along the X-axis. Curves of the <code>f( x ) = y</code> form often suffer from the geometric intuition perspective. The unit circle for instance has two \u00b1parts instead of just one. While the range of valid values for <code>x</code> is well-defined <code>[-1, 1]</code>, values outside of it are problematic. However, a nice property of this form is that it is trivially computable <code>y = lambda x : math.sqrt( 1 - x * x )</code>.</p> <p></p>"},{"location":"geometry/curves/#implicit","title":"Implicit","text":"<p>The implicit form describes the constraints we need to adhere to for being exactly on the circle. We are free to choose any point in the plane, expressed by their coordinates <code>x</code> and <code>y</code>, as long as the point's square distance from the origin is exactly one. This can be trivially transformed to computation <code>IsPointOnCircle = lambda x, y: abs( x * x + y * y - 1 ) &lt;= e-17</code>. It also implies that points where x<sup>2</sup> + y<sup>2</sup> &gt; 1 are outside the circle while x<sup>2</sup> + y<sup>2</sup> &lt; 1 are inside the circle. Therefore, we can interpret it as a recipe for  circle containment testing.</p> <p></p>"},{"location":"geometry/curves/#parametric","title":"Parametric","text":"<p>The parametric form describes the motion of a point around the circle, as if it was drawn by a compass or a person walking around it. It provides a handle for tracking the progress made, associated with the angle <code>a</code> between the X-axis and radial direction. The angle <code>a</code> is notionally bounded to <code>[0, 2\u03c0)</code> but even if we go out of bounds, say <code>-\u03c0</code> or <code>4\u03c0</code>, we are still on the circle. In that sense it does enforce a constraint on the motion. It is also trivially computable using the expression <code>PointOnCircle = lambda angle: ( math.cos( a ), math.sin( a ) )</code>.</p> <p></p>"},{"location":"geometry/curves/#rational","title":"Rational","text":"<p>The rational form describes the point of intersection between a line from <code>[-1, 0]</code> and a point on the circle <code>[x, y]</code> with the Y-axis at <code>[0, t]</code>. The geometric intuition is unusual but constructive. It is rational in that it describes points on a circle based only on division of polynomials, that is without transcendental functions. The parameter <code>t</code> can take any real value but the point <code>[-1, 0]</code> can only be reached when <code>t</code> becomes infinite. Computationally it is also trivial to encode as <code>PointOnCircle = lambda t : ( ( 1 - t * t ) / ( 1 + t * t ), 2 * t / ( 1 + t * t ) )</code> and efficient because it only requires basic arithmetic. However, floating point numbers have finite precision so the accuracy is not equal for every point on the circle.</p> <p></p>"},{"location":"geometry/curves/#empirical","title":"Empirical","text":"<p>Measuring physical objects results into collections of data points used for fitting analytical shapes. This is performed via either interpolation, where a curve passes through the data points or approximation, where the curve passes as close as possible about the data points. Curve fitting is performed via statistical error minimization methods such as regression.The need for regression is because there are often more than enough data points but also because of the need to account for the errors present in the data, due to their empirical measurement sourcing.</p> <p></p>"},{"location":"geometry/curves/#operations","title":"Operations","text":"<p>Generally parametric forms are preferred in computational geometry because they allow for a unified approach in accessing some important properties of curves, namely addressing consecutive points, computing tangent vectors and coordinate systems along them.</p>"},{"location":"geometry/curves/#evaluation","title":"Evaluation","text":"<p>Provided with a parametric curve <code>C( t )</code>, a point <code>p</code> on the curve is evaluated by <code>p = C( t )</code>, where <code>t</code> is the common way to name the parameter along the curve.  Note that depending on the curve, <code>p</code> can be <code>2D</code> as is <code>p = [x, y]</code> or <code>3D</code> as in <code>p = [x, y, z]</code>. For instance, a unit circle in the XY-plane is <code>C( t ) = [cos( t ), sin( t )]</code> and a line between points <code>a = [xa, ya, za]</code> and <code>b = [xb, yb, zb]</code> is <code>C( t ) = a * ( 1 - t ) + b * t</code>.</p> <p></p> <p>In Rhino the <code>Curve</code> interface, which most curves comply with, captures the notion of a point-on-curve via the <code>PointAt( )</code> method.</p> <pre><code>\"\"\" Various Curves\n\"\"\"\ncurve = Line(\n    Point3d( xa, ya, za ),\n    Point3d( xb, yb, zb ) )\n\ncurve = Circle(\n    Point3d( xc, yc, 0.0 ), 1.0 )\n\ncurve = NurbsCurve.Create( False, 2,\n    [Point3d( xa, ya, za ),\n     Point3d( xb, yb, zb ),\n     Point3d( xc, yc, zc )] )\n\n\"\"\" The PointAt Method\n\"\"\"\npoint = curve.PointAt( t )\n</code></pre>"},{"location":"geometry/curves/#domain","title":"Domain","text":"<p>The range of allowed values for a curve's parameter <code>t</code> is known as the curve's domain. Domains are specified by using intervals such as <code>[-1, 1]</code>, <code>[0, +oo)</code> and <code>R</code> or in general <code>[min, max]</code>.</p> <p>For parametric curves, it is common to use the unit domain <code>[0, 1]</code>. Using the same unit domain for every curve is convenient because we don't need to store the <code>[min, max]</code> values. Therefore, unless otherwise specified, the domain of a parametric curve can be assumed as <code>[0, 1]</code>. The unit domain conceptually can be interpreted as a percentage or time of travel along the curve.</p> <p></p> <p>Explicitly specifying the domain of a curve offers the ability to express bounded curves. This is useful because notionally curves do not have a start and an end point. By using domains their start and end points become the minimum and maximum parameters of their domains. This approach captures the concept of a curve segment as a part of an unbounded curve, for instance a linear segment or circular arc are bounded versions of a line and a circle, respectively.</p>"},{"location":"geometry/curves/#parameterization","title":"Parameterization","text":"<p>Changing the domain of curve from one range to another is also known as reparameterization. The two most popular domains we may wish to adopt are: (a) the unit range <code>[0, 1]</code> and (b) the arc-length range <code>[0, s]</code>, where <code>s</code> expresses the distance traveled.</p> <p>For example, the circle <code>C( a ) = r[cos( a ), sin( a )]</code> with radius <code>r</code> is parameterized by angle <code>a</code> in <code>[0, 2\u03c0]</code>. Its perimeter is <code>2\u03c0r</code>, therefore <code>C( s ) = r[cos( a/r ), sin( a/r )]</code> is parameterized by arc-length <code>s</code> in <code>[0, 2\u03c0r]</code>. In the same sense we can use the unit domain, where the circle <code>C( t ) = r[cos( 2\u03c0t ), sin( 2\u03c0t )]</code> is defined with <code>t</code> in <code>[0, 1]</code>.</p> <p>Note that it is almost never as easy to reparameterize arbitrary curves. The use of arc-length parameterization is useful for performing mathematical operations because it gets rid of square roots involved in length computations. The unit range is typically used for most computational geometry curves.</p> <p>In Rhino a curve's domain can be accessed using the <code>Domain</code> property. The returned value is an <code>Interval</code> which contains the <code>Min</code> and <code>Max</code> values. Note that curve domains are read-only.</p> <pre><code>\"\"\" Curve Domain\n\"\"\"\ncurve = Circle(\n    Point3d( xc, yc, 0.0 ), 1.0 )\n\nprint( curve.Domain )\n\nt_min = curve.Domain.Min\nt_max = curve.Domain.Max\n\nprint( t_min, t_max )\n</code></pre>"},{"location":"geometry/curves/#points-on-curve","title":"Points on Curve","text":"<p>Evaluating a number of consecutive points along a curve often uses the idiom seen below. The <code>index</code> and <code>count</code> values are translated into a unit-range parameter <code>index / ( count - 1 )</code>, before <code>PointAt( )</code> is called. However, this only works for curves with unit domain <code>[0, 1]</code>.</p> <pre><code>\"\"\" Normalized Parameters\n\"\"\"\nus = [index / ( count - 1 )\n    for index in range( count )]\n\n\"\"\" Points on Normalized Curve\n\"\"\"\npoints [curve.PointAt( u )\n    for u in us]\n</code></pre> <p>The proper way to map parameters from the unit-range onto the curve's domain requires a form of interpolation such as linear interpolation as seen below.</p> <pre><code>\"\"\" Normalized Parameters\n\"\"\"\nus = [index / ( count - 1 )\n    for index in range( count )]\n\n\"\"\" Parameters in Curve's Domain\n\"\"\"\nts = [( curve.Domain.Min * ( 1 - u ) +\n        curve.Domain.Max * (     u ) )\n    for u in us]\n\n\"\"\" Points on Curve's Domain\n\"\"\"\npoints [curve.PointAt( t )\n    for t in ts]\n</code></pre> <p>The <code>Interval</code> object provides a couple of useful methods namely <code>ParameterAt( )</code> which converts parameters from the unit-range onto the curve's domain, exactly seen earlier, and <code>NormalizedParameterAt( )</code> which does the opposite conversions, namely from a domain value to a unit-range value.</p> <pre><code>\"\"\" Normalized Parameters\n\"\"\"\nus = [index / ( count - 1 )\n    for index in range( count )]\n\n\"\"\" Parameters in Curve's Domain (shortcut)\n\"\"\"\nts = [curve.ParameterAt( u )\n    for u in us]\n\n\"\"\" Points on Curve's Domain\n\"\"\"\npoints [curve.PointAt( t )\n    for t in ts]\n</code></pre> <p>Note that curves provide the <code>DivideByCount( )</code> method which can be used as a shortcut to perform the operation presented above. Additionally, for evaluating points using arc-length parameterization, the <code>PointAtLength( )</code> method can be used.</p> <pre><code>\"\"\" Parameters in Curve's Domain (shortcut)\n\"\"\"\nts = curve.DividedByCount( count - 1, True )\n\n\"\"\" Points on Curve's Domain\n\"\"\"\npoints [curve.PointAt( t )\n    for t in ts]\n</code></pre>"},{"location":"geometry/curves/#curve-length","title":"Curve Length","text":"<p>Length is measured within a domain interval <code>[a, b]</code> along a curve <code>C( t )</code>. The mathematical expression involves derivatives and integrals, namely <code>\u222b[a, b]|C'( t )|dt</code> which expands to <code>\u222b[a, b]sqrt( ( dx / dt ) ** 2 + ( dy / dt ) ** 2 + ( dz / dt )** 2 ) dt</code>. For a few curves this can be computed analytically, that is we can actually derive a closed-form solution, but for most, an approximation can be used <code>\u03a3[a, b] |C( t + dt ) - C( t )|</code>.</p> <p>Geometrically this expression states that the length along a curve can be computed by the sum of many small linear segments. The code below demonstrates how to approximate a curve's length step by step trying to be as close to the definition above.</p> <pre><code>\"\"\" Normalized Parameters\n\"\"\"\nus = [index / ( count - 1 )\n    for index in range( count )]\n\n\"\"\" Parameters in [a, b]\n\"\"\"\nts = [a * ( 1 - u ) + b * u\n    for u in us]\n\n\"\"\" Points on Curve\n\"\"\"\npoints = [curve.PointAt( t )\n    for t in ts]\n\n\"\"\" Segment Vectors\n\"\"\"\nvectors = [( b - a )\n    for a, b in zip( points[:-1], points[1:] )]\n\n\"\"\" Vector Lengths\n\"\"\"\nlengths = [vector.Length\n    for vector in vectors]\n\n\"\"\" Curve Length\n\"\"\"\nlength = sum( lengths )\n</code></pre> <p>Rhino provides the <code>GetLength( )</code> method which computes a curve's length. Without parameters is computes the length of the entire curve, while by passing an <code>Interval</code> can be used for computing the length as shown above.</p> <pre><code>\"\"\" Curve Length\n\"\"\"\ncurve = Circle( Point3d.Origin, 1.0 )\n\n\"\"\" Full Circle\n\"\"\"\nlength = curve.GetLength( )\n\n\"\"\" Half Circle\n\"\"\"\nlength = curve.GetLength( Interval( 0.0, math.pi ) )\n</code></pre>"},{"location":"geometry/curves/#derivatives","title":"Derivatives","text":""},{"location":"geometry/curves/#tangent","title":"Tangent","text":"<p>The derivatives of parametric curves <code>C( t ) = p</code> convey very important geometric properties. The first derivative <code>C'( t ) = U</code> represents the tangent vector <code>T = U / |U|</code> at parameter <code>t</code>. The tangent vector is associated with a line <code>{ p, T }</code> that best-fits the curve locally. The length of the first derivative <code>|U|</code> captures how the curve's length changes over <code>t</code>, which is close to the notion of speed in physics.</p> <p>The tangent never becomes the zero vector, for curves that are continuous and not degenerate in some sense, such as a line defined by the same two points. However, is some cases it may yield two different directions, based on the side <code>t</code> is approached. This is common for curves, that are not continuously differentiable in the sense that they contain cusp points.</p> <p>A derivative can be approximately computed by evaluating two nearby points and computing the tangent vectors as seen below.</p> <pre><code>\"\"\" Finite dt\n\"\"\"\ndt = 1e-5\n\n\"\"\" C( t ) and C( t + dt )\n\"\"\"\np = curve.PointAt( t )\nq = curve.PointAt( t + dt )\n\n\"\"\" Finite Tangent C'( t )\n\"\"\"\nU = ( q - p ) / dt\n</code></pre> <p>The exact derivative requires limits, where <code>dt \u2192 0</code>. Nevertheless, the above approximation, also known as a finite difference, demonstrates that derivatives of curves are type-wise vectors since they involved subtraction between points. If we do not care about the length of the derivative, it is best to not divide by a small number but instead just normalize the vector.</p> <pre><code>\"\"\" Finite Unit Tangent\n\"\"\"\nT = ( curve.PointAt( t + dt ) -\n      curve.PointAt( t ) )\nT.Unitize( )\n</code></pre> <p>In Rhino tangent vectors can be computed analytically using the <code>TangentAt( )</code> method provided by the <code>Curve</code> interface, where <code>t</code> is the parameter in the curve's domain. Note however that the <code>TangentAt( )</code> method returns a normalized vector, therefore the speed content is missing.</p> <pre><code>\"\"\" Exact Unit Tangent\n\"\"\"\np = curve.PointAt( t )\nT = curve.TangentAt( t )\n</code></pre>"},{"location":"geometry/curves/#normal","title":"Normal","text":"<p>The second derivative of a curve <code>C''( t ) = V</code> is associated with the normal vector computed as <code>N = U x V x U / |U x V x U|</code> of the curve at parameter <code>t</code>. The normal is orthogonal to the tangent <code>T \u00b7 N = 0</code> and represents the direction of projection <code>N</code> onto the curve at point <code>C( t )</code> in the sense of a perpendicular line <code>{ p, N }</code>.</p> <p>Semantically, the second derivative <code>C''( t )</code> captures the rate by which a curve is changing direction or bending. This is also associated with a circle that best-fits the curve locally known as the circle of curvature. The circle's radius <code>r</code> is associated the concept of the curvature defined as <code>\u03ba = 1 / r</code> at parameter <code>t</code>.The circle's center is located at <code>c = p + N / \u03ba</code>. The curvature at every point along a curve can be computed using <code>\u03ba = |U x V| / |U| ** 3</code>.</p> <p>The second derivative is not always well-defined. This does not only include the cases presented regarding the behavior of the tangent but also simpler cases such as a line for instance. Also, the normal vanishes at points where the curve flips direction, also known as points of inflection.</p> <p>Rhino does not provide a <code>NormalAt( )</code> but instead a <code>CurvatureAt( )</code> method. It returns a vector with the same direction as the normal and length equal to the curvature at <code>t</code>.</p> <pre><code>\"\"\" Curvature Vector\n\"\"\"\nu = curve.CurvatureAt( t )\n\n\"\"\" Curvature\n\"\"\"\n\u03ba = u.Length\n\n\"\"\" Normal Vector\n\"\"\"\nN = Vector3d( u )\nN.Unitize( )\n</code></pre> <p>Alternatively, the <code>DerivativeAt( )</code> can used, where the first argument is the parameter <code>t</code> along the curve and the second is the number of desired derivatives. Note that the result is a collection of vectors so some conversions are required.</p> <pre><code>\"\"\" Computing Derivatives\n\"\"\"\nD = curve.DerivativeAt( t, 2 )\np, U, V = Point3d( D[0] ), D[1], D[2]\n\n\"\"\" Tangent Vector\n\"\"\"\nT = Vector3d( U )\nT.Unitize( )\n\n\"\"\" Normal Vector\n\"\"\"\nUxV = Vector3d.CrossProduct( U, V )\nN = Vector3d.CrossProduct( UxV, U )\nN.Unitize( )\n\n\"\"\" Curvature\n\"\"\"\n\u03ba = UxV.Length / ( U.Length ** 3 )\n</code></pre>"},{"location":"geometry/curves/#binormal","title":"Binormal","text":"<p>The binormal vector <code>B</code> of a curve at parameter <code>t</code> is associated with the third derivative of the curve <code>C'''( t ) = W</code> but usually computed as <code>B = U x V / |U x V|</code>. It is orthogonal to both the tangent and the normal vectors <code>B = T \u00d7 N</code>. The third derivative geometrically captures the rate by which the curve is twisting along its length. This quantity also known as torsion <code>\u03c4</code> can be computed using <code>\u03c4 = ( U \u00d7 V ) \u00b7 W / ( U \u00d7 V ) ** 2</code>.</p> <pre><code>\"\"\" Computing Derivatives\n\"\"\"\nD = curve.DerivativeAt( t, 3 )\np, U, V, W = Point3d( D[0] ), D[1], D[2], D[3]\n\n\"\"\" Binormal\n\"\"\"\nUxV = Vector3d.CrossProduct( U, V )\nB = UxV / UxV.Length\n\n\"\"\" Torsion\n\"\"\"\n\u03c4 = ( UxV * W ) / ( UxV * UxV )\n\n\"\"\" Shortcut\n\"\"\"\n\u03c4 = curve.TorsionAt( t )\n</code></pre>"},{"location":"geometry/curves/#frame","title":"Frame","text":"<p>The three derivatives along a curve form a coordinate system known as the Frenet-Serret frame. More commonly, the Frenet-Serret frame's origin is associated with the point, the X-axis with the tangent <code>T</code>, the Y-axis with the normal <code>N</code>, and the Z-axis with the binormal <code>B</code>, at parameter <code>t</code>. Because of this association, it is also often known as the <code>TNB</code> frame.</p> <p>Rhino provides the <code>FrameAt( )</code> method for computing coordinate systems along curves.</p> <pre><code>\"\"\" Curve Frame\n\"\"\"\nplane = curve.FrameAt( t )\n\n\"\"\" Associated Vectors\n\"\"\"\np = plane.Origin\nT = plane.XAxis\nN = plane.YAxis\nB = plane.ZAxis\n</code></pre>"},{"location":"geometry/curves/#projection","title":"Projection","text":"<p>Projection, also known as finding the closest point from any point <code>p</code> onto a curve <code>C</code> requires finding a point <code>q</code> such that the direction <code>u = q - p</code> is orthogonal to the curve at <code>q</code>. This is also equivalent of finding the parameter <code>t</code> such that the line defined by the point <code>C( t ) = q</code> and the normal <code>N( t ) = u</code> passes through point <code>p</code>. This is because the normal direction is orthogonal to the curve by definition. Projection of points on simple curves, such as lines and circles, can be computed analytically. For more complex curves it requires numerical computation.</p> <p>In Rhino, curves implement the <code>ClosestPoint( )</code> method, which accepts the point to project and return the parameter of the curve.</p> <pre><code>\"\"\" Curve Closest Point\n\"\"\"\np = Point3d( px, py, pz )\n\nt = curve.ClosestPoint( p )\n\nq = curve.PointAt( t )\n</code></pre>"},{"location":"geometry/curves/computational/","title":"Computational Curves","text":"<p>The types of curves presented in this section are enabled by the ability to perform computations efficiently. Otherwise such geometries are impractical and inaccessible with conventional media. The presentation follows the historical evolution of polygonal and smooth curves including Bezier, BSpline and Nurbs curves.</p>"},{"location":"geometry/curves/computational/#polylines","title":"Polylines","text":""},{"location":"geometry/curves/computational/#definition","title":"Definition","text":"<p>Polylines are piece-wise continuous line segment curves represented by lists of points. Polylines where the first and last points coincide are considered closed or otherwise open. The length of a polyline is the sum of its linear segments.</p> <pre><code>\"\"\" Polyline Class\n\"\"\"\nclass Poly:\n    \"\"\" Construction\n    \"\"\"\n    def __init__( self, points ):\n        self.Points = points\n\n    \"\"\" Source/Start Point\n    \"\"\"\n    @property\n    def Source( self ):\n        return self.Points[0]\n\n    \"\"\" Target/End Point\n    \"\"\"\n    @property\n    def Target( self ):\n        return self.Points[-1]\n\n    \"\"\" Is Polyline Closed?\n    \"\"\"\n    @property\n    def IsClosed( self ):\n        return self.Source.DistanceTo(\n               self.Target ) &lt;= 1e-5\n\n    \"\"\" Line Segments Enumerator\n    \"\"\"\n    @property\n    def Segments( self ):\n        for source, target in zip(\n                self.Points[:-1], self.Points[1:] )\n            yield ( source, target )\n\n    \"\"\" Length of Polyline\n    \"\"\"\n    @property\n    def Length( self ):\n        return sum( [source.DistanceTo( target )\n            for source, target in self.Segments] )\n</code></pre>"},{"location":"geometry/curves/computational/#smoothing","title":"Smoothing","text":"<p>Polylines are often used for representing time-series, where a value or position is tracked over time. Signals collected from sensors often contain numerous points as well as errors. A simple process for decimating the points and simultaneously deriving a smooth trend curve involves averaging consecutive points.</p> <p>In each iteration, every line segment is collapsed to its mid-point, and thus the polyline is reduced by one point. Averaging is repeated recursively producing a smooth approximations of the initial curve. The start and end points of the polyline may be retained, or pinned, because otherwise the curve will geometrically shrink, theoretically down to a single point.</p> <pre><code>class Poly:\n    \"\"\" Average Consecutive Points\n    \"\"\"\n    def Average( self, points, pinned ):\n        result = []\n        if( pinned ):\n            result.append( self.Source )\n\n        for a, b in self.Segments:\n            result.append( ( a + b ) / 2 )\n\n        if( pinned ):\n            result.append( self.Target )\n        return result\n\n    \"\"\" Polyline Smoothing\n    \"\"\"\n    def Smooth( self, iterations = 32, pinned = True ):\n        points = self.Points\n        for _ in range( iterations ):\n            points = self.Average( points, pinned )\n        return Poly( points )\n\n    def ToPolyline( self ):\n        return Polyline( self.Points )\n\n\"\"\" Smoothing Noisy Signal\n\"\"\"\nimport math, random\n\npoints = []\ncount = 50\nfor index in range( count ):\n    x = 2 * math.pi * index / ( count - 1 )\n    y = math.sin( x ) + random.uniform( -0.1, 0.1 )\n    points.append( Point3d( x, y, 0 ) )\n\nnoisy = Poly( points )\nsmooth = noisy.Smooth( )\n</code></pre>"},{"location":"geometry/curves/computational/#application","title":"Application","text":"<p>Rhino uses two classes for polylines, namely <code>Polyline</code> and <code>PolylineCurve</code>, with the former being a light-weight list-like representation, while the later implementing the <code>Curve</code> interface supporting many more complex methods. The <code>Polyline</code> class is used for manipulating point lists directly, while the <code>PolylineCurve</code> is used for passing curve-like parameters to geometric methods such as computing curve intersections, lofting surfaces etc.</p> <pre><code>\"\"\" Polyline Object\n\"\"\"\npoly = Polyline( [Point3d( x, x * x, 0.0 )\n    for x in range( 10 )] )\n\n\"\"\" Point Indexing\n\"\"\"\nsource = poly.First\ntarget = poly.Last\n\nsource = poly[0]\ntarget = poly[poly.Count - 1] #-- Cannot use -1\n\n\"\"\" Polyline Length\n\"\"\"\nlength = poly.Length\n\n\"\"\" Polyline Curve Object\n\"\"\"\npoly = PolylineCurve( [Point3d( x, x * x, 0.0 )\n    for x in range( 10 )] )\n\n\"\"\" Point Indexing\n\"\"\"\nsource = poly.PointAtStart\ntarget = poly.PointAtEnd\n\nsource = poly.Point( 0 )\ntarget = poly.Point( poly.PointCount - 1 )\n\n\"\"\" Polyline Length\n\"\"\"\nlength = poly.GetLength( )\n</code></pre>"},{"location":"geometry/curves/computational/#subdivisions","title":"Subdivisions","text":""},{"location":"geometry/curves/computational/#definition_1","title":"Definition","text":"<p>Subdivision curves are defined by an initial control polygon which is recursively augmented by introducing new interim points and then adjusting their positions in a weighted average sense. The process typically converges to a limiting smooth curve after only a few iterations. There are two types of subdivision curves, namely approximating and interpolating, with the later retaining the positions of the initial control polygon, unlike the former one, see additional information.</p>"},{"location":"geometry/curves/computational/#approximation","title":"Approximation","text":"<p>Approximation schemes iterate over pairs of consecutive line segments, <code>a-&gt;b</code> and <code>b-&gt;c</code>, and inject two new mid-points laterally <code>A = ( a + b ) / 2</code> and <code>C = ( b + c ) / 2</code>. The common point <code>b</code> between the segments is relocated at a position computed from the weighted average of its initial position and the mid-points <code>B = A * wa + b * wb + C * wc</code>, where <code>wa</code>, <code>wb</code> and <code>wb</code> are the weights. The list <code>K = [wa, wb, wc]</code> is known as the subdivision's kernel. Moreover, the sum of weights is unity <code>wa + wb + wc = 1</code>.</p> <p>The number of points <code>n</code> after each iteration is almost double <code>2 * n - 1</code>, therefore the curve rapidly reaches its smooth limiting shape. Open and closed control polygons require attention such that the new points wrap around properly.</p> <pre><code>\"\"\" Subdivision Curve\n\"\"\"\nclass SubDivisionCurve( Poly ):\n    def __init__( self, points, weight = 2 ):\n        Poly.__init__( self, points )\n        scale = 1.0 / ( weight + 2 )\n        self.Kernel = [scale,\n                       scale * weight,\n                       scale]\n\n    \"\"\" Evaluate Kernel\n    \"\"\"\n    def Evaluate( self, a, b, c ):\n        A = ( a + b ) / 2\n        C = ( b + c ) / 2\n\n        wa, wb, wc = self.Kernel\n        B = ( A * wa + b * wb + C * wc )\n\n        return A, B, C\n\n    \"\"\" Subdivision Iteration\n    \"\"\"\n    def Subdivide( self, points, closed ):\n        result = []\n        if( closed ):\n            A, B, C = self.Evaluate(\n                points[-2], #-- skip -1\n                points[ 0],\n                points[ 1] )\n            result.append( A )\n            result.append( B )\n        else:\n            result.append( points[0] )\n\n        for a, b, c in zip(\n                points[ :-2],\n                points[1:-1],\n                points[2:  ] ):\n            A, B, C = self.Evaluate( a, b, c )\n            result.append( A )\n            result.append( B )\n        result.append( C )\n\n        if( not closed ):\n            result.append( points[-1] )\n        return result\n\n    \"\"\" Curve Approximation\n    \"\"\"\n    def Approximate( self, iterations = 8 ):\n        points = self.Points\n        closed = self.IsClosed\n        for _ in range( iterations ):\n            points = self.Subdivide( points, closed )\n        return Poly( points )\n\n\"\"\" Open Curve\n\"\"\"\ncurve = SubDivisionCurve( [\n    Point3d( 0, 0, 0 ),\n    Point3d( 1, 1, 0 ),\n    Point3d( 2, 0, 0 ),\n    Point3d( 3,-1, 0 ),\n    Point3d( 4, 0, 0 )] ).Approximate( )\n\n\"\"\" Closed Curve\n\"\"\"\ncurve = SubDivisionCurve( [\n    Point3d( 0, 3, 0 ),\n    Point3d( 1, 4, 0 ),\n    Point3d( 2, 3, 0 ),\n    Point3d( 1, 2, 0 ),\n    Point3d( 0, 3, 0 )] ).Approximate( )\n</code></pre>"},{"location":"geometry/curves/computational/#bezier-curves","title":"B\u00e9zier Curves","text":"<p>B\u00e9zier curves <code>B( t )</code> are parametric curves using <code>t: [0, 1]</code> with a polynomial representation defined by a sequence of control points P<sub>i</sub> = [P<sub>0</sub>, P<sub>1</sub>, ..., P<sub>n-1</sub>]. The number of control points <code>n</code> is associated with the degree <code>d</code> of the polynomial by <code>n = d + 1</code>. Geometrically they generalize the idea of smoothly blending between points. For example below are the first few polynomials.</p> <ol> <li>B( t ) = ( 1 - t )P<sub>0</sub> + tP<sub>1</sub></li> <li>B( t ) = ( 1 - t )<sup>2</sup>P<sub>0</sub> + 2( 1 - t )tP<sub>1</sub> + t<sup>2</sup>P<sub>2</sub></li> <li>B( t ) = ( 1 - t )<sup>3</sup>P<sub>0</sub> + 3( 1 - t )<sup>2</sup>tP<sub>1</sub> + 3( 1 - t )t<sup>2</sup>P<sub>2</sub> + t<sup>3</sup>P<sub>3</sub></li> <li>B( t ) = ( 1 - t )<sup>4</sup>P<sub>0</sub> + 4( 1 - t )<sup>3</sup>tP<sub>1</sub> + 6( 1 - t )<sup>2</sup>t<sup>2</sup>P<sub>2</sub> + 4( 1 - t )t<sup>3</sup>P<sub>3</sub> + t<sup>4</sup>P<sub>4</sub></li> </ol> <p>The first degree polynomial is just the linear interpolation used in the definition a line segment. Higher degrees are extension of this principle. B\u00e9zier curves, especially quadratics and cubics, are pervasive across design software because they are smooth, require limited memory and they are fast to compute.</p>"},{"location":"geometry/curves/computational/#definition_2","title":"Definition","text":"<p>The expression often used as definition for B\u00e9zier curves, namely B( t ) = \u03a3[0, d] b<sub>d,i</sub>( t ) P<sub>i</sub>, where b<sub>d,i</sub>( t ) = comb( d, i ) t<sup>i</sup> ( 1 - t )<sup>d-i</sup>, is also known as the Bernstein basis function. Comb( n, k ) is a function that returns the binomial coefficient n! / ( k! ( n - k )! ).</p> <pre><code>\"\"\" Binomial Coefficient for python &lt; 3.8\n    or just math.comb( ) for python &gt; 3.8\n\"\"\"\ndef math_comb( n, k ):\n    return math.factorial( n ) // (\n           math.factorial( k ) * math.factorial( n - k ) )\n\n\"\"\" Evaluate Bezier at Parameter\n\"\"\"\nclass BezierCurve:\n    def __init__( self, points ):\n        self.Points = points\n\n    @property\n    def Degree( self ):\n        return len( self.Points ) - 1\n\n    def Evaluate( self, t ):\n        point = Point3d.Origin\n        for index, control in enumerate( self.Points ):\n            alpha = t ** index\n            omega = ( 1 - t ) ** ( self.Degree - index )\n            combo = math_comb( self.Degree, index )\n            basis = combo * alpha * omega\n            point += control * basis\n        return point\n</code></pre> <p>The expression is derived is by expanding <code>( ( 1 - t ) + t ) ** d</code>, hence the binomial coefficients and combinations of <code>( 1 - t )</code> and <code>t</code> raised in respective powers. When those terms are combined with the control points, they produce continuous curves. This also explains why the degree + 1 equals the number of control points required.</p>"},{"location":"geometry/curves/computational/#evaluation","title":"Evaluation","text":"<p>An alternative approach for evaluating B\u00e9zier curves deploys recursive linear interpolation: For every pair of consecutive control points <code>P[i]</code> and <code>P[i+1]</code> we compute a new point <code>Q</code> as the linear combination <code>P[i] * ( 1 - t ) + P[i+1] * t</code>. Processing all <code>n</code> points results into a new list of <code>n-1</code> points. Thereafter, the process is repeated until we are left with a single point.</p> <pre><code>class BezierCurve:\n    @staticmethod\n    def DeCasteljau( points, t ):\n        if( len( points ) == 1 ):\n            return points[0]\n        new_points = []\n        for source, target in zip( points[:-1], points[1:] ):\n            new_points.append( source * ( 1 - t ) + target * t )\n        return BezierCurve.DeCasteljau( new_points, t )\n\n    def Evaluate( self, t ):\n        return BezierCurve.DeCasteljau( self.Points, t )\n</code></pre>"},{"location":"geometry/curves/computational/#derivatives","title":"Derivatives","text":"<p>The derivatives of Bezier curves follow exactly the same rules used for deriving polynomials, namely for f( x ) = x<sup>d</sup> its derivative is f'( x ) = d * x<sup>d-1</sup>. Therefore, to compute the derivative of a Bezier curve, the differences of consecutive control points are scaled by the number of points, effectively dropping a degree, see derivation details.</p> <pre><code>class BezierCurve:\n    \"\"\" Derivative / Hodograph Curve\n    \"\"\"\n    def Derive( self ):\n        d = self.Degree\n        points = [( target - source ) * d\n            for source, target in zip(\n                self.Points[:-1], self.Points[1:] )]\n        return BezierCurve( points )\n\n\"\"\" Bezier Derivative\n\"\"\"\ncontrols = [\n    Point3d( 0.0, 0.0, 0.0 ),\n    Point3d( 1.0, 1.0, 0.0 ),\n    Point3d( 2.0, 0.0, 0.0 ),\n    Point3d( 3.0,-1.0, 0.0 ),\n    Point3d( 4.0, 0.0, 0.0 )]\n\nbezier = BezierCurve( controls )\ntangent = bezier.Derive( )\n\npoint = bezier.Evaluate( t )\nvector = Vector3d( tangent.Evaluate( t ) )\nvector.Unitize( )\n</code></pre> <p>Higher order derivatives can be computed using the same principle. The <code>Derivatives( )</code> method computes a number of requested derivatives which can be used for producing the tangent, normal, frame, curvature and torsion as seen below.</p> <pre><code>class BezierCurve:\n    \"\"\" Derivatives at Parameter\n    \"\"\"\n    def Derivatives( self, t, n = -1 ):\n        d = self.Degree\n        if( n &lt; 0 or\n            n &gt; d ):\n            n = d\n        curve = self\n        delta = [curve.Evaluate( t )] * ( n + 1 )\n        for k in range( 1, n + 1 ):\n            curve = curve.Derive( )\n            delta[k] = curve.Evaluate( t )\n        return delta\n\n    \"\"\" Tangent Vector\n    \"\"\"\n    def Tangent( self, t ):\n        _, u = self.Derivatives( t, 1 )\n        u.Unitize( )\n        return u\n\n    \"\"\" Normal Vector\n    \"\"\"\n    def Normal( self, t ):\n        _, u, v = self.Derivatives( t, 2 )\n        n = Vector3d.CrossProduct( u, v )\n        n.Unitize( )\n        return n\n\n    \"\"\" Fresnet Frame\n    \"\"\"\n    def Frame( self, t ):\n        o, u, v = self.Derivatives( t, 2 )\n        return Plane( o, u, v )\n\n    \"\"\" Curvature\n    \"\"\"\n    def Curvature( self, t ):\n        _, u, v = self.Derivatives( t, 2 )\n        return Vector3d.CrossProduct( u, v ).Length / u.Length ** 3\n\n    \"\"\" Torsion\n    \"\"\"\n    def Torsion( self, t ):\n        o, u, v, w = self.Derivatives( t, 3 )\n        x = Vector3d.CrossProduct( u, v )\n        return ( x * w ) / ( x * x )\n</code></pre>"},{"location":"geometry/curves/computational/#application_1","title":"Application","text":"<p>Rhino implements Bezier curves via the <code>BezierCurve</code> class, see documentation. However, Bezier curves can be represented using Nurbs curves, where their degree equals their number of points plus one, as seen below.</p> <pre><code>\"\"\" Using Rhino's Bezier Curve\n\"\"\"\nfrom Rhino.Geometry import BezierCurve\n\ncurve = BezierCurve( controls )\npoint = curve.PointAt( t )\ntangent = curve.TangentAt( t )\n\n\"\"\" Using Rhino's Nurbs Curve\n\"\"\"\nfrom Rhino.Geometry import NurbsCurve\n\nperiodic, degree = False, len( controls ) - 1\ncurve = NurbsCurve.Create( periodic, degree, controls )\npoint = curve.PointAt( t )\ntangent = curve.TangentAt( t )\n</code></pre>"},{"location":"geometry/curves/computational/#bspline-curves","title":"BSpline Curves","text":""},{"location":"geometry/curves/computational/#definition_3","title":"Definition","text":"<p>Basis splines solve the limitation of Bezier curves, where a curve's degree is bound to the number of its control points. BSplines achieve this by stitching lower degree polynomials in piece-wise continuous manner, see additional information. Stitching is encoded using a list with the domain parameters where the pieces of polynomial of the same degree meet one another, known as the knot vector.</p> <pre><code>class BasisSplineCurve:\n    \"\"\" Construction\n    \"\"\"\n    def __init__( self, points, degree ):\n        self.Points = points\n        self.Degree = degree\n        self.Knots  = self.ClampedKnots( )\n\n    \"\"\" Open Knot Vector\n    \"\"\"\n    def OpenKnots( self ):\n        n, d = len( self.Points ), self.Degree\n        return [i / ( n + d )\n            for i in range( n + d + 1 )]\n\n    \"\"\" Clamped Knot Vector\n    \"\"\"\n    def ClampedKnots( self ):\n        n, d = len( self.Points ), self.Degree\n        k_min = [0.0] * d\n        k_mid = [i / ( n - d ) for i in range( n - d + 1 )]\n        k_max = [1.0] * d\n        return k_min + k_mid + k_max\n\n    \"\"\" Periodic Knot Vector\n    \"\"\"\n    def PeriodicKnots( self ):\n        n, d = len( self.Points ), self.Degree\n        return [( i - d  ) / ( n - d )\n            for i in range( n + d + 1 )]\n</code></pre>"},{"location":"geometry/curves/computational/#evaluation_1","title":"Evaluation","text":"<p>Evaluating points on BSplines is slightly more involved compared to Bezier curves.  However, the logic is not unlike De Casteljau's repeated interpolation scheme. First, the polynomial curve piece is identified by locating the knot interval <code>[k_min, k_max]</code> containing the parameter <code>t</code>. Finally, adjacent control points are interpolated in a linear fashion using the basis functions associated with the knot values. Only up to degree + 1 points are used unlike Bezier curves which process the entire list of control points. The <code>Evaluate( )</code> method below follows the De Boor's algorithm. A more efficient implementation is presented by Piegl and Tiller in The NURBS Book.</p> <pre><code>class BasisSplineCurve:\n    \"\"\" Find Knot Span Containing Parameter\n    \"\"\"\n    def KnotSpan( self, t ):\n        n, d = len( self.Points ), self.Degree\n        if( t &lt;= self.Knots[d] ): return d, d\n        if( t &gt;= self.Knots[n] ): return d, n - 1\n        for knot, ( k_min, k_max ) in enumerate(\n                zip( self.Knots[:-1], self.Knots[1:] ) ):\n            if( k_min &lt;= t &lt;  k_max or\n                k_min &lt;  t &lt;= k_max ):\n                return d, knot\n\n    \"\"\" De Boor's Algorithm\n    \"\"\"\n    def Evaluate( self, t ):\n        #-- Relevant Knots and Points\n        #--\n        d, k = self.KnotSpan( t )\n        P = self.Points[k-d:k+1]\n\n        #-- Recursive Interpolations\n        #--\n        for i in range( d ):\n            for j in range( d, i, -1 ):\n                to = self.Knots[j + k - d]\n                ti = self.Knots[j + k - i]\n\n                alpha = ( t - to ) / ( ti - to )\n                omega = 1.0 - alpha\n\n                P[j] = omega * P[j - 1] + alpha * P[j]\n        return P[-1]\n</code></pre> <p>The demonstration below constructs a BSpline, prints its knot vector and evaluates a series of points along its domain. Note that the repeated zeros and ones in the knot vector are for keeping the basis functions evaluation within bounds and forcing the curve to pass through the first and last control points.</p> <pre><code>\"\"\" Control Points\n\"\"\"\ncontrols = [\n    Point3d( 0.0, 0.0, 0.0 ),\n    Point3d( 1.0, 1.0, 0.0 ),\n    Point3d( 2.0, 0.0, 0.0 ),\n    Point3d( 3.0,-1.0, 0.0 ),\n    Point3d( 4.0, 0.0, 0.0 )]\n\n\"\"\" Clamped BSpline Curve\n\"\"\"\ncurve = BasisSplineCurve( controls, degree = 3 )\nprint( curve.Knots )\n#  [ 0.0, 0.0, 0.0, 0.0, 0.5, 1.0, 1.0, 1.0, 1.0 ]\n#  | 0.0 * degree | unit range   | 1.0 * degree  |\n#  | clamped      | interpolated | clamped       |\n\n\"\"\" Open BSpline Curve\n\"\"\"\ncurve = BasisSplineCurve( controls, degree = 3 )\ncurve.Knots = curve.OpenKnots( )\nprint( curve.Knots )\n# [0.0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0]\n# |                 interpolated                        |\n\ncount  = 128\npoints = [curve.Evaluate( index / ( count - 1 ) )\n    for index in range( count )]\n</code></pre>"},{"location":"geometry/curves/computational/#periodic-curves","title":"Periodic Curves","text":"<p>Periodic curves are represented by first wrapping the last control points over the first control points, by repeating as many as the degree of the curve, and then using a periodic knot vector.</p> <pre><code>\"\"\" Control Points\n\"\"\"\ncontrols = [\n    Point3d( 0.0, 0.0, 0.0 ), #-- 0\n    Point3d( 1.0, 1.5, 0.0 ), #-- 1\n    Point3d( 2.0, 0.0, 0.0 ), #-- 2\n    Point3d( 0.0, 0.0, 0.0 ), #-- wrap 0\n    Point3d( 1.0, 1.5, 0.0 ), #-- wrap 1\n    Point3d( 2.0, 0.0, 0.0 )] #-- wrap 2\n\n\"\"\" Periodic BSpline Curve\n\"\"\"\ncurve = BasisSplineCurve( controls, degree = 3 )\ncurve.Knots = curve.PeriodicKnots( )\nprint( curve.Knots )\n#  [-1.5, -1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0, 2.5]\n#  | wrap backward  | unit range   | wrap forward |\n#  | periodic       | interpolated | periodic     |\n</code></pre>"},{"location":"geometry/curves/computational/#derivatives_1","title":"Derivatives","text":"<p>The derivative of a BSpline curve is another one-degree-lower BSpline curve. Its control points are computed from the differences of the original control points, scaled by the degree and knot span differences. Finally, its knot vector is a copy of the original knots without the first and last items, see derivation details. Higher order derivatives and differential properties are computed using the same principles as seen in Bezier curves.</p> <pre><code>class BasisSplineCurve:\n    \"\"\" Derivative / Hodograph Curve\n    \"\"\"\n    def Derive( self ):\n        d = self.Degree\n        points = []\n        for i in range( 1, len( self.Points ) ):\n            po, ko = self.Points[i-1], self.Knots[i  ]\n            pi, ki = self.Points[i  ], self.Knots[i+d]\n            point = ( pi - po ) * d / ( ki - ko )\n            points.append( point )\n        curve = BasisSplineCurve( points, d - 1 )\n        curve.Knots = self.Knots[1:-1]\n        return curve\n\n    def Derivatives( self, t, n = -1 ):\n        d = self.Degree\n        if( n &lt; 0 or\n            n &gt; d ):\n            n = d\n        curve = self\n        delta = [curve.Evaluate( t )] * ( n + 1 )\n        for k in range( 1, n + 1 ):\n            curve = curve.Derive( )\n            delta[k] = curve.Evaluate( t )\n        return delta\n\n\"\"\" BSpline Curve Derivative\n\"\"\"\ncontrols = [\n    Point3d( 0.0, 0.0, 0.0 ),\n    Point3d( 1.0, 1.0, 0.0 ),\n    Point3d( 2.0, 0.0, 0.0 ),\n    Point3d( 3.0,-1.0, 0.0 ),\n    Point3d( 4.0, 0.0, 0.0 )]\n\nbspline = BasisSplineCurve( controls, degree = 3 )\npoint = bspline.Evaluate( t )\nplane = bspline.Frame( t )\n</code></pre>"},{"location":"geometry/curves/computational/#application_2","title":"Application","text":"<p>Rhino does not provide a specialized BSpline class but the functionality is supported via Nurbs curves, see next section, which represent a superset or generalization thereof.</p> <pre><code>\"\"\" Using Rhino's Nurbs Curve\n\"\"\"\nfrom Rhino.Geometry import NurbsCurve\n\ncontrols = [\n    Point3d( 0.0, 0.0, 0.0 ),\n    Point3d( 1.0, 1.0, 0.0 ),\n    Point3d( 2.0, 0.0, 0.0 ),\n    Point3d( 3.0,-1.0, 0.0 ),\n    Point3d( 4.0, 0.0, 0.0 )]\n\nperiodic, degree = False, 3\ncurve = NurbsCurve.Create( periodic, degree, controls )\nprint( list( curve.Knots ) )\n# [ 0.0, 0.0, 0.0, 1.0, 2.0, 2.0, 2.0 ]\n# | clamped | interpolated | clamped  |\n</code></pre>"},{"location":"geometry/curves/computational/#nurbs-curves","title":"Nurbs Curves","text":""},{"location":"geometry/curves/computational/#definition_4","title":"Definition","text":"<p>Nurbs or non-uniform rational basis splines extend BSplines by being able to represent rational curves such as circles and other conic sections, see additional information. This is achieved by introducing a 4th coordinate for each control point known as the weight. The notion of using 4D instead of 3D points originates in projective geometry, where an additional coordinate is used to allow representing points at infinity, see Gerald Farin's NURBS for Curve and Surface Design for additional information.</p>"},{"location":"geometry/curves/computational/#evaluation_2","title":"Evaluation","text":"<p>The De Boor's algorithm can be used for evaluating Nurbs curves. First the rational control points, about the knot interval containing the parameter, are decoupled and pre-scaled by their weights. Then the computed non-rational points and weights are used to define two BSpline curves within the reduced knot vector. Finally, both curves are evaluated and their quotient is returned.</p> <p>Note that BSpline curves express a general polynomial scheme for smoothly interpolating values, which may be points or just simple numbers as in the case of the weight's curve.</p> <pre><code>\"\"\" Nurbs Curve\n\"\"\"\nclass RationalBSplineCurve( BasisSplineCurve ):\n    \"\"\" Construction\n    \"\"\"\n    def __init__( self, points, degree ):\n        BasisSplineCurve.__init__( self, points, degree )\n\n    \"\"\" Decouple Points and Weights\n    \"\"\"\n    def Decouple( self, points ):\n        P = [Point3d( p.X * p.W,\n                      p.Y * p.W,\n                      p.Z * p.W )\n                 for p in points]\n        W = [p.W for p in points]\n        return P, W\n\n    \"\"\" Evaluate Point\n    \"\"\"\n    def Evaluate( self, t ):\n        d, k = self.KnotSpan( t )\n        P, W = self.Decouple( self.Points[k-d:k+1] )\n        K = self.Knots[k-d:k+d+1]\n\n        A = BasisSplineCurve( P, d ); A.Knots = K\n        w = BasisSplineCurve( W, d ); w.Knots = K\n\n        return A.Evaluate( t ) / w.Evaluate( t )\n\n\"\"\" Rational Cubic Curve\n\"\"\"\ncontrols = [\n    Point4d( 0.0, 0.0, 0.0, 1.0 ),\n    Point4d( 1.0, 1.0, 0.0, 5.0 ), #-- Rational\n    Point4d( 2.0, 0.0, 0.0, 1.0 ),\n    Point4d( 3.0,-1.0, 0.0, 5.0 ), #-- Rational\n    Point4d( 4.0, 0.0, 0.0, 1.0 )]\n\ncurve = RationalBSplineCurve( controls, 3 )\n\n\"\"\" Rational Circle\n\"\"\"\nr = 1.0                            #-- Radius\no = 0.5 * math.sqrt( 2.0 )         #-- Weight\ncontrols = [Point4d( r, 0, 0, 1 ),\n            Point4d( r, r, 0, o ),\n            Point4d( 0, r, 0, 1 ),\n            Point4d(-r, r, 0, o ),\n\n            Point4d(-r, 0, 0, 1 ),\n            Point4d(-r,-r, 0, o ),\n            Point4d( 0,-r, 0, 1 ),\n            Point4d( r,-r, 0, o )]\ncontrols.append( controls[0] )\n\ncircle = RationalBSplineCurve( controls, 2 )\ncircle.Knots = [0.00, 0.00, 0.00,\n                0.25, 0.25, 0.50,\n                0.50, 0.75, 0.75,\n                1.00, 1.00, 1.00]\n</code></pre>"},{"location":"geometry/curves/computational/#derivatives_2","title":"Derivatives","text":"<p>The derivatives of Nurbs curves are significantly more complicated when compared to BSplines, see quotient rule. Additionally, there is no hodograph Nurbs curve representation. Therefore, they are computed per parameter. Conceptually, a Nurbs curve is converted into two BSpline curves, one for the pre-weighted control points and one for the weights themselves. Their derivatives are computed and their combinations are used to reconstruct the Nurbs curve's derivatives, see The NURBS Book for additional information.</p> <pre><code>class RationalBSplineCurve( BasisSplineCurve ):\n    \"\"\" Nurbs Derivatives\n    \"\"\"\n    def Derivatives( self, t, n = -1 ):\n        d = self.Degree\n        if( n &lt; 0 or\n            n &gt; d ):\n            n = d\n\n        \"\"\" Non-Rational Derivatives\n        \"\"\"\n        P, W = self.Decouple( self.Points )\n        A = BasisSplineCurve( P, d ); A.Knots = self.Knots\n        w = BasisSplineCurve( W, d ); w.Knots = self.Knots\n\n        dA = A.Derivatives( t, n )\n        dw = w.Derivatives( t, n )\n\n        \"\"\" Rational Derivatives\n        \"\"\"\n        D = [1.0] * ( n + 1 )\n        for k in range( n + 1 ):\n            u = Vector3d( dA[k] )\n            for i in range( 1, k + 1 ):\n                u -= math_comb( k, i ) * dw[i] * D[k - i]\n            D[k] = u / dw[0]\n        return D\n</code></pre>"},{"location":"geometry/curves/computational/#application_3","title":"Application","text":"<p>Rhino provides an extensive range of methods for constructing and manipulating Nurbs curves, see documentation. Note that construction of Nurbs curves is performed using the static methods starting with <code>NurbsCurve.Create*</code> instead of the class constructor.</p> <pre><code>\"\"\" Nurbs Curve Construction\n\"\"\"\ncontrols = [\n    Point3d( 0.0, 0.0, 0.0 ),\n    Point3d( 1.0, 1.0, 0.0 ),\n    Point3d( 2.0, 0.0, 0.0 ),\n    Point3d( 3.0,-1.0, 0.0 ),\n    Point3d( 4.0, 0.0, 0.0 )]\n\n\"\"\" Open Cubic BSpline\n\"\"\"\nperiodic, degree = False, 3\ncurve = NurbsCurve.Create( periodic, degree, controls )\nprint( list( curve.Knots ) )\n#-- [0.0, 0.0, 0.0, 1.0, 2.0, 2.0, 2.0]\n\n\"\"\" Manual Nurbs Curve Construction\n\"\"\"\ncontrols = [\n    Point4d( 1.5, 0.0, 0.0, 1.0 ),\n    Point4d( 2.5, 1.0, 0.0, 5.0 ), #-- Rational\n    Point4d( 3.5, 0.0, 0.0, 1.0 ),\n    Point4d( 4.5,-1.0, 0.0, 5.0 ), #-- Rational\n    Point4d( 5.5, 0.0, 0.0, 1.0 )]\n\ndimensions, degree, rational = 3, 3, True\ncurve = NurbsCurve( dimensions,\n    rational, degree, len( controls ) )\n\nfor index in range( len( controls ) ):\n    curve.Points.SetPoint( index,\n        Point3d( controls[index].X,\n                 controls[index].Y,\n                 controls[index].Z ),\n                 controls[index].W )\n\ncurve.Knots.CreateUniformKnots( 1.0 )\n\n\"\"\" Open Fitted/Interpolated Cubic BSpline\n\"\"\"\npoints = [\n    Point3d( 0.0, 0.0, 0.0 ),\n    Point3d( 1.0, 1.0, 0.0 ),\n    Point3d( 2.0, 0.0, 0.0 ),\n    Point3d( 3.0,-1.0, 0.0 ),\n    Point3d( 4.0, 0.0, 0.0 )]\n\ncurve = NurbsCurve.CreateInterpolatedCurve( points, 3 )\n\n\"\"\" Periodic Rational BSpline\n\"\"\"\ncurve = NurbsCurve.CreateFromCircle(\n    Circle( Plane.WorldXY, 1.0 ) )\n</code></pre> <p>Some commonly used methods are presented below including projecting points onto curves, splitting and joining curves, performing Boolean operations and offsetting curves.</p> <pre><code>\"\"\" Point Projection on Curve\n    returns projected point and parameter\n\"\"\"\np, t = curve.ClosestPoint( Point3d.Origin )\n\n\"\"\" Split curve in parts at parameter(s)\n\"\"\"\nparts = curve.Split( 0.5 )\nparts = curve.Split( [0.25, 0.5, 0.75] )\n\n\"\"\" Join curves with tolerance\n\"\"\"\ncurves = NurbsCurve.JoinCurves( parts, 1e-3 )\n\n\"\"\" Boolean operations on closed curves\n\"\"\"\ncurves = NurbsCurve.CreateBooleanUnion( parts, 1e-3 )\n\n\"\"\" Offset curves with rounded corners\n\"\"\"\ncurves = curve.Offset( Plane.WorldXY, 0.1, 1e-5,\n    CurveOffsetCornerStyle.Round )\n</code></pre>"},{"location":"geometry/curves/computational/#resources","title":"Resources","text":"<p>Grasshopper </p>"},{"location":"geometry/curves/euclidean/","title":"Euclidean Curves","text":"<p>Euclidean curves, also known as conic sections, have been studied for centuries. They represent the most basic and commonly used curves in geometry. Traditionally they are considered in the plane but by transformation can be situated anywhere in space.</p>"},{"location":"geometry/curves/euclidean/#line","title":"Line","text":"<p>Lines and finite segments thereof are the most common curves used in geometry. A line can be defined parametrically either by two points <code>p</code> and <code>q</code> as <code>L( t ) = p * ( 1 - t ) + q * t</code>, or by an origin point <code>o</code> and a direction <code>u</code> as <code>L( t ) = o + u * t</code>. Even though they are equivalent, the two-point representation is associated with linear interpolation and commonly used for line segments, where <code>t: [0, 1],</code> while the point-vector form is closer semantically to a ray or half-line, where <code>t: [0, +oo)</code>, or commonly used for infinite lines, where <code>t: (-oo, +oo)</code>.</p> <pre><code>class Line:\n    def __init__( self, source, target ):\n        self.Source = source\n        self.Target = target\n\n    def Evaluate( self, t ):\n        return ( self.Source * ( 1 - t ) +\n                 self.Target * t )\n\n    def Tangent( self, t ):\n        T = self.Target - self.Source\n        T.Unitize( )\n        return T\n\n    def Normal( self, t ):\n        return Plane( self.Source,\n            self.Target - self.Source ).XAxis\n</code></pre> <p>A <code>Line</code> class can be defined as seen in the code. Note that the tangent vector is constant and independent from the parameter <code>t</code>. Additionally, the normal vector is ill-defined so a basis vector from a normal plane is used instead.</p> <p>Rhino provides the <code>Line</code> data types which can be defined using either a point and vector or two points, see documentation. Internally, the line is defined by its end-points named as <code>From</code> and <code>To</code>. The origin is the point <code>From</code> and the direction as <code>To - From</code> or access using the <code>Direction</code> property.</p> <pre><code>\"\"\" Line from Two Points\n\"\"\"\np = Point3d( px, py, pz )\nq = Point3d( qx, qy, qz )\n\nln = Line( p, q )\n\n\"\"\" Line from Origin and Direction\n\"\"\"\no =  Point3d( ox, oy, oz )\nu = Vector3d( ux, uy, uz )\n\nln = Line( o, u )\n\n\"\"\" Start and End Points\n\"\"\"\nsource = ln.From\ntarget = ln.To\n\n\"\"\" Line's Direction\n\"\"\"\ndirection = target - source\ndirection = ln.Direction\n</code></pre>"},{"location":"geometry/curves/euclidean/#circle","title":"Circle","text":"<p>Circle is the second most commonly used curve and can be defined in the plane by a center point <code>c</code> and a radius <code>r</code>. Additionally, in 3D space, a coordinate system or plane basis is required such as <code>P = { o, u, v }</code>, where <code>o</code> is the origin and <code>u</code> and <code>v</code> are its orthonormal basis vectors. By convention, spatial circle's centers coincide with the planes' origins <code>c = o</code>. Therefore, a general 3D circle is defined as <code>C = { o, u, v, r }</code>. The parametric equation of the circle based on those is <code>C( t ) = o + u * cos( t ) * r + v * sin( t ) * r</code>. It is also possible to absorb the radius into the basis vectors such that <code>|u| = |v| = r</code> and express the circle using just its basis <code>{ o, u, v }</code> as <code>C( t ) = o + u * cos( t ) + v * sin( t )</code>. The parameterization of a circle is typically in the angle sense, where <code>t: [0, 2\u03c0)</code>.</p> <pre><code>class Circle:\n    def __init__( self, basis, radius = 1.0 ):\n        self.Basis  = basis\n        self.Radius = radius\n\n    def Evaluate( self, angle ):\n        x = self.Radius * math.cos( angle )\n        y = self.Radius * math.sin( angle )\n\n        return ( self.Basis.Origin +\n                 self.Basis.XAxis * x +\n                 self.Basis.YAxis * y )\n\n    def Tangent( self, angle ):\n        x = -math.sin( angle )\n        y =  math.cos( angle )\n\n        return ( self.Basis.XAxis * x +\n                 self.Basis.YAxis * y )\n\n    def Normal( self, angle ):\n        x = -math.cos( angle )\n        y = -math.sin( angle )\n\n        return ( self.Basis.XAxis * x +\n                 self.Basis.YAxis * y )\n</code></pre> <p>Rhino provides the <code>Circle</code> class, see documention, which allows constructing circles by a center point and a radius in 2D, or a plane and a radius in 3D. Note that in both cases the circle is internally stored using the plane-radius form. The center-radius definition is converted into a translated XY-plane at the circle's center. The circle's center and radius can be accessed using the <code>Center</code> and <code>Radius</code> properties, while its basis using the <code>Plane</code> property.</p> <pre><code>\"\"\" Planar Circle\n\"\"\"\ncenter = Point3d( cx, cy, cz )\nradius = float( positive )\n\ncircle = Circle( center, radius )\n\n\"\"\" Spatial Circle\n\"\"\"\ncircle = Circle( Plane.WorldYZ, radius )\n\n\"\"\" Circle's Properties\n\"\"\"\ncenter = circle.Center\nradius = circle.Radius\nplane  = circle.Plane\n</code></pre>"},{"location":"geometry/curves/euclidean/#ellipse","title":"Ellipse","text":"<p>In one sense, an ellipse is a generalization of a circle using two scaling factors <code>a</code> and <code>b</code> instead of a single one, namely its radius <code>r</code>. Points on an ellipse are expressed in space using the form <code>E( t ) = o + u * cos( t ) * a + v * sin( t ) * b</code>. The scalars <code>a</code> and <code>b</code> are also known as the semi-major and semi-minor axes coefficients. Again it is possible to absorb them into the basis vectors such that <code>|u| = a</code> and <code>|v| = b</code> and therefore use exactly the same equation as the circle <code>E( t ) = o + u * cos( t ) + v * sin( t )</code>. The parameterization is also in angle sense, where <code>t: [0, 2\u03c0)</code>.</p> <pre><code>class Ellipse:\n    def __init__( self, basis, major = 1.0, minor = 1.0 ):\n        self.Basis  = basis\n        self.Radius = Vector2d( major, minor )\n\n    def Evaluate( self, angle ):\n        x = self.Radius.X * math.cos( angle )\n        y = self.Radius.Y * math.sin( angle )\n\n        return ( self.Basis.Origin +\n                 self.Basis.XAxis * x +\n                 self.Basis.YAxis * y )\n\n    def Tangent( self, angle ):\n        x = -self.Radius.X * math.sin( angle )\n        y =  self.Radius.Y * math.cos( angle )\n\n        T = ( self.Basis.XAxis * x +\n              self.Basis.YAxis * y )\n        T.Unitize( )\n        return T\n\n    def Normal( self, angle ):\n        return Vector3d.CrossProduct(\n            self.Basis.ZAxis, self.Tangent( angle ) )\n</code></pre> <p>Rhino provides the <code>Ellipse</code> class, see documention, which allows constructing ellipses by a plane and radii or three points. The ellipse's center and radii can be accessed using the <code>Center</code>, <code>Radius1</code>, <code>Radius2</code> properties, and its basis using the <code>Plane</code> property. However, the <code>Ellipse</code> does not implement the <code>Curve</code> interface requiring converting the curve into a Nurbs form using <code>ToNurbsCurve( )</code> method.</p> <pre><code>\"\"\" Ellipse\n\"\"\"\ncenter = Point3d( cx, cy, cz )\na, b = float( positive ), float( positive )\n\nellipse = Ellipse( Plane( center,\n    Vector3d.XAxis, Vector3d.YAxis ), a, b )\n\n\"\"\" Circle's Properties\n\"\"\"\ncenter = ellipse.Center\na, b   = ellipse.Radius1, ellipse.Radius2\nplane  = ellipse.Plane\n</code></pre>"},{"location":"geometry/curves/euclidean/#parabola","title":"Parabola","text":"<p>Parabolas are quadratic polynomial curves defined as y = ax<sup>2</sup>. There are more complex versions including additional linear terms such as y = ax<sup>2</sup> + bx + c. To spatialize a parabola a basis plane is required such that points on the curve can be expressed as seen below.</p> <pre><code>class Parabola:\n    def __init__( self, basis, a = 1, b = 0, c = 0 ):\n        self.Basis = basis\n        self.Coefficients = [a, b, c]\n\n    def Evaluate( self, x ):\n        y = ( self.Coefficients[0] * x * x +\n              self.Coefficients[1] * x +\n              self.Coefficients[2] )\n\n        return ( self.Basis.Origin +\n                 self.Basis.XAxis * x +\n                 self.Basis.YAxis * y )\n\n    def Tangent( self, x ):\n        y = ( self.Coefficients[0] * x * 2 +\n              self.Coefficients[1] )\n\n        T = ( self.Basis.XAxis * 1 +\n              self.Basis.YAxis * y )\n        T.Unitize( )\n        return T\n\n    def Normal( self, angle ):\n        return Vector3d.CrossProduct(\n            self.Basis.ZAxis, self.Tangent( angle ) )\n</code></pre> <p>Parabolas are conic sections where a plane intersects a cone at a bias while cutting through the cone's axis. Another definition for a parabola is the curve whose points are equidistant from a point, also known as focus and a line, also known as a directrix, see additional information.</p> <p>Rhino represents parabolas as second degree Bezier curves with three control points, and provides three methods for constructing them, namely <code>CreateParabolaFromFocus( )</code>, <code>CreateParabolaFromPoints( )</code> and <code>CreateParabolaFromVertex( )</code>, see documentation.</p> <pre><code>\"\"\" Parabola from vertex, start and end points\n\"\"\"\nparabola = NurbsCurve.CreateParabolaFromVertex(\n    Point3d( vx, vy, vz ),\n    Point3d( sx, sy, sz ),\n    Point3d( ex, ey, ez ) )\n</code></pre>"},{"location":"geometry/curves/euclidean/#hyperbola","title":"Hyperbola","text":"<p>Hyperbolas in their simplest form are curves defined as y = a / x. They also represent conic sections where the plane is parallel to the cone's axis. Alternatively, a hyperbola can be defined by the relationship where the difference of distances between two points, also known as focii, is fixed for all points on the curve, see additional information.</p> <pre><code>class Hyperbola:\n    def __init__( self, basis, alpha = 1 ):\n        self.Basis = basis\n        self.Alpha = alpha\n\n    def Evaluate( self, x ):\n        return ( self.Basis.Origin +\n                 self.Basis.XAxis * x +\n                 self.Basis.YAxis * self.Alpha / x )\n\n    def Tangent( self, x ):\n        T = ( self.Basis.XAxis * 1 +\n              self.Basis.YAxis * -self.Alpha / ( x * x ) )\n        T.Unitize( )\n        return T\n\n    def Normal( self, angle ):\n        return Vector3d.CrossProduct(\n            self.Basis.ZAxis, self.Tangent( angle ) )\n</code></pre> <p>Rhino does not provide a method for constructing hyperbolas programmatically even though it is possible to construct them via the user interface. The curves created are second degree rational Bezier curves.</p>"},{"location":"geometry/curves/euclidean/#spiral","title":"Spiral","text":"<p>The term spiral captures a family of planar curves associated with a circular motion where the radius is continuously changing, or in other words the radius is a function of the angle. The definition below captures all spiral curves by requiring a callable radius parameter. The tangent and normal vectors are compute approximately using the finite differences scheme.</p> <pre><code>class Spiral:\n    def __init__( self, basis, radius = None ):\n        self.Basis  = basis\n        if( radius is None )\n            self.Radius = lambda angle: angle\n        else:\n            self.Radius = radius\n\n    def Evaluate( self, angle ):\n        x = self.Radius( angle ) * math.cos( angle )\n        y = self.Radius( angle ) * math.sin( angle )\n        return ( self.Basis.Origin +\n                 self.Basis.XAxis * x +\n                 self.Basis.YAxis * y )\n\n    def Tangent( self, angle ): #-- Approximate\n        T = ( self.Evaluate( angle + 1e-5 ) -\n              self.Evaluate( angle        ) )\n        T.Unitize( )\n        return T\n\n    def Normal( self, angle ): #-- Approximate\n        return Vector3d.CrossProduct(\n            self.Basis.ZAxis, self.Tangent( angle ) )\n</code></pre> <p>Specific spirals include the Archimedean, where <code>radius = lambda angle: angle</code>, hyperbolic, where <code>radius = lambda alpha: 1.0 / alpha</code>, and many others, see additional information</p> <pre><code>\"\"\" Archimedean Spiral\n\"\"\"\nspiral = Spiral( Plane.WorldXY )\n\n\"\"\" Hyperbolic Spiral\n\"\"\"\nspiral = Spiral( Plane.WorldXY,\n    lambda angle: 1.0 / angle )\n</code></pre>"},{"location":"geometry/curves/euclidean/#helix","title":"Helix","text":"<p>Helices are associated with spirals but they three-dimensional curves. They are defined using a basis and a radius function. The helical shape is accomplished by translating along the basis' plane Z-axis, in typically linear fashion, as seen below.</p> <pre><code>class Helix:\n    def __init__( self, basis, radius = None ):\n        self.Basis  = basis\n        if( radius is None ):\n            self.Radius = lambda angle: 1.0\n        elif( isinstance( radius, float ) ):\n            self.Radius = lambda angle: radius\n        else:\n            self.Radius = radius\n\n    def Evaluate( self, t ):\n        x = self.Radius( t ) * math.cos( t * math.pi * 2 )\n        y = self.Radius( t ) * math.sin( t * math.pi * 2 )\n        return ( self.Basis.Origin +\n                 self.Basis.XAxis * x +\n                 self.Basis.YAxis * y +\n                 self.Basis.ZAxis * t )\n\n    def Tangent( self, angle ): #-- Approximate\n        T = ( self.Evaluate( angle + 1e-5 ) -\n              self.Evaluate( angle        ) )\n        T.Unitize( )\n        return T\n\n    def Normal( self, angle ): #-- Approximate\n        return Vector3d.CrossProduct(\n            self.Basis.ZAxis, self.Tangent( angle ) )\n</code></pre> <p>Examples of various helices are presented below. Note that if the radius is omitted, then the helix has unit radius. Alternatively, if the radius parameter is a number, then the radius is constant. In the most general case a lambda can be passed.</p> <pre><code>\"\"\" Unit Radius\n\"\"\"\nhelix = Helix( Plane.WorldXY )\n\n\"\"\" Constant Radius\n\"\"\"\nhelix = Helix( Plane.WorldXY, 2.0 )\n\n\"\"\" Archimedean\n\"\"\"\nhelix = Helix( Plane.WorldXY,\n    lambda t: t * math.pi * 2 )\n</code></pre>"},{"location":"geometry/meshes/","title":"Mesh Geometry","text":"<p>Meshes are collections of simple polygons, typically triangles or quads, used for representing surfaces and solids. They are are motivated by their capability for accelerated processing via GPUs and for overcoming the limitations of mathematical surfaces which require well-behaved functions in the sense of continuity and derivatives.</p>"},{"location":"geometry/meshes/#representations","title":"Representations","text":""},{"location":"geometry/meshes/#triangle-lists","title":"Triangle Lists","text":"<p>The simplest way to define a mesh is via a collection of 3D points, every three thereof describing a triangle. A table <code>( n, 3 )</code> of points <code>M = [[a1, b1, c1], ... [an, bn, cn]]</code> is often used, however, it is also common to use a <code>( n, 3, 3 )</code> tensors in <code>numpy</code> and <code>pytorch</code> or flat lists of  <code>( n * 9 )</code> coordinates when uploading the data to the GPU.</p> <pre><code>class TriangleList:\n    def __init__( self, triangles ):\n        self.Triangles = triangles\n\n    def ToFloats( self ):\n        coordinates = []\n        for triangle in self.Triangles:\n            for point in triangle:\n                coordinates.append( point.X )\n                coordinates.append( point.Y )\n                coordinates.append( point.Z )\n        return coordinates\n\n    def ToNumPy( self ):\n        array = np.zeros( ( len( self.Triangles ), 3, 3 ) )\n        for i, triangle in enumerate( self.Triangles ):\n            for i, point in enumerate( triangle ):\n                array[i, j, 0] = point.X\n                array[i, j, 1] = point.Y\n                array[i, j, 2] = point.Z\n        return array\n\nmesh = TriangleList( [\n    [Point3d( 0.0, 0.0, 0.0 ),\n     Point3d( 1.0, 0.0, 0.0 ),\n     Point3d( 1.0, 1.0, 0.0 )],\n\n    [Point3d( 1.0, 1.0, 0.0 ),\n     Point3d( 0.0, 1.0, 0.0 ),\n     Point3d( 0.0, 0.0, 0.0 )]] )\n</code></pre> <p>This representation is the most unstructured way to describe meshes also known as a soup of triangles. It is used when each point is associated with a unique color <code>[r, g, b, a]</code> or a texture coordinate <code>[u, v]</code>. Otherwise, it is considered wasteful because often triangles share points which are duplicated here. For instance a cube has <code>8</code> vertices and <code>6 * 2 = 12</code> triangles, but with this representation we need <code>12 * 3 = 36</code> vertices! Note that this definition may be trivially extended to include quads or polygons instead of only triangles.</p>"},{"location":"geometry/meshes/#indexed-meshes","title":"Indexed Meshes","text":"<p>The common way to represent meshes is using a list of points <code>P = [P0, P1, ..., Pn-1]</code>, also known as vertices, and a list of  indices <code>F = [F0, F1, ..., Fn-1]</code>, also known as faces. A face <code>F[i]</code> is a just list of integers <code>[a, b, c]</code>, where <code>a</code>, <code>b</code> and <code>c</code> describe which vertices to select from the vertex-list, by index, to form a triangle, namely <code>P[a]</code>, <code>P[b]</code> and <code>P[c]</code>. For example, the face <code>[4, 1, 6]</code> represents a triangle with points <code>P[4]</code>, <code>P[1]</code>, and <code>P[6]</code>. The motivation for this representation is primarily for saving memory. A cube only requires <code>8</code> vertices as opposed to <code>36</code> with the equivalent triangle soup representation.</p> <pre><code>class IndexedMesh:\n    def __init__( self, vertices, faces ):\n        self.Vertices = vertices\n        self.Faces    = indices\n\n    ''' Face Index -&gt; Points\n    '''\n    def TriangleAt( self, face ):\n        ia, ib, ic = self.Faces[face]\n\n        pa = self.Vertices[ia]\n        pb = self.Vertices[ib]\n        pc = self.Vertices[ic]\n\n        return [pa, pb, pc]\n\nmesh = IndexedMesh(\n    [Point3d( 0.0, 0.0, 0.0 ),\n     Point3d( 1.0, 0.0, 0.0 ),\n     Point3d( 1.0, 1.0, 0.0 ),\n     Point3d( 0.0, 1.0, 0.0 )],\n\n    [[0, 1, 2], [2, 3, 0]] )\n</code></pre> <p>Rhino's meshes are based on the latter representation. The collection of points is accessed via the <code>Vertices</code> property and the triangulation indices via the <code>Faces</code> property. Note that Rhino supports mixed meshes containing not only triangles but also quads simultaneously. Newer versions also allow meshes with polygonal faces.</p> <pre><code>\"\"\" Mesh Construction\n\"\"\"\nmesh = Mesh( )\n\na = mesh.Vertices.Add( 0.0, 0.0, 0.0 )\nb = mesh.Vertices.Add( 1.0, 0.0, 0.0 )\nc = mesh.Vertices.Add( 1.0, 1.0, 0.0 )\nd = mesh.Vertices.Add( 0.0, 1.0, 0.0 )\n\nmesh.Faces.AddFace( a, b, c )\nmesh.Faces.AddFace( c, d, a )\n\n''' add quadrilateral '''\n\nmesh.Faces.Add( a, b, c, d )\n</code></pre> <p>Note that mesh points in Rhino are represented by <code>Point3f</code> using single precision floating point numbers instead of <code>Point3d</code> which use doubles. This is because graphics cards work faster with lower precision values. Nevertheless, <code>Point3f</code> does not implement the range of methods <code>Point3d</code> does, thus for performing computations conversion is required.</p> <pre><code>\"\"\" Retrieve Mesh Vertex\n\"\"\"\nvertex = mesh.Vertices[0]\n\n\"\"\" Convert to Point3d\n\"\"\"\npoint = Point3d( vertex )\n\n\"\"\" Perform Computation\n\"\"\"\npoint += Vector3d.ZAxis\n\n\"\"\" Convert to Point3f\n\"\"\"\nmesh.Vertices[0] = Point3f( point.X, point.Y, point.Z )\n\n''' equivalent '''\n\nmesh.Vertices.SetVertex( 0, point )\n</code></pre>"},{"location":"geometry/meshes/#conversions","title":"Conversions","text":"<p>Converting between indexed meshes and triangle lists is straight forward application of the indexing logic to select the appropriate vertices and package them into a list.</p> <pre><code>class IndexedMesh:\n    def __init__( self, vertices, faces ):\n        self.Vertices = vertices\n        self.Faces    = indices\n\n    def ToTriangleList( self ):\n        triangles = [self.TriangleAt( index )\n            for index in range( len( self.Faces ) )]\n        return TriangleList( triangles )\n</code></pre> <p>The opposite conversion, from a triangle list to an indexed mesh, requires flattening all triangles into a list of vertices and serially numbering the faces <code>[0, 1, 2], [3, 4, 5] ...</code>. Note that this process will not merge duplicate vertices and provide a compact the triangle soup.</p> <pre><code>class TriangleList:\n    def __init__( self, triangles ):\n        self.Triangles = triangles\n\n    def ToIndexedMesh( self ):\n        vertices, faces = [], []\n        for triangle in self.Triangles:\n            index = len( vertices )\n            faces.append( [index + 0,\n                           index + 1,\n                           index + 2] )\n            for point in triangle:\n                vertices.append( point )\n        return IndexedMesh( vertices, faces )\n</code></pre>"},{"location":"geometry/meshes/#mesh-normals","title":"Mesh Normals","text":"<p>The concept of mesh normals is associated with ideas presented in the analytical curves and surfaces section. Mesh normals are defined per mesh point and express the locally tangent plane. Therefore, the number of normals is the same with the number of points. Mesh normals can be assigned arbitrarily or computed in the approximate sense, since there are no surface derivatives for meshes as they are fundamentally non-differentiable.</p> <p>This approximation is performed by averaging the plane normals from the triangles connected with each point. There are two common methods for computing mesh normals, namely weighted and unweighted. The difference is in accumulating unnormalized or normalized normals for each triangle. In other words, using the triangle's area as a weight encoded in the cross product of its sides or not. Weighted normals is motivated by the potential presence of tiny or sliver triangles which may affect the normal direction adversely.</p> <pre><code>class IndexedMesh:\n    def __init__( self, vertices, faces, normals ):\n        self.Vertices = vertices\n        self.Faces    = faces\n        self.Normals  = normals\n\n        if( normals is None ):\n            self.ComputeNormals( )\n\n    def ComputeNormals( self, weighted = False ):\n        self.Normals = [Vector3d.Zero\n            for _ in self.Vertices]\n\n        for a, b, c in self.Faces:\n            normal = Vector3d.CrossProduct(\n                self.Vertices[b] - self.Vertices[a],\n                self.Vertices[c] - self.Vertices[b] )\n            if( not weighted ): normal.Unitize( )\n\n            self.Normals[a] += normal\n            self.Normals[b] += normal\n            self.Normals[c] += normal\n\n        for normal in self.Normals:\n            normal.Unitize( )\n        return self\n</code></pre> <p>In Rhino mesh normals have the same semantics. They can be assigned manually or computed automatically. Note that mesh normals are <code>Vector3f</code> instead of <code>Vector3d</code>, so conversions may be required.</p> <pre><code>\"\"\" Mesh Construction\n\"\"\"\nmesh = Mesh( )\n\na = mesh.Vertices.Add( 0.0, 0.0, 0.0 )\nb = mesh.Vertices.Add( 1.0, 0.0, 0.0 )\nc = mesh.Vertices.Add( 1.0, 1.0, 0.0 )\nd = mesh.Vertices.Add( 0.0, 1.0, 0.0 )\n\nmesh.Faces.AddFace( a, b, c )\nmesh.Faces.AddFace( c, d, a )\n\n''' manually '''\nfor _ in range( mesh.Vertices.Count ):\n    mesh.Normals.Add( Vector3d.ZAxis )\n\n''' computed '''\n\nmesh.Normals.ComputeNormals( )\n</code></pre>"},{"location":"geometry/meshes/#face-winding","title":"Face Winding","text":"<p>The order by which triangle points are used to define their normals is important because the cross product is not commutative. This implies that a triangle <code>[a, b, c]</code> will have its normal flipped if we use <code>[a, c, b]</code>. Meshes with inconsistent triangle winding can cause problems from visualization to 3d printing because mesh normals are used for lighting, hidden surface removal and solid closure determination.</p> <pre><code>\"\"\" Inconsistent Winding\n\"\"\"\nmesh = IndexedMesh(\n    [Point3d( 0.0, 0.0, 0.0 ),\n     Point3d( 1.0, 0.0, 0.0 ),\n     Point3d( 1.0, 1.0, 0.0 ),\n     Point3d( 0.0, 1.0, 0.0 )],\n\n    [[0, 1, 2], [0, 2, 3]] ) #-- vs. [2, 3, 0]\n</code></pre>"},{"location":"geometry/meshes/#flat-shading","title":"Flat Shading","text":"<p>Mesh normals are used for smoothly shading triangles against light sources. However, a box expressed as an indexed mesh with <code>8</code> vertices and <code>12</code> triangles arguably looks weird. This is because the normals are averaged across faces with sharp angles.</p> <p>To avoid this artifact and/or in general to force a mesh to appear with each triangle flat shaded the following approach can be used. The method below copies every triangle but the points are duplicated or unshared such that the normals will not wrap around corners.</p> <pre><code>class IndexedMesh:\n    def __init__( self, vertices, faces, normals ):\n        self.Vertices  = vertices\n        self.Faces     = faces\n        self.Normals   = normals\n        if( normals is None ):\n            self.ComputeNormals( )\n\n    def ToFlatMesh( self ):\n        points = []\n        planes = []\n        for index, ( a, b, c ) in enumerate( self.Faces ):\n            points.append( self.Vertices[a] )\n            points.append( self.Vertices[b] )\n            points.append( self.Vertices[c] )\n            planes.append( [index * 3 + 0,\n                            index * 3 + 1,\n                            index * 3 + 2] )\n        return IndexedMesh( points, planes )\n</code></pre>"},{"location":"geometry/meshes/#mesh-colors","title":"Mesh Colors","text":"<p>Assigning colors to mesh vertices is common from old-school video games to 3d printing and scientific visualization. Supporting per vertex colors is usually implemented with a list containing as many colors as the number of points. Colors may be encoded as either RGB <code>[r, g, b]</code> or RGBA <code>[r, g, b, a]</code> values, where the color components <code>r</code>, <code>g</code>, <code>b</code> and <code>a</code>,  are either expressed as bytes <code>[0, 255]</code> or floats in <code>[0.0, 1.0]</code>.</p> <pre><code>class IndexedMesh:\n    def __init__( self, vertices, faces, normals ):\n        self.Vertices  = vertices\n        self.Faces     = faces\n        self.Normals   = normals\n        self.Colors    = colors\n\n    def PaintNormals( self ):\n        self.Colors = []\n        for normal in self.Normals:\n            ''' Float RGB values [0, 1]\n            '''\n            r = ( 1.0 + normal.X ) / 2.0\n            g = ( 1.0 + normal.Y ) / 2.0\n            b = ( 1.0 + normal.Z ) / 2.0\n\n            ''' Byte RGB values [0, 255]\n            '''\n            r = int( 255 * r ) &amp; 0xFF\n            g = int( 255 * g ) &amp; 0xFF\n            b = int( 255 * b ) &amp; 0xFF\n\n            self.Colors.append( [r, g, b] )\n        return self\n\n    def PaintZ( self ):\n        ''' Min and Max Z-coordinates\n        '''\n        zmin, zmax = 1e10, -1e10\n        for point in self.Vertices:\n            zmin = min( zmin, point.Z )\n            zmax = max( zmax, point.Z )\n        dz = zmax - zmin\n        dz = 0.0 if( dz == 0.0 ) else 1.0 / dz\n\n        self.Colors = []\n        for point in self.Vertices:\n            ''' Float Gray Tone\n            '''\n            gray = ( point.Z - zmin ) * dz\n\n            ''' Byte Gray Tone\n            '''\n            gray = int( 255 * gray ) &amp; 0xFF\n            self.Colors.append( [gray, gray, gray] )\n        return self\n</code></pre> <p>Rhino uses the color format representation of .NET / Windows where alpha, red, green and blue are packed into a single 32-bit integer.</p> <pre><code>from System.Drawing import Color\n\nmesh = Mesh( )\n\na = mesh.Vertices.Add( 0.0, 0.0, 0.0 )\nb = mesh.Vertices.Add( 1.0, 0.0, 0.0 )\nc = mesh.Vertices.Add( 1.0, 1.0, 0.0 )\nd = mesh.Vertices.Add( 0.0, 1.0, 0.0 )\n\nmesh.VertexColors.Add( Color.FromArbg( 0xFF, 0xFF, 0xFF       ) ) #-- R, G, B\nmesh.VertexColors.Add( Color.FromArbg( 0xFF0000               ) ) #-- RGB\nmesh.VertexColors.Add( Color.FromArbg( 0x80, 0x00, 0xFF, 0x00 ) ) #-- A, R, G, B\nmesh.VertexColors.Add( Color.FromArbg( 0x800000FF             ) ) #-- ARGB\n\nmesh.Faces.AddFace( a, b, c )\nmesh.Faces.AddFace( c, d, a )\n</code></pre>"},{"location":"geometry/meshes/#mesh-textures","title":"Mesh Textures","text":"<p>Associating colors per vertex and letting the GPU smoothly bend them in the interior of triangles can only go as far as painting meshes with gradients. Texture mapping enables applying raster images with much more complex patterns. This is performed by associating each vertex with a texture coordinate, that is the pixel location in the image space.</p> <p>Texture coordinates <code>u</code> and <code>v</code> for the horizontal and vertical image direction, respectively, are not expressed in pixels but in the unit range <code>[0, 1]</code>. When the letters <code>s</code> and <code>t</code> are used instead of <code>u</code> and <code>v</code>, the vertical direction of the image is flipped, that is <code>u</code> and <code>s</code> are always left-to-right but <code>u</code> is bottom-to-top while <code>t</code> is top-to-bottom, that is <code>v = 1 - t</code>.</p> <pre><code>class IndexedMesh:\n    def __init__( self, vertices, faces, textures ):\n        self.Vertices  = vertices\n        self.Faces     = faces\n        self.Textures  = textures\n\nmesh = IndexedMesh(\n    [Point3d( 0.0, 0.0, 0.0 ),\n     Point3d( 1.0, 0.0, 0.0 ),\n     Point3d( 1.0, 1.0, 0.0 ),\n     Point3d( 0.0, 1.0, 0.0 )],\n\n    [[0, 1, 2], [2, 3, 0]],\n\n    [[0.0, 0.0],\n     [1.0, 0.0],\n     [1.0, 1.0],\n     [0.0, 1.0]] )\n</code></pre> <p>Rhino uses the same semantics via the <code>TextureCoordinates</code> property. Note that texture coordinates use the <code>s</code> and <code>t</code> convention and they are single precision 2D points <code>Point2f</code>.</p> <pre><code>\"\"\" Texture Coordinates\n\"\"\"\nmesh = Mesh( )\n\na = mesh.Vertices.Add( 0.0, 0.0, 0.0 )\nb = mesh.Vertices.Add( 1.0, 0.0, 0.0 )\nc = mesh.Vertices.Add( 1.0, 1.0, 0.0 )\nd = mesh.Vertices.Add( 0.0, 1.0, 0.0 )\n\nmesh.TextureCoordinates.Add( 0.0, 0.0 )\nmesh.TextureCoordinates.Add( 1.0, 0.0 )\nmesh.TextureCoordinates.Add( 1.0, 1.0 )\nmesh.TextureCoordinates.Add( 0.0, 1.0 )\n\nmesh.Faces.AddFace( a, b, c )\nmesh.Faces.AddFace( c, d, a )\n</code></pre>"},{"location":"geometry/meshes/#barycentrics","title":"Barycentrics","text":"<p>Vertex normals and colors are interpolated by the GPU for shading the interior pixels of triangles in visually smooth way. This process is known as barycentric interpolation and aims to smoothly blend between three quantities, which may be vertices, normals, colors etc.</p> <p>A point <code>p</code> within a triangle <code>[a, b, c]</code>, where <code>a</code>, <code>b</code> and <code>c</code> are its vertices, may be expressed as the ratio of areas of the triangles formed by <code>a</code>, <code>b</code>, <code>c</code> and <code>p</code>. The areas are computed using the convention <code>A = |p, b, c|</code>, <code>B = |p, c, a|</code> and <code>C = |p, a, b|</code>, where the area for vertex <code>a</code> involves point <code>p</code> and the opposite side of the triangle <code>bc</code>. The sum of these areas <code>A + B + C</code> equals the area of the triangle <code>T = |a, b, c|</code>, that is <code>A + B + C = T</code>. By dividing with the area of the triangle produces <code>A/T + B/T + C/T = 1</code>.</p> <p>The terms <code>wa = A/T</code>,  <code>wb = B/T</code> and <code>wc = C/T</code> are the barycentric coordinates or the weights of the interpolation. This because we can address every point <code>p</code> in the interior of the triangle by the weighted sum of the vertices <code>p = a * wa + b * wb + c * wc</code>.  The values of the weights are in the unit range <code>[0, 1]</code>. When the weights are <code>[1, 0, 0]</code>, <code>[0, 1, 0]</code>and <code>[0, 0, 1]</code>, then the interpolated points are on the vertices <code>a</code>, <code>b</code> and <code>c</code>, respectively. Moreover, when the weights are <code>[1/3, 1/3, 1/3]</code> the interpolated point is at the centroid of the triangle <code>( a + b + c ) / 3</code>, hence the name barycentric.</p> <p>Barycentric interpolation enables blending normals and colors by replacing the triangles' vertices with the associated vectors and RGB values. This technique produces smooth gradients and light shading in 3D graphics.</p> <pre><code>\"\"\" Barycentric Interpolation\n\"\"\"\ndef ToBarycentric( triangle, point ):\n    a, b, c = triangle\n    area = Vector3d.CrossProduct( b - a, c - b ).Length\n    return Point3d(\n        Vector3d.CrossProduct( b - point, c - b ).Length / area,\n        Vector3d.CrossProduct( c - point, a - c ).Length / area,\n        Vector3d.CrossProduct( a - point, b - a ).Length / area )\n\ndef FromBarycentric( triangle, point ):\n    a, b, c = triangle\n    return ( a * point.X +\n             b * point.Y +\n             c * point.Z )\n</code></pre>"},{"location":"geometry/meshes/#operations","title":"Operations","text":""},{"location":"geometry/meshes/#surface-area","title":"Surface Area","text":"<p>The surface area of a mesh is computed by the sum of the areas of its triangles. The area of triangles can be computed using the cross product.</p> <pre><code>class IndexedMesh:\n    def __init__( self, vertices, faces ):\n        self.Vertices = vertices\n        self.Faces    = faces\n\n    @property\n    def Triangles( self ):\n        for ia, ib, ic in self.Faces:\n            pa = self.Vertices[ia]\n            pb = self.Vertices[ib]\n            pc = self.Vertices[ic]\n            yield [pa, pb, pc]\n\n    @property\n    def Area( self ):\n        area = 0.0\n        for pa, pb, pc in self.Triangles:\n            area += Vector3d.CrossProduct(\n                pb - pa, pc - pb ).Length\n        return area / 2\n</code></pre> <p>In Rhino the <code>AreaMassProperties</code> class may be used for computing mesh volumes.</p> <pre><code>\"\"\" Computing Mesh Areas\n\"\"\"\nprops = AreaMassProperties.Create( mesh )\n\nprint( mesh.Area )\n</code></pre>"},{"location":"geometry/meshes/#mesh-volume","title":"Mesh Volume","text":"<p>Mesh volume is computed as the sum of signed volumes of tetrahedra formed by each triangle and the world origin, see detailed derivation. The volume associated with a triangle <code>[a, b, c]</code> and the world origin <code>o = [0, 0, 0]</code> is surprisingly easy to compute using <code>a \u00d7 b \u00b7 c</code>. Note that only properly closed meshes have meaningful volume.</p> <pre><code>class IndexedMesh:\n    def __init__( self, vertices, faces ):\n        self.Vertices = vertices\n        self.Faces    = faces\n\n    @property\n    def Volume( self ):\n        volume = 0.0\n        for pa, pb, pc in self.Triangles:\n            volume += Vector3d.CrossProduct( pa, pb ) * pc\n        return abs( volume / 6 )\n</code></pre> <p>In Rhino the <code>VolumeMassProperties</code> class may be used for computing mesh volumes.</p> <pre><code>\"\"\" Computing Mesh Volumes\n\"\"\"\nprops = VolumeMassProperties.Create( mesh )\n\nprint( mesh.Volume )\n</code></pre>"},{"location":"geometry/meshes/#deduplication","title":"Deduplication","text":"<p>Removing duplicate mesh vertices or converting a triangle soup to an indexed mesh with shared vertices across faces is fairly complicated. This is because it requires finding all the unique or in other words shared vertices.</p> <p>A simple approach is presented below, where an initially empty list of unique vertices and a list of faces is created. For each vertex from each triangle, first we look up whether the vertex exists or not in the unique vertex list. If the vertex exists, then we know its index, otherwise we append it at the end of the list and record the index as the length of unique vertices before insertion.</p> <p>This algorithm is slow so it should not be used for large meshes.</p> <pre><code>''' Checks if a point existing in a list of points\n    Returns the index if present, or -1 otherwise.\n'''\ndef FindPoint( target, points, epsilon = 1e-5 ):\n    for index, source in enumerate( points ):\n        if( source.DistanceTo( target ) &lt;= epsilon ):\n            return index\n    return -1\n\nclass IndexedMesh:\n    def __init__( self, vertices, faces ):\n        self.Vertices = vertices\n        self.Faces    = faces\n\n    ''' Removes duplicate vertices and returns a\n        new compacted mesh.\n    '''\n    def RemoveDuplicateVertices( self, epsilon = 1e-5 ):\n        vertices = [] #-- Unique vertices list\n        faces    = [] #-- Reindexed faces list\n        for triangle in self.Triangles:\n            face = []\n            for vertex in triangle:\n                index = FindPoint( vertex, vertices )\n                if( index &lt; 0 ):\n                    index = len( vertices )\n                    vertices.append( vertex )\n                face.append( index )\n            faces.append( face )\n        return IndexedMesh( vertices, faces )\n</code></pre>"},{"location":"geometry/meshes/topology/","title":"Mesh Topology","text":"<p>Often we need to perform geometric operations by examining relationships between the vertices, edges and faces of a mesh. Indicative examples include finding: the edge or faces connected to a vertex or the edge shared between two faces. All those relationships are captured by the notion of mesh topology. Already the indexed mesh representation is topological in the sense that it encodes mesh faces in terms of their relationship with the list of vertices.</p>"},{"location":"geometry/meshes/topology/#definitions","title":"Definitions","text":""},{"location":"geometry/meshes/topology/#nodes","title":"Nodes","text":"<p>Conceptually, a node is a shared point of a mesh. The list of points in an indexed mesh can be considered as its node list. However, a node <code>i</code> is the index of the point in the list, not the 3D point itself. Typically, nodes are integers serially numbered from <code>0</code> to <code>n - 1</code>, where <code>n</code> is the number of points. Another important property of nodes is that they represent unique points, so the mesh needs to be deduplicated.</p>"},{"location":"geometry/meshes/topology/#edges","title":"Edges","text":"<p>Mesh edges are represented by pairs of nodes <code>[s, t]</code>, where <code>s</code> and <code>t</code> are integer indices expressing which two points are connected. In cases we do not care about the direction of the edge <code>[s, t]</code> and <code>[t, s]</code> represent the same edge. However, if we do, then those two pairs represent edges with opposite directions.</p>"},{"location":"geometry/meshes/topology/#faces","title":"Faces","text":"<p>Mesh faces are represented by triplets of nodes <code>[a, b, c]</code> for triangulations, where <code>a</code>, <code>b</code> and <code>c</code> are the nodes. This is the convention already used for indexed meshes. Generally, the nodes in a face are oriented, that is their order in important, as explained in the earlier discussion about mesh normals.</p>"},{"location":"geometry/meshes/topology/#connectivity","title":"Connectivity","text":""},{"location":"geometry/meshes/topology/#face-to-node","title":"Face to Node","text":"<p>The face-to-node map enables queries such as which nodes are connected to a particular face: face \u2192 list( node ). This information is already available in the mesh faces list.</p> <pre><code>class IndexedMesh:\n    def __init__( self, vertices, faces ):\n        self.Vertices = vertices\n        self.Faces    = faces\n\n    ''' Face Index -&gt; Node Indices\n    '''\n    def NodesFromFace( self, face ):\n        return self.Faces[face]\n</code></pre>"},{"location":"geometry/meshes/topology/#node-to-face","title":"Node to Face","text":"<p>The node-to-face map enables queries such as which faces are connected to a particular node: node \u2192 list( face ). It is the exact opposite of a mesh's face list which conveys which nodes are connected to a face: face \u2192 list( node ). It may be represented as a list with the same length as the number of points, with each item containing another list of indices pointing to the mesh's faces. The faces about a node are also known as a fan or umbrella.</p> <p>The method <code>BuildNodeToFaceMap( )</code> creates a list of sets, one per node, and then iterates over each face updating the map with the node indices encountered. Sets are used because they cull duplicate node indices but they are simplified away into lists before completing the mapping. The method <code>FacesFromNode( )</code> returns a list of the faces connected to a node.</p> <pre><code>class IndexedMesh:\n    def __init__( self, vertices, faces ):\n        self.Vertices = vertices\n        self.Faces    = faces\n\n        self.BuildNodeToFaceMap( )\n\n    def BuildNodeToFaceMap( self ):\n        self.NodeToFace = [set( ) for _ in self.Vertices]\n        for index, nodes in enumerate( self.Faces ):\n            for node in nodes:\n                self.NodeToFace[node].add( index )\n        self.NodeToFace = [list( indices )\n            for indices in self.NodeToFace]\n        return self\n\n    ''' Node Index -&gt; Face Indices\n    '''\n    def FacesFromNode( self, node ):\n        return self.NodeToFace[node]\n</code></pre>"},{"location":"geometry/meshes/topology/#face-to-edge","title":"Face to Edge","text":"<p>The face-to-edge map enables queries such as which edges are connected to a particular face: face \u2192 list( edge ). Since these relationships are trivially computed from the face list, we do not need to store the data. Instead we can implement this in the form of an iterator. Additionally, in some cases we need the same edge expressed as both <code>( s, t )</code> and <code>( t, s )</code>.</p> <pre><code>class IndexedMesh:\n    def __init__( self, vertices, faces ):\n        self.Vertices = vertices\n        self.Faces    = faces\n\n    ''' Face Index -&gt; Edge Indices\n    '''\n    def EdgesFromFace( self, face, both_ways = True ):\n        nodes = self.Faces[face]\n        count = len( nodes )\n        for index in range( count ):\n            s = nodes[index]\n            t = nodes[( index + 1 ) % count]\n            yield ( s, t )\n            if( both_ways ):\n                yield ( t, s )\n</code></pre>"},{"location":"geometry/meshes/topology/#node-to-node","title":"Node to Node","text":"<p>The node-to-node map enables queries such as which nodes are connected to a particular node: node \u2192 list( node ). It has as many items as the number of points, with each item containing a list of connected nodes. It is constructed by iterating over each face, collecting the three edges encountered. Again the use of sets is to prevent duplicates. The edges between a node and its adjacent nodes are also known as spokes.</p> <pre><code>class IndexedMesh:\n    def __init__( self, vertices, faces ):\n        self.Vertices = vertices\n        self.Faces    = faces\n\n        self.BuildNodeToNodeMap( )\n\n    def BuildNodeToNodeMap( self ):\n        self.NodeToNode = [set( ) for _ in self.Vertices]\n        for a, b, c in self.Faces:\n            self.NodeToNode[a].add( b ) #-- a -&gt; b\n            self.NodeToNode[a].add( c ) #-- a -&gt; c\n\n            self.NodeToNode[b].add( c ) #-- b -&gt; c\n            self.NodeToNode[b].add( a ) #-- b -&gt; a\n\n            self.NodeToNode[c].add( a ) #-- c -&gt; a\n            self.NodeToNode[c].add( b ) #-- c -&gt; b\n        self.NodeToNode = [list( indices )\n            for indices in self.NodeToNode]\n        return self\n\n    ''' Node Index -&gt; Node Indices\n    '''\n    def NodesFromNode( self, node ):\n        return self.NodeToNode[node]\n</code></pre>"},{"location":"geometry/meshes/topology/#edge-to-face","title":"Edge to Face","text":"<p>The edge-to-face map enables queries such as which faces are connected to a particular edge: edge \u2192 list( face ). Unlike the previous maps, we do not know the number of edges in advance. Since an edge requires two indices <code>s</code> and <code>t</code>, we cannot use a lists but instead a dictionary with tuples <code>( s, t )</code> for keys. The edge-to-face map is constructed by iterating over each face, collecting the edges encountered. Again the use of sets is to prevent duplicates and we double store each edge <code>( s, t )</code> and <code>( t, s )</code> for convenience.</p> <pre><code>class IndexedMesh:\n    def __init__( self, vertices, faces ):\n        self.Vertices = vertices\n        self.Faces    = faces\n\n        self.BuildEdgeToFaceMap( )\n\n    def BuildEdgeToFaceMap( self ):\n        self.EdgeToFace = { }\n        for index in range( len( self.Faces ) ):\n            for edge in self.EdgesFromFace( index, both_ways = True ):\n                if( not ( edge in self.EdgeToFace ) ):\n                    self.EdgeToFace[edge] = set( )\n                self.EdgeToFace[edge].add( index )\n        self.EdgeToFace = [list( indices )\n            for indices in self.EdgeToFace]\n        return self\n\n    ''' Edge Indices -&gt; Face Indices\n    '''\n    def FacesFromEdge( self, edge ):\n        return self.EdgeToFace[edge]\n</code></pre>"},{"location":"geometry/meshes/topology/#face-to-face","title":"Face to Face","text":"<p>The face-to-face map enables queries such as which faces are connected to a particular face: face \u2192 list( face ). This map can be represented using a list since we know the number of faces in advance. The construction below uses the edge-to-face map as a shortcut. Since two faces are connected with one another through a shared edge, the values of the <code>EdgeToFace</code> dictionary contains faces that are incident. Thus, we just need to use their combinations making sure we don't make the superfluous association between a face and itself.</p> <pre><code>class IndexedMesh:\n    def __init__( self, vertices, faces ):\n        self.Vertices = vertices\n        self.Faces    = faces\n\n        self.BuildEdgeToFaceMap( )\n        self.BuildFaceToFaceMap( )\n\n    def BuildFaceToFaceMap( self ):\n        self.FaceToFace = [set( ) for _ in self.Faces]\n        for faces in self.EdgeToFace.values( ):\n            for source in faces:\n                for target in faces:\n                    if( source != target ):\n                        self.FaceToFace[source].add( target )\n        self.FaceToFace = [list( indices )\n            for indices in self.FaceToFace]\n        return self\n\n    ''' Face Index -&gt; Face Indices\n    '''\n    def FacesFromFace( self, face ):\n        return self.FaceToFace[face]\n</code></pre>"},{"location":"geometry/meshes/topology/#rhino-topology","title":"Rhino Topology","text":"<p>In Rhino mesh topology is available via the <code>MeshTopologyVertices</code> and <code>MeshTopologyEdges</code> properties of a mesh object. The term topology vertices is associated with the concept of a node and it is used to contrast with geometry vertices or just mesh vertices.</p> <p>Rhino performs vertex deduplication before constructing the topology data structures. If the mesh has no duplicates then the topology vertices, or nodes, are identical to the geometry vertices. However, if there are duplicate geometry vertices then a single topology vertex, or node, is associated with all of them. Therefore, conversion between geometry to topology vertices is one-to-one but reverse is in general one-to-many.</p> <pre><code>\"\"\" Mesh has duplicates if counts are unequal\n\"\"\"\nprint( mesh.Vertices.Count )\nprint( mesh.TopologyVertices.Count )\n\n''' Topology Vertex to Geometry Vertex ( 1 -&gt; n )\n'''\nindices = mesh.TopologyVertices.MeshVertexIndices( node )\n\n''' Geometry Vertex to Topology Vertex ( 1 -&gt; 1 )\n'''\nnode = mesh.TopologyVertices.MeshVertexIndices( index )\n</code></pre> <p>Adjacencies between nodes and other topology entities can be accessed as seen below.</p> <pre><code>''' Node Adjacencies\n'''\nnodes = mesh.TopologyVertices.ConnectedTopologyVertices( node )\nedges = mesh.TopologyVertices.ConnectedEdges( node )\nfaces = mesh.TopologyVertices.ConnectedFaces( node )\n</code></pre> <p>Topology edges are expressed as <code>IndexPair</code> objects containing the source <code>s</code>  and target <code>t</code> topology vertices, named as <code>I</code> and <code>J</code>, respectively. Edges are stored in a serial format and they are accessible by index as seen below.</p> <pre><code>''' Node Indices -&gt; Edge Index\n'''\nindex = mesh.MeshTopologyEdges.GetEdgeIndex( s, t )\n\n''' Edge Index -&gt; Node Indices\n'''\nnodes = mesh.MeshTopologyEdges.GetTopologyVertices( index )\nprint( nodes.I, nodes.J )\n</code></pre> <p>Adjacencies between edges and other topology entities can be accessed as seen below.</p> <pre><code>''' Edge Adjacencies\n'''\nedges = mesh.MeshTopologyEdges.GetEdgesForFace( face )\nfaces = mesh.MeshTopologyEdges.GetConnectedFaces( edge )\n</code></pre>"},{"location":"geometry/meshes/topology/#topology-analysis","title":"Topology Analysis","text":"<p>The connectivity maps developed enable understanding several interesting mesh properties and performing operations that require information about the local  neighborhood of a vertex or face.</p>"},{"location":"geometry/meshes/topology/#boundary-edges","title":"Boundary Edges","text":"<p>The number of faces incident to an edge provides insight regarding whether the mesh is an open surface or potentially a closed solid. Edges with only one adjacent face must be on a surface boundary. Therefore, such a mesh cannot not represent a closed solid, which ought to have no boundary edges. Boundary edges are also known as naked.</p> <pre><code>class IndexedMesh:\n    def __init__( self, vertices, faces ):\n        self.Vertices = vertices\n        self.Faces    = faces\n\n    def HasBoundaryEdges( self ):\n        for faces in self.EdgeToFace.values( ):\n            if( len( faces ) == 1 ):\n                return True\n        return False\n\n    def BoundaryEdges( self ):\n        edges = set( )\n        for ( s, t ), faces in self.EdgeToFace.items( ):\n            if( len( faces ) == 1 ):\n                if( s &gt; t ): s, t = t, s\n                edges.add( ( s, t ) )\n        return list( edges )\n</code></pre>"},{"location":"geometry/meshes/topology/#non-manifold-edges","title":"Non-Manifold Edges","text":"<p>Edges with more than two incident faces are also known as non-manifold. Surfaces with non-manifold edges cannot be properly oriented in the sense of making their normals consistently points towards an interior and an exterior direction. Therefore, meshes with non-manifold edges cannot also represent closed solids.</p> <pre><code>class IndexedMesh:\n    def __init__( self, vertices, faces ):\n        self.Vertices = vertices\n        self.Faces    = faces\n\n    def HasNonManifoldEdges( self ):\n        for faces in self.EdgeToFace.values( ):\n            if( len( faces ) &gt; 2 ):\n                return True\n        return False\n\n    def NonManifoldEdges( self ):\n        edges = set( )\n        for ( s, t ), faces in self.EdgeToFace.items( ):\n            if( len( faces ) &gt; 2 ):\n                if( s &gt; t ): s, t = t, s\n                edges.add( ( s, t ) )\n        return list( edges )\n</code></pre>"},{"location":"geometry/meshes/topology/#two-manifold-edges","title":"Two-Manifold Edges","text":"<p>One of the conditions for determining whether a mesh represents a solid object is such that all its edges have exactly two adjacent faces. This is easy to check using the edge-to-face map.</p> <pre><code>class IndexedMesh:\n    def __init__( self, vertices, faces ):\n        self.Vertices = vertices\n        self.Faces    = faces\n\n    def HasSolidEdges( self ):\n        for faces in self.EdgeToFace.values( ):\n            if( len( faces ) != 2 ):\n                return False\n        return True\n</code></pre>"},{"location":"geometry/meshes/topology/#multiple-domains","title":"Multiple Domains","text":"<p>A mesh may contain multiple surface fragments that are not connected with one another. This is also known as a multiply connected domain condition. To check whether a mesh represents one continuously connected surface or solid we need to start from a face, say the first one, and walk from face to face until we visit all connected faces once. If by the end of this process the number of faces visited is not equal with total number of faces, then we know that the mesh has multiply connected domains.</p> <pre><code>class IndexedMesh:\n    def __init__( self, vertices, faces ):\n        self.Vertices = vertices\n        self.Faces    = faces\n\n    def HasMultipleDomains( self, seed = 0 ):\n        visited = set( [seed] )\n        queue = [seed]\n        while len( queue &gt; 0 ):\n            face = queue.pop( 0 )\n            for adjacent in self.FaceToFace[face]:\n                if( adjacent in visited ): continue\n                visited.add( adjacent )\n                queue.append( adjacent )\n        return len( visited ) != len( self.Faces )\n</code></pre>"},{"location":"geometry/meshes/topology/#face-orientation","title":"Face Orientation","text":"<p>Checking whether the normals of a simply connected mesh are consistently oriented can be performed by examining pairs of adjacent faces and evaluating the sign of their dot products. If all normals are aligned then the mesh fulfils another necessary condition for representing a solid.</p> <pre><code>class IndexedMesh:\n    def __init__( self, vertices, faces ):\n        self.Vertices = vertices\n        self.Faces    = faces\n\n    ''' Face Index -&gt; Face Normal\n    '''\n    def FaceNormalAt( self, face ):\n        pa, pb, pc = self.TriangleAt( face )\n        return Vector3d.CrossProduct(\n            pb - pa, pc - pb )\n\n    def HasInconsistentNormals( self ):\n        visited = set( [0] )\n        stack = [0]\n        while len( queue &gt; 0 ):\n            face = stack.pop( )\n            normal = self.FaceNormalAt( face )\n            for adjacent in self.FaceToFace[face]:\n                if( adjacent in visited ): continue\n                if( normal * self.FaceNormalAt( adjacent ) &lt; 0 ):\n                    return True\n                visited.add( adjacent )\n                stack.append( adjacent )\n        return False\n</code></pre>"},{"location":"geometry/solids/","title":"Solid Geometry","text":"<p>The objective of this section is to introduce concepts associated with various computational representations of solid objects that aim to simulate the physical world. Solids build upon ideas and the methods developed for points, curves, surfaces and meshes.</p>"},{"location":"geometry/solids/#representations","title":"Representations","text":"<p>There are several approaches available representations for solids with different advantages and limitations. In some sense they are interchangeable but this comes with loss of information or capabilities to manipulate them.</p>"},{"location":"geometry/solids/boundary/","title":"Boundary Representations","text":"<p>Boundary representations (BReps) express solids only via their outer surface characteristics, in the sense that solids are hollow or skin deep with no internal volumetric variation of matter; they are homogenous lumps, where only their boundary shape features are important. This is both a reasonable and practical abstraction for describing physical objects for design, engineering and manufacturing applications.</p> <p>BReps capture both geometric as well as topological concepts, not unlike those presented in the geometry of meshes section. So the concepts of a face, edge and node are also present here but there are also higher level topological ideas.</p>"},{"location":"geometry/solids/boundary/#bodies","title":"Bodies","text":"<p>Bodies are at the top of the BRep hierarchy objects representing solid objects with one exterior shell and zero or more interior shells. Interior shells are used for expressing internal voids or cavities. This allows for solids with no voids such as solid box as well as closed objects with cavities such as a box with a thin wall.</p> <p>Some software use a slightly different definition for allowing multiply connected domains, that is bodies contains more than one solids which are disconnected. To enable this they introduce the notion of a lump, defined as seen above, such that a body contains one or more lumps.</p> <p>Rhino does not support bodies so it is not possible to subtract two concentric spheres with different radii and produce a thin wall solid. The best that can be done is to create some connecting geometry between the inner and outer surfaces or group the two spheres.</p>"},{"location":"geometry/solids/boundary/#shells","title":"Shells","text":"<p>A shell is collection of one or more boundary faces that forms a closed and orientable envelope. Shells split space in an exterior and an interior, and vise-versa for shells used for voids. A sphere is a shell with one face, while a cube is shell with six faces. To represent a thin walled object, the outer shell's normals point towards the opposite direction of the interior shell. In both cases the normals point towards the ambient space or against the solid's interior volume.</p> <p>Rhino's Breps are essentially shells which may not comply with the closure and orientability constraints. This is why they are terms as polysurfaces which may be open or closed. A closed and orientable polysurface is equivalent to a solid body with only the exterior shell defined.</p>"},{"location":"geometry/solids/boundary/#faces","title":"Faces","text":"<p>Faces, in the geometric sense, are just bounded parametric surfaces such as planes and Nurbs surfaces. The boundary may be defined by a parametric domain or a domain curve. Faces require one exterior and zero or more interior loops. Interior loops represent surface holes. For instance a cylinder's cap is plane bounded by a circle while a tube's cap is plane bounded by two circles.</p> <pre><code>''' Solid Object\n'''\nsolid = Brep.CreateFromBox( BoundingBox(\n    Point3d( 0.0, 0.0, 0.0 ),\n    Point3d( 1.0, 1.0, 1.0 ) ) )\n\n''' Enumerating Faces\n'''\nfor index in range( solid.Faces.Count ):\n    face = solid.Faces[index]\n\n    ''' Adjacencies\n    '''\n    edges = face.AdjacentFaces( )\n    faces = face.AdjacentFaces( )\n\n    ''' Boundary\n    '''\n    loops = face.Loops\n    external = face.OuterLoop\n\n    ''' Geometry\n    '''\n    surface = face.UnderlyingSurface( )\n</code></pre>"},{"location":"geometry/solids/boundary/#edges","title":"Edges","text":"<p>Faces are adjacent with one another via edges which are often domain curves of the supporting surfaces. Edges are not generic curves floating about in space. Instead, it is better to consider them as the result of the intersection between faces, that is the meeting or common interface among faces.</p> <p>Conceptually, edges have several geometric representations simultaneously: (a) a domain curve for each associated face, and (b) a spatial curve which ought to be the same for all associated faces. For example two intersecting spheres require an edge which is a different domain curve for each sphere and a circle living in ambient space.</p> <pre><code>''' Solid Object\n'''\nsolid = Brep.CreateFromBox( BoundingBox(\n    Point3d( 0.0, 0.0, 0.0 ),\n    Point3d( 1.0, 1.0, 1.0 ) ) )\n\n''' Enumerating Edges\n'''\nfor index in range( solid.Edges.Count ):\n    edge = solid.Edges[index]\n\n    ''' Adjacencies\n    '''\n    faces = edge.AdjacentFaces( )\n\n    ''' Boundary\n    '''\n    nodes = ( edge.StartVertex,\n              edge.EndVertex )\n\n    ''' Geometry\n    '''\n    curves = edge.EdgeCurve\n</code></pre>"},{"location":"geometry/solids/boundary/#loops","title":"Loops","text":"<p>Edges form loops, also known as rings, which bound the faces in the sense of an interior and an exterior. Loops are the 2D analogue of 3D shells, so the notions of closure and orientability are important. Otherwise it is not possible to determine what is filled and what is empty. Loops must not overlap one another, such as intersections between the exterior-interior or the interior-interior. Theoretically, they may have shared points, even though this often leads to problems.</p> <pre><code>''' Solid Object\n'''\nsolid = Brep.CreateFromBox( BoundingBox(\n    Point3d( 0.0, 0.0, 0.0 ),\n    Point3d( 1.0, 1.0, 1.0 ) ) )\n\n''' Enumerating Loops\n'''\nfor index in range( solid.Loops.Count ):\n    loop = solid.Loops[index]\n\n    ''' Typology\n    '''\n    closure = loop.LoopType\n</code></pre>"},{"location":"geometry/solids/boundary/#nodes","title":"Nodes","text":"<p>Nodes express the boundaries where edges meet. The can be considered as domain parameters of each adjacent face, domain parameters of each adjacent edge and a 3D point simultaneously.</p> <pre><code>''' Solid Object\n'''\nsolid = Brep.CreateFromBox( BoundingBox(\n    Point3d( 0.0, 0.0, 0.0 ),\n    Point3d( 1.0, 1.0, 1.0 ) ) )\n\n''' Enumerating Nodes\n'''\nfor index in range( solid.Vertices.Count ):\n    node = solid.Vertices[index]\n\n    ''' Adjacencies\n    '''\n    edges = node.EdgeIndices( )\n\n    ''' Geometry\n    '''\n    point = node.Location\n</code></pre>"},{"location":"geometry/solids/boundary/#operations","title":"Operations","text":"<p>Some typical operations using BReps are presented below. Generally, it is not advisable to edit BReps directly because their dual topology and geometry representation is often fragile. Instead they can be manipulated via Boolean operations. Some common operations nevertheless are presented below.</p> <pre><code>''' Explode to Trimmed Surfaces\n'''\nsolid = Brep.CreateFromBox( BoundingBox(\n    Point3d( 0.0, 0.0, 0.0 ),\n    Point3d( 1.0, 1.0, 1.0 ) ) )\n\nbreps = [solid.Faces[index].DuplicateFace( True )\n    for index in range( solid.Faces.Count )]\n\n''' Explode tp Untrimmed Surfaces\n'''\nsurfaces = [solid.Faces[index].UnderlyingSurface( )\n    for index in range( solid.Faces.Count )]\n\n''' Brep from Surfaces\n'''\na = Brep.CreateFromCornerPoints(\n   Point3d( 0.0, 0.0, 0.0 ),\n   Point3d( 1.0, 0.0, 0.0 ),\n   Point3d( 0.0, 1.0, 0.0 ), 1e-5 )\n\nb = Brep.CreateFromCornerPoints(\n   Point3d( 0.0, 0.0, 0.0 ),\n   Point3d( 1.0, 0.0, 0.0 ),\n   Point3d( 0.0, 0.0, 1.0 ), 1e-5 )\n\nc = Brep.CreateFromCornerPoints(\n   Point3d( 0.0, 0.0, 0.0 ),\n   Point3d( 0.0, 1.0, 0.0 ),\n   Point3d( 0.0, 0.0, 1.0 ), 1e-5 )\n\nd = Brep.CreateFromCornerPoints(\n   Point3d( 1.0, 0.0, 0.0 ),\n   Point3d( 0.0, 1.0, 0.0 ),\n   Point3d( 0.0, 0.0, 1.0 ), 1e-5 )\n\nbrep = Brep.MergeBreps( [a, b, c, d], 1e-5 )\n\n''' Splitting with Surface\n'''\nplane = Brep.CreateFromCornerPoints(\n   Point3d( 0.0, 0.0, 0.5 ),\n   Point3d( 1.0, 0.0, 0.5 ),\n   Point3d( 1.0, 1.0, 0.5 ),\n   Point3d( 0.0, 1.0, 0.5 ), 1e-5 )\n\nparts = solid.Split( plane, 1e-5 )\n\n''' Surface to Brep\n'''\nsurface = NurbsSurface.CreateExtrusion(\n    PolylineCurve( [ Point3d( 0.0, 0.0, 0.0 ),\n                     Point3d( 1.0, 0.0, 0.0 ),\n                     Point3d( 1.0, 1.0, 0.0 ),\n                     Point3d( 0.0, 1.0, 0.0 ),\n                     Point3d( 0.0, 0.0, 0.0 )] ),\n       Vector3d( 1.0, 1.0, 1.0 ) )\n\nextrusion = Brep.CreateFromSurface( surface )\n\n''' Closing Planar Holes\n'''\nsolid = extrusion.CapPlanarHoles( 1e-5 )\n</code></pre>"},{"location":"geometry/solids/clouds/","title":"Point Cloud Geometry","text":"<p>Point clouds represent scenarios where topology is completely implicit, in a sense that the only relationship among points is their proximity. Data may be associated as additional components <code>p = [x, y, z, w, ..., \u03c9]</code> or couplings <code>( p, v ) = ( [x, y, z], [w, ..., \u03c9] )</code>. The density of a point cloud can be computed as the number of points per cubic unit.</p> <p>Most point cloud operations require computing the nearest neighbors of each point. For instance, to compute the normal of the implicit surface through a point, a list of nearest neighbors is first collected, up to some distance threshold, and a plane is fitted. Curvature is computed in exactly the same way but a quadratic surface is fitted instead.</p> <p>Extracting surfaces and solids from point clouds requires an intermediate structure such as a regular voxel grid or an irregular tetrahedralization, from which surface elements are interpolated. Thus, point clouds even though they are simple, they require significantly more computational resources.</p> <p>Rhino supports point clouds. Points require positional information and optionally they can store normals, colors and arbitrary scalar values.</p> <pre><code>\"\"\" Point Cloud Construction\n\"\"\"\ncloud = PointCloud( )\n\nfor index in range( 1000 ):\n    point = Point3d(\n        random.uniform( -1, 1 ),\n        random.uniform( -1, 1 ),\n        random.uniform( -1, 1 ) )\n\n    normal = Vector3d(\n        random.uniform( -1, 1 ),\n        random.uniform( -1, 1 ),\n        random.uniform( -1, 1 ) )\n\n    color = Color.FromArgb(\n        int( random.uniform( 0, 255 ) ),\n        int( random.uniform( 0, 255 ) ),\n        int( random.uniform( 0, 255 ) ) )\n\n    value = random.uniform( -1, 1 )\n\n    if( int( RhinoApp.Version[0] ) &gt;= 8 )\n        cloud.Add( point, normal, color, value )\n    else:\n        cloud.Add( point, normal, color )\n</code></pre> <p>Note that Grasshopper does not render point clouds. A workaround is provided below but this is equivalent to baking the geometry in the document! Therefore, it is best to use a boolean input parameter <code>pressed</code> and connect a push button such that the component does not bake point clouds unless the button is pressed.</p> <pre><code>\"\"\" Baking Point Clouds\n\"\"\"\nfrom Rhino import RhinoDoc\nif( pressed ):\n    RhinoDoc.ActiveDoc.Objects.AddPointCloud( cloud )\n</code></pre>"},{"location":"geometry/solids/constructive/","title":"Constructive Solid Geometry","text":"<p>Constructive Solid Geometry (CSG) is an early approach for describing solids via directed acyclic graphs expressing cascading solid Boolean operations. The concept of building hierarchies of Boolean operations is motivated by (a) the desire to parameterize the construction of complex solids from simpler primitives and operations, (b) the need for efficient computation because Boolean operations among solids are often very expensive.</p> <p>The geometric primitives of CSG include solid objects such as boxes, cylinders and spheres etc, but also more generally solids constructed by extrusion, revolution, sweeping etc of profiles. The Boolean operations include (a) Union, or solid addition, where two or more solids are combined, (b) Difference, or solid subtraction, where one or more solids are removed from another, and (c) Intersection where the common volume between two or more solids is computed.</p> <p>Rhino's kernel is based on BReps presented later but nevertheless it supports  the construction of solid primitives as well as Boolean operations as seen below. Additionally, by performing Boolean operation via a Grasshopper graph is very similar to CSG in the way that updates propagate only downstream in a parametric way.</p>"},{"location":"geometry/solids/constructive/#basic-primitives","title":"Basic Primitives","text":"<pre><code>\"\"\" Unit Length Cube\n\"\"\"\ncube = Brep.CreateFromBox( BoundingBox(\n    Point3d( 0.0, 0.0, 0.0 ),\n    Point3d( 1.0, 1.0, 1.0 ) ) )\n\n\"\"\" Unit Radius+Height Cone\n\"\"\"\ncone = Brep.CreateFromCone( Cone(\n    Plane.WorldXY, 1.0, 1.0 ), True )\n\n\"\"\" Unit Radius Sphere\n\"\"\"\nball = Brep.CreateFromSphere( Sphere(\n    Plane.WorldXY, 1.0 ) )\n</code></pre>"},{"location":"geometry/solids/constructive/#constructions","title":"Constructions","text":"<p>Examples of extrusion, revolution and sweeping are presented below. Note that in Rhino we need to manually put end caps to make solids.</p> <pre><code>\"\"\" Solid by Extrusion\n\"\"\"\nprofile = PolylineCurve( [\n    Point3d(-1.0, 0.0, 0.0 ),\n    Point3d( 0.0, 0.0, 1.0 ),\n    Point3d( 1.0, 0.0, 0.0 ),\n    Point3d( 0.0, 0.0,-1.0 ),\n    Point3d(-1.0, 0.0, 0.0 )] )\n\nsolid = Extrusion.Create(\n    profile, 5.0, True )\n\n\"\"\" Solid by Revolution\n\"\"\"\nprofile = Polyline( [\n    Point3d( 3.0, 0.0, 0.0 ),\n    Point3d( 4.0, 0.0, 1.0 ),\n    Point3d( 5.0, 0.0, 0.0 ),\n    Point3d( 4.0, 0.0,-1.0 ),\n    Point3d( 3.0, 0.0, 0.0 )] )\n\naxis = Line(\n    Point3d( 0.0, 0.0, 0.0 ),\n    Point3d( 0.0, 0.0, 1.0 ) )\n\nsolid = Brep.CreateFromRevSurface(\n    RevSurface.Create( profile, axis,\n        0.0, math.pi * 2 ), False, False )\n\n\"\"\" Solid by Sweep\n\"\"\"\nprofile = PolylineCurve( [\n    Point3d(-1.0, 0.0, 0.0 ),\n    Point3d( 0.0, 0.0, 1.0 ),\n    Point3d( 1.0, 0.0, 0.0 ),\n    Point3d( 0.0, 0.0,-1.0 ),\n    Point3d(-1.0, 0.0, 0.0 )] )\n\nrail = NurbsCurve.Create( False, 2,[\n    Point3d( 0.0, 0.0, 0.0 ),\n    Point3d( 2.0, 3.0, 0.0 ),\n    Point3d( 2.0, 0.0, 4.0 )] )\n\nsolid = Brep.CreateFromSweep(\n    rail, profile, True, 1e-5 )\nsolid = Brep.CapPlanarHoles(\n    solid[0], 1e-5 )\n</code></pre>"},{"location":"geometry/solids/constructive/#boolean-operations","title":"Boolean Operations","text":"<p>Rhino supports the typical solid Boolean operations. They all require a tolerance parameter used internally for approximate operations such as intersections using floating point numbers. They also all return a collection of solids because there may be more than one resulting solids and even possibly no results at all.</p> <p>Boolean union requires a list of solid objects which if they intersect, they will form a single solid uniting or absorbing their overlapping parts. Union is commutative in the sense that the order of the solids does not matter. On the other hand Boolean difference is not commutative, therefore the first solid, or list of solids, is considered the subject and the second solid, or list of solids, is the object to be removed. The split operation is exactly the same as the difference operation but both the remaining and removed parts of the solid operation are returned. Boolean intersection computes the common solid between its operands, which may be empty if they don't overlap. Intersection is also commutative even though the style of parameter passing appears closer to the difference.</p> <pre><code>\"\"\" Solid Primitives\n\"\"\"\none = Brep.CreateFromBox( BoundingBox(\n    Point3d( 0.0, 0.0, 0.0 ),\n    Point3d( 1.0, 1.0, 1.0 ) ) )\n\ntwo = Brep.CreateFromBox( BoundingBox(\n    Point3d( 0.5, 0.5, 0.5 ),\n    Point3d( 1.5, 1.5, 1.5 ) ) )\n\n\"\"\" Boolean Union\n\"\"\"\nsolids = Brep.CreateBooleanUnion( [one, two], 1e-5 )\n\n\"\"\" Boolean Difference\n\"\"\"\nsolids = Brep.CreateBooleanDifference( one, two, 1e-5 )\n\n\"\"\" Boolean Split\n\"\"\"\nsolids = Brep.CreateBooleanSplit( one, two, 1e-5 )\n\n\"\"\" Boolean Intersection\n\"\"\"\nsolids = Brep.CreateBooleanIntersection( one, two, 1e-5 )\n</code></pre>"},{"location":"geometry/solids/voxels/","title":"Volumetric Representations","text":"<p>For certain applications, including medical, engineering and scientific, the outer shape of solid objects is just insufficient. Consider any physical object with varied interior material properties for instance. Such objects cannot be represented easily using the above representations.</p> <p>In general, the same challenge of representation is encountered in every scenario where we need to address information, physical or otherwise, volumetrically. In other words, to consider space as a dense set of properties defined at every point within it.</p> <p>There are at least two ways to achieve this including (a) structured, where space is represented using for instance a regular 3D grid of properties, and (b) unstructured, where point clouds are used to carry the information. In both cases the concept of a shape is implicit in the sense that it is subject to defining which property, or relationship thereof, is of interest and then extracting it.</p> <p>The data associated with points in space may be sourced from sensors such as CT and 3D scanners, from simulations such as FEA and CFD, or from mathematical functions whereby three coordinates produce a value <code>v = f( x, y, z )</code>.</p>"},{"location":"geometry/solids/voxels/#voxel-space","title":"Voxel Space","text":"<p>Voxels are 3D pixels associated with regular grids of points, which are typically rectangular, and the volumes between them, typically cubes. Using this representation it is possible to associate any kind of information with the points and/or the volumes. Shapes such as surfaces and solids may be extracted by determining face elements that adhere to some rule.</p> <p>Capabilities available using this representation include: (a) surfaces of arbitrary topology can be represented, (b) Boolean operations can be computed in a trivially, (c) some unique operations such as blending shapes. Limitations include: (a) they are computationally much more expensive than other representations, (b) the surfaces and solids are finite approximations which are often reduced to unstructured meshes.</p>"},{"location":"geometry/solids/voxels/#point-grid","title":"Point Grid","text":"<p>The implementation below defines a grid using an axis aligned bounding box and a resolution, that is the number of points, per axis. The points of the grid are not computed, to save memory, but instead interpolated. The values associated per point are just scalar initially set to zero. They are stored in a nested list of floats. The <code>PointIndices( )</code> enumerator simplifies the process of iterating over all points without using triple for-loops.</p> <pre><code>\"\"\" Voxel Grid\n\"\"\"\nclass VoxelGrid:\n    \"\"\" Constructor\n    \"\"\"\n    def __init__( self, minimum, maximum, resolution ):\n        self.Min    = minimum        #-- Minimum Point : Point3d\n        self.Max    = maximum        #-- Maximum Point : Point3d\n        self.Count  = resolution     #-- Resolution    : [int, int, int]\n        self.Reset( )\n\n    \"\"\" Reset Values\n    \"\"\"\n    def Reset( self, value = 0.0 ):\n        nx, ny, nz = self.Count\n        self.Values = [[[0.0\n            for iz in range( nz )]\n                for iy in range( ny )]\n                    for ix in range( nx )]\n        return self\n\n    \"\"\" Point Index Enumeration\n    \"\"\"\n    def PointIndices( self ):\n        nx, ny, nz = self.Count\n        for ix in range( nx ):\n            for iy in range( ny ):\n                for iz in range( nz ):\n                    yield ( ix, iy, iz )\n\n    \"\"\" Value at Index\n    \"\"\"\n    def ValueAt( self, ix, iy, iz ):\n        return self.Values[ix][iy][iz]\n\n    \"\"\" Point at Index\n    \"\"\"\n    def PointAt( self, ix, iy, iz ):\n        nx, ny, nz = self.Count\n        tx = ix / ( nx - 1 )\n        ty = iy / ( ny - 1 )\n        tz = iz / ( nz - 1 )\n        return Point3d(\n            self.Min.X * ( 1 - tx ) + self.Max.X * tx,\n            self.Min.Y * ( 1 - ty ) + self.Max.Y * ty,\n            self.Min.Z * ( 1 - tz ) + self.Max.Z * tz )\n\n    \"\"\" Grid Points\n    \"\"\"\n    def Points( self ):\n        for ix, iy, iz in self.PointIndices( ):\n            yield self.PointAt( ix, iy, iz )\n\n\"\"\" All Grid Points\n\"\"\"\ngrid = VoxelGrid(\n    Point3d( -1, -1, -1 ),\n    Point3d(  1,  1,  1 ),\n    [4, 5, 6] )\n\npoints = list( grid.Points( ) )\n</code></pre>"},{"location":"geometry/solids/voxels/#voxel-grid","title":"Voxel Grid","text":"<p>Voxels are defined as the vertices of boxes referenced from the lowest point indices with respect to the grid's axes. Their eight vertices are thus combinations of an <code>[ix, iy, iz]</code> index and the ones vector <code>[+1, +1, +1]</code>. The <code>VoxelIndices( )</code> indices iterator produces all voxel indices for simplifying for-loops. Note that the iterator skips the last point per direction.</p> <p>Voxel vertices are ordered counter clockwise in the XY-plane and then upwards in the Z-direction, as seen in the <code>VoxelPointsAt( )</code> method. For constructing bounding boxes, only the reference index <code>[ix, iy, iz]</code> and the opposite extreme vertex <code>[ix + 1, iy + 1, iz + 1]</code> are required.</p> <pre><code>class VoxelGrid:\n    \"\"\" Voxel Index Enumerator\n    \"\"\"\n    def VoxelIndices( self ):\n        nx, ny, nz = self.Count\n        for ix in range( nx - 1 ):\n            for iy in range( ny - 1 ):\n                for iz in range( nz - 1 ):\n                    yield ( ix, iy, iz )\n\n    \"\"\" Voxel Points at Index\n    \"\"\"\n    def VoxelPointsAt( self, ix, iy, iz ):\n        return [self.PointAt( ix + 0, iy + 0, iz + 0 ),\n                self.PointAt( ix + 1, iy + 0, iz + 0 ),\n                self.PointAt( ix + 1, iy + 1, iz + 0 ),\n                self.PointAt( ix + 0, iy + 1, iz + 0 ),\n\n                self.PointAt( ix + 0, iy + 0, iz + 1 ),\n                self.PointAt( ix + 1, iy + 0, iz + 1 ),\n                self.PointAt( ix + 1, iy + 1, iz + 1 ),\n                self.PointAt( ix + 0, iy + 1, iz + 1 )]\n\n    \"\"\" Voxel Enumerator\n    \"\"\"\n    def Voxels( self ):\n        for ix, iy, iz in self.VoxelIndices( ):\n            yield self.VoxelPointsAt( ix, iy, iz )\n\n    \"\"\" Bounding Box at Index\n    \"\"\"\n    def VoxelBoundsAt( self, ix, iy, iz ):\n        return BoundingBox(\n            self.PointAt( ix + 0, iy + 0, iz + 0 ),\n            self.PointAt( ix + 1, iy + 1, iz + 1 ) )\n\n    \"\"\" Bounding Box Enumerator\n    \"\"\"\n    def VoxelBounds( self ):\n        for ix, iy, iz in self.VoxelIndices( ):\n            yield self.VoxelBoxAt( ix, iy, iz )\n\n\"\"\" All Bounding Boxes\n\"\"\"\ngrid = VoxelGrid(\n    Point3d( -1, -1, -1 ),\n    Point3d(  1,  1,  1 ),\n    [4, 5, 6] )\n\nboxes = list( grid.VoxelBounds( ) )\n</code></pre> <p>Using relative offsets <code>[ix + dx, iy + dy, iz + dz]</code> from the reference index <code>[ix, iy, iz]</code> is a very common idiom when using voxels. Instead of copying and pasting the same expression while adjusting the offsets, we can store them in a nested list,  also known as a look up table, and simplify life as seen below.</p> <pre><code>class VoxelGrid:\n    \"\"\" Voxel Vertex Index LUT\n    \"\"\"\n    Vertices = [\n        [0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0],\n        [0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]]\n\n    \"\"\" Voxel Values at Index\n    \"\"\"\n    def VoxelValuesAt( self, ix, iy, iz ):\n        return [self.Values[ix + dx][iy + dy][iz + dz]\n            for dx, dy, dz in VoxelGrid.Vertices]\n\n    \"\"\" Voxel Points at Index\n    \"\"\"\n    def VoxelPointsAt( self, ix, iy, iz ):\n        return [self.PointAt( ix + dx, iy + dy, iz + dz )\n            for dx, dy, dz in VoxelGrid.Vertices]\n</code></pre>"},{"location":"geometry/solids/voxels/#interpolation","title":"Interpolation","text":"<p>Evaluating points and values within each voxel using normalized parameters <code>u</code>, <code>v</code> and <code>w</code>, with respect to the grid's directions, can be performed with trilinear interpolation. The process uses the concept of linear interpolation between two points at a parameter recursively. The ability to approximate a value at each position is space is what makes this representation special.</p> <p>Trilinear interpolation is computed by two bilinear interpolations for the upper <code>a, b, c, d</code> and lower <code>e, f, g, h</code> faces of the voxel using parameters <code>u</code> and <code>v</code>. The result are two points <code>p</code> and <code>q</code> within each face for which a linear interpolation using <code>w</code> computes the interior quantity.</p> <p>Bilinear interpolation within a face <code>a, b, c, d</code> is computed by two linear interpolations between the upper <code>a, b</code> and lower edges <code>d, c</code> of a face using parameter <code>u</code>. These yield two points <code>p</code> and <code>q</code> which are interpolated with parameter <code>v</code>.</p> <pre><code>class VoxelGrid:\n    \"\"\" Linear Interpolation\n    \"\"\"\n    def Interpolate1D( self, nodes, t ):\n        return nodes[0] * ( 1 - t ) + nodes[1] * t\n\n    \"\"\" Bilinear Interpolation\n    \"\"\"\n    def Interpolate2D( self, nodes, u, v ):\n        return self.Interpolate1D(\n              [self.Interpolate1D( nodes[0:2], u ),\n               self.Interpolate1D( nodes[2:4], u )], v )\n\n    \"\"\" Trilinear Interpolation\n    \"\"\"\n    def Interpolate3D( self, nodes, u, v, w ):\n        return self.Interpolate1D(\n              [self.Interpolate2D( nodes[0:4], u, v ),\n               self.Interpolate2D( nodes[4:8], u, v )], w )\n\n    \"\"\" Evaluate Point and Value at Parameters\n    \"\"\"\n    def Evaluate( self, ix, iy, iz, u, v, w ):\n        points = self.VoxelPointsAt( ix, iy, iz )\n        values = self.VoxelValuesAt( ix, iy, iz )\n\n        return ( self.Interpolate3D( points, u, v, w ),\n                 self.Interpolate3D( values, u, v, w ) )\n</code></pre> <p>Interpolating points at values along edges can be performed also in the linear sense. For an edge defined by two points <code>p</code> and <code>q</code> and the associated values  <code>u</code> and <code>v</code>, the point at value <code>w</code> can be computed by first normalizing the value <code>t = ( w - u ) / ( v - u )</code> and then performing point interpolation <code>p * ( 1 - t ) + q * t</code>. If <code>w = u</code> or <code>w = v</code> then <code>t = 0</code> or <code>t = 1</code> and thus the result will be <code>p</code> and <code>q</code>, respectively. Note that if <code>u = v</code> the interpolation raises division by zero.</p> <pre><code>class VoxelGrid:\n    \"\"\" Interpolate Edge at Value\n    \"\"\"\n    def InterpolateEdge( self, p, u, q, v, w ):\n        t = ( w - u ) / ( v - u )\n        return p * ( 1 - t ) + q * t\n</code></pre>"},{"location":"geometry/solids/voxels/#tetrahedra","title":"Tetrahedra","text":"<p>While voxels are simple, using them directly for extracting surfaces can get fairly complicated. Instead, using tetrahedra simplifies computations significantly. There are two ways to convert a voxel box to a list of tetrahedra: (a) connecting from the reference index to all faces of the box which requires six tetras, and (b) using the minimum decomposition which requires only five.</p> <p></p> <p>Using fewer tetrahedra produces surfaces with fewer faces but there is a problem: Unlike the six-tetrahedron decomposition which tiles nicely by translation, the five-tetrahedron case requires consecutive voxels to be reflected such that their edges coincide.</p> <p></p> <p>Reflecting voxels in a 3D checkerboard pattern can be expressed using bitwise operations, that is <code>( ix ^ iy ^ iz ) &amp; 1</code>. Using bitwise <code>&amp; 1</code> with any number returns its least significant bit. This is either <code>0</code> for even or <code>1</code> for odd numbers. The bitwise exclusive-or operation <code>x ^ y</code> between two numbers flips their bits using the truth table seen below.</p> <code>ix ^ iy</code> 0 1 <code>( ix ^ iy ) ^ iz</code> 0 1 0 1 0 1 0 1 1 0 1 0 1 0 <p>Computing the vertices of tetrahedra given a voxel at index <code>[ix, iy, iz]</code> is based on a look up table, namely <code>VoxelGrid.Tetras</code>. It contains <code>2</code> groups, one for even and one for odd voxels. A group contains <code>5</code> lists, one per tetrahedron, with <code>4</code> indices each, one per vertex. The numbers address the offsets we need to apply as defined in the <code>VoxelGrid.Vertices</code>.</p> <p>For example, the first entry <code>[0, 2, 5, 7]</code> represents a tetrahedron with (a) index <code>0</code> which maps to offset <code>[0, 0, 0]</code> that is the origin of the voxel, (b) index <code>2</code> which maps to offset <code>[1, 1, 0]</code> that is the upper-right node of the bottom face of the voxel, (c) index <code>5</code> which maps to offset <code>[1, 0, 1]</code> that is the upper-left node of the top face of the voxel, and (d) index <code>7</code> which maps to offset <code>[0, 1, 1]</code> that is the lower-right node of the top face of the voxel.</p> <pre><code>class VoxelGrid:\n    Tetras = [\n        [[0, 2, 5, 7], [0, 4, 5, 7], #-- Even\n         [0, 2, 3, 7], [2, 5, 6, 7],\n         [0, 1, 2, 5]],\n\n        [[0, 1, 3, 4], [1, 4, 5, 6], #-- Odd\n         [3, 4, 6, 7], [1, 2, 3, 6],\n         [1, 3, 4, 6]]]\n</code></pre> <p>With those concepts in place, the <code>TetrahedronPointsAt( )</code> method: (a) first computes the <code>parity</code> and selects the appropriate <code>reflection = Tetras[parity]</code>, (b) then it selects one of the five tetrahedra <code>tetra = reflection[index]</code>, where <code>index</code> is in <code>[0, 4]</code>, (c) then for each <code>vertex</code> in the <code>tetrahedron</code>, it looks up the associated <code>offset = Vertices[vertex]</code>, and (d) evaluates the grid point using the current voxel index <code>[ix, iy, iz]</code> with the computed offset using <code>point = PointAt( ix + dx, iy + dy, iz + dz )</code>.</p> <pre><code>class VoxelGrid:\n    \"\"\" Tetrahedron Points\n    \"\"\"\n    def TetrahedronPointsAt( self, ix, iy, iz, index ):\n        offsets = self.TetrahedronOffsetsAt( ix, iy, iz, index )\n        return [self.PointAt( ix + dx, iy + dy, iz + dz )\n                    for dx, dy, dz in offsets]\n\n    \"\"\" Tetrahedron Values\n    \"\"\"\n    def TetrahedronValuesAt( self, ix, iy, iz, index ):\n        offsets = self.TetrahedronOffsetsAt( ix, iy, iz, index )\n        return [self.Values[ix + dx][iy + dy][iz + dz]\n                    for dx, dy, dz in offsets]\n\n    \"\"\" Tetrahedron Points and Values\n    \"\"\"\n    def TetrahedronPointsAndValuesAt( self, ix, iy, iz, index ):\n        offsets = self.TetrahedronOffsetsAt( ix, iy, iz, index )\n        points, values = [], []\n        for dx, dy, dz in offsets:\n            points.append( self.PointAt( ix + dx, iy + dy, iz + dz ) )\n            values.append( self.Values[ix + dx][iy + dy][iz + dz] )\n        return ( points, values )\n\n    \"\"\" Tetrahedra Points and Values Enumerator\n    \"\"\"\n    def TetrahedraAt( self, ix, iy, iz ):\n        for index in range( len( VoxelGrid.Tetras[0] ) ):\n            yield self.TetrahedronPointsAndValuesAt( ix, iy, iz, index )\n\n    \"\"\" Vertex Offset for Tetrahedron\n    \"\"\"\n    def TetrahedronOffsetsAt( self, ix, iy, iz, index ):\n        tetrahedron = self.TetrahedronAt( ix, iy, iz, index )\n        return [VoxelGrid.Vertices[vertex]\n                    for vertex in tetrahedron]\n\n    \"\"\" Tetrahedron for Decomposition\n    \"\"\"\n    def TetrahedronAt( self, ix, iy, iz, index ):\n        tetrahedra = self.ReflectionAt( ix, iy, iz )\n        return tetrahedra[index]\n\n    \"\"\" Reflected Voxel Decomposition\n    \"\"\"\n    def ReflectionAt( self, ix, iy, iz ):\n        parity = ( ix ^ iy ^ iz ) &amp; 1\n        return VoxelGrid.Tetras[parity]\n</code></pre> <p>The method <code>TetrahedronMeshAt( )</code> converts one tetrahedron of the voxel decomposition into a mesh that can be visualized and the <code>VoxelTetrahedraMeshesAt( )</code> method converts all of them.</p> <pre><code>class VoxelGrid:\n    \"\"\" Tetrahedron Face Indices\n    \"\"\"\n    TetraFaces = [[0, 1, 2],\n                  [1, 2, 3],\n                  [2, 0, 3],\n                  [0, 1, 3]]\n\n    \"\"\" Tetrahedron to Mesh\n    \"\"\"\n    def TetrahedronMeshAt( self, ix, iy, iz, index ):\n        mesh = Mesh( )\n        for vertex in self.TetrahedronPointsAt( ix, iy, iz, index ):\n            mesh.Vertices.Add( vertex )\n        for a, b, c in VoxelGrid.TetraFaces:\n            mesh.Faces.AddFace( a, b, c )\n        return mesh\n\n    \"\"\" Voxel to Meshes\n    \"\"\"\n    def VoxelTetrahedraMeshesAt( self, ix, iy, iz ):\n        count = len( VoxelGrid.Tetras[0] ) #-- Tetras = 5\n        return [self.TetrahedronMeshAt( ix, iy, iz, index )\n            for index in range( count )]\n\ngrid = VoxelGrid(\n    Point3d( -1, -1, -1 ),\n    Point3d(  1,  1,  1 ),\n    [4, 5, 6] )\n\ntetras = grid.VoxelTetrahedraMeshesAt( 0, 0, 0 )\n</code></pre>"},{"location":"geometry/solids/voxels/#triangulation","title":"Triangulation","text":"<p>With the ability to interpolate any point and value within the voxel grid one way to extract a shape is by choosing a constant desired value <code>w</code> and selecting all associated points and form surfaces. This process produces an envelope also known as an iso-surface.</p> <p>Consider two grid points <code>p</code> and <code>q</code> with values <code>u</code> and <code>v</code>. If the value <code>w</code> is within <code>u</code> and <code>v</code>, either <code>u \u2264 w \u2264 v</code> or <code>v \u2264 w \u2264 u</code>, then the line between <code>p</code> and <code>q</code> intersects the surface formed by all <code>w</code> values, because <code>u</code> and <code>v</code> are at the opposite sides of <code>w</code>. The point of intersection at <code>w</code> can be computed using the edge interpolation method developed earlier.</p> <p>This principle extends to all edges of a tetrahedron. First each node's value in relationship with the iso-surface is considered. If all node values are smaller than the desired iso-value, then the tetrahedron is completely inside the volume bounded by the iso-surface; and the opposite occurs when all values are greater. The remaining cases represent intersection between the iso-surface and the tetrahedron, which takes place at its edges. If three edges intersect, then a triangle is generated and a quadrilateral for four intersections. With <code>4</code> edges, we need to consider all <code>16</code> combinations of potential intersection.</p> <p></p> <p>This algorithm is known as marching tetrahedra, which is simplification of the marching cubes method. The equivalent look-up table for voxel-surface intersection requires 2<sup>8</sup> or 256 entries, see Paul Bourke's detailed documentation.</p> <p>The combinations are encoded using look up tables which help avoiding nested if-statements. The <code>Polygons</code> table contains <code>16</code> bits that map to the type of polygonal face, where <code>1</code> is for quads and <code>0</code> for triangles. Note that the first and last entries <code>2</code>, that is completely inside and outside, are never used. The <code>Windings</code> table contains permutation information as for how to reorder the points of a tetrahedron in each case such that the interpolation between vertices and thus the surface normals of the resulting face are consistent.</p> <pre><code>class VoxelGrid:\n    \"\"\" Polygon IsQuad Table\n    \"\"\"\n    Polygons =  [2, 0, 0, 1,  #-- _ T T Q\n                 0, 1, 1, 0,  #-- T Q Q T\n                 0, 1, 1, 0,  #-- T Q Q T\n                 1, 0, 0, 2]  #-- Q T T _\n\n    \"\"\" Winding Order Table\n    \"\"\"\n    Windings = [[0, 0, 0, 0], #--  0 - _ - 15\n                [0, 1, 2, 3], #--  1 - T - 14\n                [1, 0, 3, 2], #--  2 - T - 13\n                [0, 1, 2, 3], #--  3 - Q - 12\n                [2, 3, 0, 1], #--  4 - T - 11\n                [3, 1, 2, 0], #--  5 - Q - 10\n                [2, 1, 3, 0], #--  6 - Q - 9\n                [3, 0, 1, 2], #--  7 - T - 8\n                [3, 2, 1, 0], #--  8 - T - 7\n                [1, 2, 3, 0], #--  9 - Q - 6\n                [0, 2, 1, 3], #-- 10 - Q - 5\n                [2, 1, 0, 3], #-- 11 - T - 4\n                [3, 2, 1, 0], #-- 12 - Q - 3\n                [1, 2, 3, 0], #-- 13 - T - 2\n                [0, 3, 2, 1], #-- 14 - T - 1\n                [0, 0, 0, 0]] #-- 15 - _ - 0\n\n    \"\"\" Reorders Points and Value for Consistent Normals\n    \"\"\"\n    def Permutate( self, case, points, values ):\n        i, j, k, l = VoxelGrid.Windings[case]\n        return ( [points[i], points[j], points[k], points[l]],\n                 [values[i], values[j], values[k], values[l]] )\n</code></pre> <p>The sixteen scenarios of intersection between the iso-surface and the tetrahedron are encoded using four bits producing a case code with value from <code>0</code> to <code>15</code>. The <code>Scenario( )</code> method turns on a different bit for each node and combines them using addition (or bitwise or). The case code is used for selecting one of the data entries stored in the look up tables.</p> <pre><code>class VoxelGrid:\n    \"\"\" Scenario from Tetrahedron Values\n    \"\"\"\n    def Scenario( self, values, value ):\n        return ( ( 0b0001 if( values[0] &lt; value ) else 0b0000 ) +\n                 ( 0b0010 if( values[1] &lt; value ) else 0b0000 ) +\n                 ( 0b0100 if( values[2] &lt; value ) else 0b0000 ) +\n                 ( 0b1000 if( values[3] &lt; value ) else 0b0000 ) )\n</code></pre> <p>The <code>IsoSurfaceAt( )</code> method iterates over all voxels and the associated tetrahedra per voxel. First it computes the scenario using the nodal values and then invokes the <code>AddFace( )</code> method, if the tetrahedron intersects the iso-surface. Adding a new face requires determining whether the face is a triangle or quadrilateral and performing point and value permutation.</p> <pre><code>class VoxelGrid:\n    \"\"\" Iso-Surface at Value\n    \"\"\"\n    def IsoSurfaceAt( self, value ):\n        mesh = Mesh( )\n        for ix, iy, iz in self.VoxelIndices( ):\n            for points, values in self.TetrahedraAt( ix, iy, iz ):\n                case = self.Scenario( values, value )\n                if( case == 0 or case == 15 ): continue\n                self.AddFace( mesh, case, points, values, value )\n        return mesh\n\n    \"\"\" Create Iso-Surface Face at Value\n    \"\"\"\n    def AddFace( self, mesh, case, points, values, value ):\n        points, values = self.Permutate( case, points, values )\n        if( VoxelGrid.Polygons[case] ):\n            return self.AddQuad( mesh, points, values, value )\n        return self.AddTriangle( mesh, points, values, value )\n</code></pre> <p>Computing triangle or quadrilateral faces of intersection is performed by first interpolating the edge and iso-surface intersection points, followed by forming  new mesh faces. Note that adding faces into a mesh in this manner, produces the equivalent of a triangle soup, where no vertices are shared across faces.</p> <pre><code>class VoxelGrid:\n    \"\"\" Create Triangular Face\n    \"\"\"\n    def AddTriangle( self, mesh, points, values, value ):\n        a, b, c, d = points\n        A, B, C, D = values\n\n        e = self.InterpolateEdge( a, A, b, B, value )\n        f = self.InterpolateEdge( a, A, c, C, value )\n        g = self.InterpolateEdge( a, A, d, D, value )\n\n        mesh.Faces.AddFace(\n            mesh.Vertices.Add( e ),\n            mesh.Vertices.Add( f ),\n            mesh.Vertices.Add( g ) )\n        return self\n\n    \"\"\" Create Quadrilateral Face\n    \"\"\"\n    def AddQuad( self, mesh, points, values, value ):\n        a, b, c, d = points\n        A, B, C, D = values\n\n        e = self.InterpolateEdge( d, D, a, A, value )\n        f = self.InterpolateEdge( d, D, b, B, value )\n        g = self.InterpolateEdge( c, C, b, B, value )\n        h = self.InterpolateEdge( c, C, a, A, value )\n\n        mesh.Faces.AddFace(\n            mesh.Vertices.Add( e ),\n            mesh.Vertices.Add( f ),\n            mesh.Vertices.Add( g ),\n            mesh.Vertices.Add( h ) )\n        return self\n</code></pre> <p>This polygonization scheme may be improved by checking each voxel for complete inclusion or exclusion and skipping iterating its tetrahedra in those cases. Also by maintaining a dictionary of edge intersections can improve performance by avoiding duplicate computations and producing compact meshes with shared vertices.</p>"},{"location":"geometry/solids/voxels/#implicit-surfaces","title":"Implicit Surfaces","text":"<p>Voxel grids can be used for visualizing implicit surfaces <code>f( x, y, z ) = v</code> which are difficult to represent otherwise. This is because either there is no simple parametric representation or it is just algebraically too complicated to bring them in an explicit form. Implicit surfaces using voxel grids is trivial to implement. The method <code>Implicit( )</code> requires a function which receives the coordinates of each point <code>x, y, z</code> in the grid and expects a value <code>v</code>. The demonstration below, builds the genus 2 surface as seen in the implicit surfaces article.</p> <pre><code>class VoxelGrid:\n    \"\"\" Implicit Surfaces by v &lt;- f( x, y, z )\n    \"\"\"\n    def ImplicitSurface( self, function ):\n        for ix, iy, iz in self.PointIndices( ):\n            point = self.PointAt( ix, iy, iz )\n            value = function( point.X, point.Y, point.Z )\n            self.Values[ix][iy][iz] = value\n        return self\n\ngrid = VoxelGrid(\n    Point3d( -2, -2, -2 ),\n    Point3d(  2,  2,  2 ),\n    [32, 32, 32] )\n\ngrid.ImplicitSurface( lambda x, y, z: (\n    2 * y * ( y ** 2 - 3 * x ** 2 ) * ( 1 - z ** 2 ) +\n    ( x ** 2 + y ** 2 ) ** 2 -\n    ( 9 * z ** 2 - 1 ) * ( 1 - z ** 2 ) ) )\n\nsurface = grid.IsoSurfaceAt( 0.0 )\n</code></pre>"},{"location":"geometry/solids/voxels/#distance-fields","title":"Distance Fields","text":"<p>Distance fields is a representation where solid primitives, and operations thereof, are expressed via their signed distance from a point, where the sign represents volume inclusion or exclusion. Given a point <code>p</code> in space and its projection point <code>o</code> with normal <code>n</code> onto an object, the signed distance is expressed by the dot product as <code>d = n \u00b7 ( p - o )</code>.</p> <p>Visualizing signed distance fields may be performed using the voxel grid approach by computing the distances between objects and the points of the grid, storing them as the associated values and then performing meshing. It is also possible to directly render them using GPU shaders, see Inigo Quilez's documentation.</p>"},{"location":"geometry/solids/voxels/#primitives","title":"Primitives","text":"<p>The implicit representation of spatial primitives such as spheres and cylinder was presented in the surfaces section earlier. The implementation below demonstrates the computation of their signed distances.</p> <pre><code>\"\"\" Sphere Primitive\n\"\"\"\nclass Sphere:\n    def __init__( self, origin, radius ):\n        self.Origin = origin\n        self.Radius = radius\n\n    def SignedDistance( self, point ):\n        o, r = self.Origin, self.Radius\n        return o.DistanceTo( point ) - r\n\n\"\"\" Cylinder Primitive\n\"\"\"\nclass Cylinder:\n    def __init__( self, origin, direction, radius ):\n        self.Origin    = origin\n        self.Direction = direction\n        self.Radius    = radius\n\n    def SignedDistance( self, point ):\n        o, u, r = self.Origin, self.Direction, self.Radius\n        projection = o + u * ( point - o ) * u\n        return point.DistanceTo( projection ) - r\n</code></pre> <p>Parametric curves and surfaces can be converted to signed distance fields using their closest point methods. Curves are not orientable in the sense of a volume. Therefore, a radius can be used to express curved cylinders and pipes. Surfaces do provide normal vectors which may be used for slabs with directional thickness.</p> <pre><code>\"\"\" Pipe Primitive\n\"\"\"\nclass Pipe:\n    def __init__( self, curve, radius ):\n        self.Curve  = curve\n        self.Radius = radius\n\n    def SignedDistance( self, point ):\n        _, t = self.Curve.ClosestPoint( point )\n        projection = self.Curve.PointAt( t )\n        return projection.DistanceTo( point ) - self.Radius\n\n\"\"\" Slab Primitive\n\"\"\"\nclass Slab:\n    def __init__( self, surface, thickness ):\n        self.Surface   = surface\n        self.Thickness = thickness\n\n    def SignedDistance( self, point ):\n        _, u, v = self.Surface.ClosestPoint( point )\n        _, plane = self.Surface.FrameAt( u, v )\n        distance = plane.Normal * ( point - plane.Origin )\n        return distance - self.Thickness\n</code></pre> <p>Implementing the signed distance field evaluation method is exactly the same as the implicit surface method. The signed distance of each point of the grid is evaluated against the subject primitive and the value is stored.</p> <pre><code>class VoxelGrid:\n    \"\"\" Signed Distance Field Primitive\n    \"\"\"\n    def SignedDistanceField( self, subject ):\n        for ix, iy, iz in self.PointIndices( ):\n            point = self.PointAt( ix, iy, iz )\n            distance = subject.SignedDistance( point )\n            self.Values[ix][iy][iz] = distance\n\ngrid = VoxelGrid(\n    Point3d( -2, -2, -2 ),\n    Point3d(  2,  2,  2 ),\n    [32, 32, 32] )\n\ngrid.SignedDistanceField(\n    Sphere( Point3d.Origin, 1.0 ) )\n\nsurface = grid.IsoSurfaceAt( 0.0 )\n</code></pre>"},{"location":"geometry/solids/voxels/#offsetting","title":"Offsetting","text":"<p>Computing offset surfaces and creating solid shells with thin walls is trivial with signed distance fields, as seen below. These geometric operations are considerably more complex using BReps. Moreover, implementing them as classes, adhering to a <code>SignedDistance( point )</code> interface, enables a compositional style of expressing both geometric primitives and operations thereof.</p> <pre><code>class Offset:\n    def __init__( self, subject, distance ):\n        self.Subject  = subject\n        self.Distance = distance\n\n    def SignedDistance( self, point ):\n        distance = self.Subject.SignedDistance( point )\n        return distance - self.Distance\n\nclass Shell:\n    def __init__( self, subject, thickness ):\n        self.Subject   = subject\n        self.Thickness = thickness\n\n    def SignedDistance( self, point ):\n        distance = self.Subject.SignedDistance( point )\n        return abs( distance ) - self.Thickness\n\ngrid = VoxelGrid(\n    Point3d( -2, -2, -2 ),\n    Point3d(  2,  2,  2 ),\n    [32, 32, 32] )\n\ngrid.SignedDistanceField(\n    Shell( Sphere( Point3d.Origin, 1.0 ), 0.2 ) )\n\nsurface = grid.IsoSurfaceAt( 0.0 )\n</code></pre>"},{"location":"geometry/solids/voxels/#booleans","title":"Booleans","text":"<p>Boolean operations between solids can be also trivially implemented using signed distance fields using the <code>min( )</code> and <code>max( )</code> built-in functions. Moreover, these operations can be combined in complex hierarchies in the same sense as construction solid geometry.</p> <pre><code>class BooleanUnion:\n    def __init__( self, subjects ):\n        self.Subjects = subjects\n\n    def SignedDistance( self, point ):\n        distances = [subject.SignedDistance( point )\n            for subject in self.Subjects]\n        return min( distances )\n\nclass BooleanIntersection:\n    def __init__( self, subjects ):\n        self.Subjects = subjects\n\n    def SignedDistance( self, point ):\n        distances = [subject.SignedDistance( point )\n            for subject in self.Subjects]\n        return max( distances )\n\nclass BooleanDifference:\n    def __init__( self, subject, _object ):\n        self.Subject = subject\n        self.Object  = _object\n\n    def SignedDistance( self, point ):\n        subject = self.Subject.SignedDistance( point )\n        _object = self.Object .SignedDistance( point )\n        return max( subject, -_object )\n\ngrid = VoxelGrid(\n    Point3d( -2, -2, -2 ),\n    Point3d(  2,  2,  2 ),\n    [32, 32, 32] )\n\ngrid.SignedDistanceField( BooleanUnion(\n    [Sphere( Point3d( -0.5, 0, 0 ), 1 ),\n     Sphere( Point3d( +0.5, 0, 0 ), 1 )] ) )\n\nsurface = grid.IsoSurfaceAt( 0.0 )\n</code></pre>"},{"location":"geometry/solids/voxels/#blending","title":"Blending","text":"<p>Blending between shapes is also fairly straight forward to implement using a smooth version of the minimum function, see Inigo Quilez's presentation for additional details. The <code>Blend</code> class implements the quadratic interpolation scheme, where the parameter <code>kappa</code> adjust the strength of blending.</p> <pre><code>class Blend:\n    def __init__( self, subjects, kappa ):\n        self.Subjects = subjects\n        self.Kappa    = kappa * 4.0\n        self.KappaInv = 1.0 / self.Kappa\n\n    def QuadraticMin( self, a, b ):\n        k, i = self.Kappa, self.KappaInv\n        h = max( k - abs( a - b ), 0.0 ) * i\n        return min( a, b ) - h *  h * k * 0.25\n\n    def SignedDistance( self, point ):\n        distances = [subject.SignedDistance( point )\n            for subject in self.Subjects]\n        minimum = distances[0]\n        for distance in distances[1:]:\n            minimum = self.QuadraticMin(\n                minimum, distance )\n        return minimum\n\ngrid = VoxelGrid(\n    Point3d( -2, -2, -2 ),\n    Point3d(  2,  2,  2 ),\n    [32, 32, 32] )\n\ngrid.SignedDistanceField( Blend( [\n    Sphere( Point3d( -0.6, 0.0, 0.0 ), 0.4 ),\n    Sphere( Point3d(  0.6, 0.0, 0.0 ), 0.4 ),\n    Sphere( Point3d(  0.0, 0.5, 0.5 ), 0.4 )], 0.15 ) )\n\nsurface = grid.IsoSurfaceAt( 0.0 )\n</code></pre>"},{"location":"geometry/solids/voxels/#resources","title":"Resources","text":"<p>Grasshopper  Script </p>"},{"location":"geometry/surfaces/","title":"Surface Geometry","text":"<p>The objective of this section is to introduce concepts associated with flat and curved surfaces. There are three very important operations related to surfaces:</p> <ol> <li>Evaluation: Forward mapping from R<sup>2</sup> \u2192 R<sup>3</sup>, that is <code>[u, v] \u2192 [x, y, z]</code>.</li> <li>Derivatives: Geometric properties associated with differential concepts.</li> <li>Projection: Inverse mapping from R<sup>3</sup> \u2192 R<sup>2</sup>, that is <code>[x, y, z] \u2192 [u, v]</code>.</li> </ol>"},{"location":"geometry/surfaces/#representation","title":"Representation","text":"<p>Surfaces can be expressed in one of several ways, namely explicit, implicit and parametric, in the same sense there are multiple representations for curves. Those offer different kinds of intuition and capabilities. Nevertheless, the parametric representation of surfaces is the one most commonly used.</p>"},{"location":"geometry/surfaces/#point-on-surface","title":"Point On Surface","text":"<p>Parametric surfaces can be considered as a direct extension of curves in two, namely <code>u</code> and <code>v</code> instead of one parameter, that is <code>t</code>. As such as surface <code>S( u, v ) = [x, y, z]</code> renders points in space <code>p = [x, y, z]</code>.</p> <p>In Rhino the <code>Surface</code> interface, which all surfaces comply with, captures the notion of a point-on-surface via the <code>PointAt( )</code> method, see documentation.</p> <pre><code>\"\"\" Various Surfaces\n\"\"\"\nsurface = Plane.WorldXY\n\nsurface = NurbsSurface.CreateFromPoints(\n    [Point3d( 0.0, 0.0, 0.0 ),\n     Point3d( 1.0, 0.0, 0.0 ),\n     Point3d( 0.0, 1.0, 1.0 ),\n     Point3d( 1.0, 1.0, 0.0 )], 2, 2, 1, 1 )\n\n\"\"\" The PointAt Method\n\"\"\"\npoint = surface.PointAt( 0.5, 0.5 )\n</code></pre> <p>Computing points on a surface along the parametric directions is commonly expressed as a grid or flat list of points as seen below.</p> <pre><code>\"\"\" Points on Normalized Surface\n\"\"\"\nnu, nv = 2, 3\n\nflat = [surface.PointAt(\n    iu / ( nu - 1 ), iv / ( nv - 1 ) )\n        for iu in range( nu )\n            for iv in range( nv )]\n\ngrid = [[surface.PointAt(\n    iu / ( nu - 1 ), iv / ( nv - 1 ) )\n        for iu in range( nu )]\n            for iv in range( nv )]\n</code></pre>"},{"location":"geometry/surfaces/#parameterization","title":"Parameterization","text":"<p>The range of values associated with the parameters <code>u</code> and <code>v</code> follow the same conventions as with parametric curves. However, the domain of a surface requires two intervals, one for each parameter <code>u: [umin, umax]</code> and <code>v: [vmin, vmax]</code>. The minimum and maximum values are typically either associated with the unit range <code>[0, 1]</code> or arc-length <code>[0, length]</code>.</p> <p>In Rhino, the domain of a surface can be obtained using the <code>Domain( )</code> method, where the parameter specifies which interval to select.</p> <pre><code>\"\"\" Surface Domain Intervals\n\"\"\"\nud = surface.Domain( 0 )\nvd = surface.Domain( 1 )\n\nprint( 'u: [{:.3f}, {:.3f}]'.format(\n    ud.Min, ud.Max ) )\n\nprint( 'v: [{:.3f}, {:.3f}]'.format(\n    vd.Min, vd.Max ) )\n\n\"\"\" Points on Surface\n\"\"\"\nnu, nv = 2, 3\n\nflat = [surface.PointAt(\n    ud.ParameterAt( iu / ( nu - 1 ) ),\n    vd.ParameterAt( iv / ( nv - 1 ) ) )\n        for iu in range( nu )\n            for iv in range( nv )]\n\ngrid = [[surface.PointAt(\n    ud.ParameterAt( iu / ( nu - 1 ) ),\n    vd.ParameterAt( iv / ( nv - 1 ) ) )\n        for iu in range( nu )]\n            for iv in range( nv )]\n</code></pre>"},{"location":"geometry/surfaces/#derivatives","title":"Derivatives","text":"<p>The concepts associated with parametric curves extend to surfaces but the terminology and mechanics change slightly because surfaces involve two parameters.</p>"},{"location":"geometry/surfaces/#tangent-plane","title":"Tangent Plane","text":"<p>The tangent of a surface a point with parameters <code>u</code> and <code>v</code> is a plane instead of vector. It is defined via the process of computing the first derivative at <code>S( u, v )</code>. However, the result is two vectors or partial derivatives <code>Su = dS / du</code> and <code>Sv = dS / dv</code>. These define the basis vectors of the tangent plane, which are in general not orthogonal with one another.</p> <pre><code>\"\"\" Finite deltas\n\"\"\"\ndu, dv = 1e-5, 1e-5\n\n\"\"\" Point at u, v\n\"\"\"\no = surface.PointAt( u, v )\n\n\"\"\" Forward points\n\"\"\"\npu = surface.PointAt( u + du, v )\npv = surface.PointAt( u, v + dv )\n\n\"\"\" Finite partial derivatives\n\"\"\"\nSu = ( p - o ) / du\nSv = ( q - o ) / du\n\n\"\"\" Finite tangent plane\n\"\"\"\ntangent = Plane( o, Su, Sv )\n</code></pre> <p>In Rhino the <code>Evaluate( )</code> method can be used to compute partial derivative vectors of surfaces. Note that higher order partial derivatives come in expanding combinations, see Hessian matrix.</p> <pre><code>\"\"\" Surface Derivatives\n\"\"\"\n_, o, dS = surface.Evaluate( u, v, 2 )\n\n\"\"\" First Order\n\"\"\"\nSu = dS[0]\nSv = dS[1]\n\n\"\"\" Second Order\n\"\"\"\nSuu = dS[2]\nSuv = dS[3]\nSvv = dS[4]\n</code></pre>"},{"location":"geometry/surfaces/#normal-vector","title":"Normal Vector","text":"<p>The normal of a surface at <code>S( u, v )</code> is a vector perpendicular to the surface. It is defined as the normal of the tangent plane and computed via the cross product <code>Su \u00d7 Sv</code>.</p> <p>In Rhino the surface normal can be evaluated using the <code>NormalAt( )</code> method.</p> <pre><code>\"\"\" Principle\n\"\"\"\n_, o, dS = surface.Evaluate( u, v, 1 )\nnormal = Vector3d.CrossProduct( dS[0], dS[1] )\nnormal.Unitize( )\n\n\"\"\" Shortcut\n\"\"\"\nnormal = surface.NormalAt( u, v )\n</code></pre>"},{"location":"geometry/surfaces/#surface-frame","title":"Surface Frame","text":"<p>The surface frame at <code>S( u, v )</code> is just the tangent plane as presented earlier. In Rhino, it is computed using the <code>FrameAt( )</code> method. Note that planes in Rhino are orthonormal so the partial derivatives' directions and lengths are not preserved. Nevertheless, the X-axis is indeed in the direction of <code>Su</code>.</p> <pre><code>\"\"\" Principle\n\"\"\"\n_, o, dS = surface.Evaluate( u, v, 1 )\nplane = Plane( o, dS[0], dS[1] )\n\n\"\"\" Shortcut\n\"\"\"\nplane = surface.FrameAt( u, v )\n</code></pre>"},{"location":"geometry/surfaces/#fundamentals","title":"Fundamentals","text":"<p>Measuring the length of curves as well as the area of regions within surfaces is associated with a concept from calculous known as the First Fundamental Form, see additional details. It is defined by three terms, <code>E</code>, <code>F</code> and <code>G</code> forming a 2x2 matrix computed from the first order partial derivatives' dot products as <code>Su \u00b7 Su</code>, <code>Su \u00b7 Sv</code>, and <code>Sv \u00b7 Sv</code>, respectively.</p> <p>Intuitively, the dot products capture the rate by which length is changing along each direction. However, because the partial derivative vectors <code>Su</code> and <code>Sv</code> are not necessarily orthogonal with one another, their combination <code>Su \u00b7 Sv</code> needs to be considered, otherwise it would have been 0.</p> <pre><code>\"\"\" Surface Derivatives\n\"\"\"\n_, o, dS = surface.Evaluate( u, v, 1 )\n\nSu = dS[0]\nSv = dS[1]\n\n\"\"\" First Fundamental Form\n\"\"\"\nE = Su * Su\nF = Su * Sv\nG = Sv * Sv\n\nI = [[ E, F ],\n     [ F, G ]]\n</code></pre> <p>While this concept is of theoretical significance, in practice lengths and areas are computed by approximation as seen in the case of parametric curves. Curves are discretized and the sum of the linear segment lengths is computed, while areas are measured using triangulations thereof.</p> <p>The Second Fundamental Form is associated with the second order derivatives of surfaces and expresses the notion surface curvature, see additional details. Again the dot products between the normal <code>n</code> and the second order partial derivatives <code>Suu</code>, <code>Svv</code> and <code>Suv</code>, express projection lengths onto the normal, which measure the rate by which the surface is bending in each direction separately and in combinations.</p> <pre><code>\"\"\" Surface Derivatives\n\"\"\"\n_, o, dS = surface.Evaluate( u, v, 2 )\n\nSu = dS[0]\nSv = dS[1]\n\nn = Vector3d.CrossProduct( Su, Sv )\nn.Unitize( )\n\n\"\"\" Second Fundamental Form\n\"\"\"\nSuu = dS[2]\nSuv = dS[3]\nSvv = dS[4]\n\nL = Suu * n\nM = Suv * n\nN = Svv * n\n\nII = [[ L, M ],\n      [ M, N ]]\n</code></pre>"},{"location":"geometry/surfaces/#normal-curvature","title":"Normal Curvature","text":"<p>The complication with computing the curvature of surfaces is that unlike curves it is not a single value. For every point on a surface <code>S( u, v ) = p</code> there is an infinite number of curves, within the surface, passing through the point, and they all typically have different curvature values.</p> <p>The way to investigate curvature therefore first requires selecting a particular direction <code>w</code> in the tangent plane. Then using <code>p</code> as the origin and <code>w</code> and <code>n</code> as basis vectors, we define a plane that intersects the surface producing a curve for which we can compute the curvature. This concept is also known as the normal curvature.</p> <p>In practice, we do not need to perform a geometric intersection but only express the direction <code>w</code> in terms of the tangent plane's basis vectors <code>Su</code> and <code>Sv</code>. This requires solving a 2x2 linear system for <code>s</code> and <code>t</code> because the vectors are almost never orthogonal with one another. Finally, we can use the first and second fundamental forms to compute the normal curvature.</p> <pre><code>\"\"\" Direction in Tangent Plane\n\"\"\"\nw = Vector2d( wx, wy )\n\n\"\"\" Express w as t * Su + s * Sv\n\"\"\"\nt = ( ( Sv.X *  w.Y - Sv.Y *  w.X ) /\n      ( Sv.X * Su.Y - Sv.Y * Su.X ) )\ns = ( ( Su.X *  w.Y - Su.Y *  w.X ) /\n      ( Su.X * Sv.Y - Su.Y * Sv.X ) )\n\ntt = t * t\nts = t * s\nss = s * s\n\n\"\"\" Compute Normal Curvature\n\"\"\"\nk = ( ( L * tt + 2 * M * ts + N * ss ) /\n      ( E * tt + 2 * F * ts + G * ss ) )\n</code></pre>"},{"location":"geometry/surfaces/#principal-curvatures","title":"Principal Curvatures","text":"<p>Normal curvature has a minimum and a maximum value, namely <code>k_min</code> and <code>k_max</code> about the <code>w_min</code> and <code>w_max</code> directions in the tangent plane, respectively. Those are also known as the principal directions and they are orthogonal with one another and the normal, see derivation. Additionally, their mean <code>H = ( k_min + k_max ) / 2</code> and product <code>K = k_min * k_max</code> are known as the Mean and Gaussian curvature of the surface at <code>S( u, v )</code>.</p> <pre><code>\"\"\" Mean and Gaussian Curvature\n\"\"\"\nK = ( ( E * N + G * L - 2 * F * M ) /\n      ( 2 * ( E * G - F * F ) ) )\nH = ( ( L * N - M * M ) /\n      ( E * G - F * F ) )\n\n\"\"\" Minimum and Maximum Curvature\n\"\"\"\nk_min = H - math.sqrt( H * H - K )\nk_max = H + math.sqrt( H * H - K )\n\n\"\"\" Principal Directions\n\"\"\"\nw_min = Sv * ( M - k_min * F ) / ( N - k_min * G ) - Su\nw_max = Sv * ( M - k_max * F ) / ( N - k_max * G ) - Su\n\nw_min.Unitize( )\nw_max.Unitize( )\n</code></pre> <p>Rhino provides the <code>CurvatureAt( )</code> method which returns a <code>SurfaceCurvature</code> object that contains the above computed surface properties.</p> <pre><code>\"\"\" Surface Curvature\n\"\"\"\ncurvature = surface.CurvatureAt( u, v )\n\nH = curvature.Mean\nK = curvature.Gaussian\n\nk_min = curvature.Kappa( 0 )\nk_max = curvature.Kappa( 1 )\n\nw_min = curvature.Direction( 0 )\nw_max = curvature.Direction( 1 )\n</code></pre>"},{"location":"geometry/surfaces/#projection","title":"Projection","text":"<p>Projection, also known as finding the closest point, from a point <code>p</code> onto a surface <code>S</code> requires finding a point <code>o = S( u, v )</code> such that <code>p = o + n * s</code>, where <code>n</code> is the surface normal at parameters <code>[u, v]</code> and <code>s</code> is a scalar. In other words, the point of intersection <code>q</code> between the surface and a line from <code>p</code> with direction perpendicular to the surface. Projection of points on simple surfaces, such as planes and spheres, can be computed analytically. For more complex curves it requires numerical computation.</p> <p>In Rhino, surfaces implement the <code>ClosestPoint( )</code> method, which accepts the point to project and return the parameter of the surface.</p> <pre><code>\"\"\" Surface Closest Point\n\"\"\"\np = Point3d( px, py, pz )\n\n_, u, v = surface.ClosestPoint( p )\n\nq = surface.PointAt( u, v )\n</code></pre>"},{"location":"geometry/surfaces/computational/","title":"Computational Surfaces","text":"<p>Computational surfaces are representations extending the curves presented in the relevant section. Parametric surfaces are trivially implemented by reusing the code developed for curves.</p>"},{"location":"geometry/surfaces/computational/#bezier-surfaces","title":"B\u00e9zier Surfaces","text":"<p>B\u00e9zier surfaces extend B\u00e9zier curves is a straight forward manner. First instead of list of control points, surfaces require a grid of control points, with rows and columns  associated with the <code>u</code> and <code>v</code> directions. (1) To produce a point on the surface, each row of control points is evaluated using the first surface parameter as if it represents a Bezier curve. This results into a list of points which is evaluated using the second parameter as if it represents a Bezier curve. This approach can be used for computing derivatives and all associated surface properties.</p> <ol> <li>Associating rows and columns with the <code>u</code> and <code>v</code> directions is subject to implementation conventions.</li> </ol> <pre><code>class BezierSurface:\n    def __init__( self, points ):\n        self.Points = points\n\n    def Evaluate( self, u, v ):\n        curves = [BezierCurve( row )\n            for row in self.Points]\n\n        points = [curve.Evaluate( u )\n            for curve in curves]\n\n        curve = BezierCurve( points )\n        return curve.Evaluate( v )\n</code></pre> <p>Rhino exports a <code>BezierSurface</code> class however it is not implementing the <code>Surface</code> interface, see documentation. The Nurbs class however can be used instead because when the number of control points equals the degree + 1 per direction, and the control point weights are zero, then a Nurbs surface is effectively equivalent to a Bezier surface.</p>"},{"location":"geometry/surfaces/computational/#bspline-surfaces","title":"BSpline Surfaces","text":"<p>BSpline surfaces extend BSpline curves in exactly the same manner as Bezier curves do for surfaces. Like BSpline curves, the degree per direction must be specified for BSpline surfaces. Evaluating points and derivatives follows the same construction.</p> <pre><code>class BSplineSurface:\n    def __init__( self, points, degree = [1, 1] ):\n        self.Points = points\n        self.Degree = degree\n\n    def Evaluate( self, u, v ):\n        curves = [BSplineCurve( row, self.Degree[0] )\n            for row in self.Points]\n\n        points = [curve.Evaluate( u )\n            for curve in curves]\n\n        curve = BSplineCurve( points, self.Degree[1] )\n        return curve.Evaluate( v )\n</code></pre> <p>In Rhino BSpline surfaces are represented as a subset of non-rational Nurbs surfaces, that is Nurbs surfaces where all control point weights are zero.</p>"},{"location":"geometry/surfaces/computational/#nurbs-surfaces","title":"Nurbs Surfaces","text":"<p>Unsurprisingly, Nurbs surfaces extend their curve analog using exactly the same principle as the previous parametric surfaces. The only difference in that the control net contains rational points.</p> <pre><code>class NurbsSurface:\n    def __init__( self, points, degree = [1, 1] ):\n        self.Points = points\n        self.Degree = degree\n\n    def Evaluate( self, u, v ):\n        curves = [NurbsCurve( row, self.Degree[0] )\n            for row in self.Points]\n\n        points = [curve.Evaluate( u )\n            for curve in curves]\n\n        curve = NurbsCurve( points, self.Degree[1] )\n        return curve.Evaluate( v )\n</code></pre> <p>Rhino's <code>NurbsSurface</code> supports numerous construction methods, accessed via the <code>NurbsSurface.Create*</code> methods, as well as operations including , see documentation.</p> <pre><code>\"\"\" Manual Construction (avoid)\n\"\"\"\nnu, nv = 3, 4\nsurface = NurbsSurface.Create( 3,\n    False, 2, 2, nu, nv )\n\n#-- Must Set Control Points\nfor iu in range( nu ):\n    for iv in range( nv ):\n        surface.Points.SetControlPoint( iu, iv,\n            ControlPoint( iu, iv, iu | iv, 0.0 ) )\n\n#-- Must Create Knot Vectors\nsurface.KnotsU.CreateUniformKnots( 1.0 )\nsurface.KnotsV.CreateUniformKnots( 1.0 )\n\n\"\"\" Surface Construction\n\"\"\"\nsurface = NurbsSurface.CreateFromCorners(\n    Point3d( 0.0, 0.0, 0.0 ),\n    Point3d( 1.0, 0.0, 0.0 ),\n    Point3d( 0.0, 1.0, 0.0 ),\n    Point3d( 1.0, 1.0, 0.0 ) )\n\nsurface = NurbsSurface.CreateFromPoints(\n    [Point3d( 0.0, 0.0, 0.0 ),\n     Point3d( 1.0, 0.0, 0.0 ),\n     Point3d( 0.0, 1.0, 0.0 ),\n     Point3d( 1.0, 1.0, 0.0 )],\n     2, 2, 1, 1 )\n\n\"\"\" Surface Points and Vectors\n\"\"\"\npoint = surface.PointAt( u, v )\nnormal = surface.NormalAt( u, v )\n_, plane = surface.FrameAt( u, v )\ncurvature = surface.CurvatureAt( u, v )\n\n\"\"\" Iso Parametric Curves\n\"\"\"\niso_u = surface.IsoCurve( 0, u )\niso_v = surface.IsoCurve( 1, v )\n\n\"\"\" Projection\n\"\"\"\n_, u, v = surface.ClosestPoint(\n    Point3d( px, py, pz ) )\n</code></pre>"},{"location":"geometry/surfaces/euclidean/","title":"Euclidean Surfaces","text":"<p>Euclidean surfaces such as planes, spheres, cylinders and cones have been studied for centuries. They represent the most basic and commonly used surfaces in geometry.</p>"},{"location":"geometry/surfaces/euclidean/#plane","title":"Plane","text":"<p>The Euclidean plane is the most fundamental type of surface. There are several ways to define a plane presented below.</p>"},{"location":"geometry/surfaces/euclidean/#parametric","title":"Parametric","text":"<p>A plane in 3D may be defined by its origin point <code>o = [ox, oy, oz]</code> and two basis vectors such as <code>x = [xx, xy, xz]</code> and <code>y = [yx, yy, yz]</code>. In general, there is no other constraint than the vectors <code>x</code> and <code>y</code> being non-parallel. However, it is common to use orthonormal vectors, where <code>|x| = |y| = 1</code> and <code>x \u00b7 y = 0</code>, because such as choice simplifies computations.</p> <p>Points of the plane can be evaluated as linear combinations of the basis vectors as seen below. The plane's normal is constant independent of the <code>u</code> and <code>v</code> coordinates. Note that the definition below does not make any assumptions about the basis vectors being orthonormal or otherwise.</p> <pre><code>class PlaneParametric:\n    def __init__( self, origin, x_axis, y_axis ):\n        self.Origin = origin\n        self.XAxis  = x_axis\n        self.YAxis  = y_axis\n\n    def Evaluate( self, u, v ):\n        return ( self.Origin +\n                 self.XAxis * u +\n                 self.YAxis * v )\n\n    def Normal( self, u, v ):\n        return Vector3d.CrossProduct(\n            self.XAxis, self.YAxis )\n</code></pre> <p>Planes are typically considered as unbounded or infinite, however by introducing a range of allowable value per axis, also known as interval or domain, it is possible to define a bounded representation as seen below. This is a concept the can be applied to any parametric surface. Note that the parameters <code>u</code> and <code>v</code> are more natural to express normalized value within each domain, in the sense that values <code>&lt; 0</code> and <code>&gt; 1</code> denote points outside the planes bounds.</p> <pre><code>class Domain:\n    def __init__( self, v_min = 0.0, v_max = 1.0 ):\n        self.Min = v_min\n        self.Max = v_max\n\n    def Interpolate( self, t ):\n        return self.Min * ( 1 - t ) + self.Max * t\n\nclass PlaneParametricBounded( PlaneParametric ):\n    def __init__( self, origin, x_axis, y_axis,\n            x_domain = None, y_domain = None ):\n        PlaneParametric.__init__( self, origin, x_axis, y_axis )\n        self.XDomain = Domain( ) if( x_domain is None ) else x_domain\n        self.YDomain = Domain( ) if( y_domain is None ) else y_domain\n\n    def Evaluate( self, u, v ):\n        return ( self.Origin +\n                 self.XAxis * self.XDomain.Interpolate( u ) +\n                 self.YAxis * self.XDomain.Interpolate( v ) )\n</code></pre> <p>Rhino's definition of a plane follows the origin and basis vectors convention. However, the vectors are automatically orthonormalized.</p> <pre><code>\"\"\" Plane Construction\n\"\"\"\nplane = Plane(\n     Point3d( ox, oy, oz ),\n    Vector3d( xx, xy, xz ),\n    Vector3d( yz, yy, yz ) )\n\norigin = plane.Origin\nx_axis = plane.XAxis\ny_axis = plane.YAxis\n\n\"\"\" World Planes\n\"\"\"\nplane = Plane.WorldXY\nplane = Plane.WorldYZ\nplane = Plane.WorldZY\n</code></pre>"},{"location":"geometry/surfaces/euclidean/#implicit","title":"Implicit","text":"<p>A plane in 3D can be also defined using an origin point <code>o</code> and a normal vector <code>n</code>, that is a vector perpendicular to the plane. The normal vector is often assumed as unit-length <code>|n| = 1</code>. A point <code>p</code> on the plane satisfies the equation <code>n \u00b7 ( p - o ) = 0</code>, also known as the implicit form.</p> <p>The dot product between the normal <code>n</code> and a vector from the plane's origin <code>o</code> to any point <code>p</code> conveys the notion of a signed projected distance <code>d = n \u00b7 ( p - o )</code> to the plane. Therefore, the equation constraints points to be exactly on the plane by requiring their projected distance to be exactly zero <code>d = 0</code>.</p> <p>This definition is more compact but cannot be used in the parametric sense. However, for some application such requirement is not important. Below is an alternative representation and some useful methods regarding the relationship between a point the plane.</p> <pre><code>class PlaneImplicit:\n    def __init__( self, origin, normal ):\n        self.Origin = origin\n        self.Normal = normal\n\n    def SignedDistance( self, point ):\n        return self.Normal * ( point - self.Origin )\n\n    def Distance( self, point ):\n        return abs( self.SignedDistance( point ) )\n\n    def Project( self, point ):\n        return ( point + self.Normal *\n            -self.SignedDistance( point ) )\n\n    def ContainsPoint( self, point, epsilon = 1e-5 ):\n        return self.Distance( point ) &lt;= epsilon\n</code></pre> <p>A plane is also associated with the concept of a half-space, because an unbounded or infinite plane may be considered as splitting space into two parts. Moreover, the plane's normal may be used to classify objects as being in front or behind the plane using the signed distance metric. Points with positive signed distance are in the front side of the plane and points with negative in back side.</p> <pre><code>class PlaneImplicit:\n    def __init__( self, origin, normal ):\n        self.Origin = origin\n        self.Normal = normal\n\n    def SignedDistance( self, point ):\n        return self.Normal * ( point - self.Origin )\n\n    def IsPointInFront( self, point ):\n        return self.SignedDistance( point ) &gt; 0.0\n\n    def IsPointBehind( self, point ):\n        return self.SignedDistance( point ) &lt; 0.0\n</code></pre> <p>It is possible to convert from a <code>PlaneImplicit</code> to a <code>PlaneParametric</code> by finding a pair of basis vectors <code>x</code> and <code>y</code> that are both orthogonal to the normal <code>n</code>. However, this is slightly ill-defined because there is an infinite number of such vectors that are perpendicular to the normal. However, we can use the concept of the unary cross product to complete the basis vectors.</p> <pre><code>class PlaneImplicit:\n    def __init__( self, origin, normal ):\n        self.Origin = origin\n        self.Normal = normal\n\n    def ToParametric( self ):\n        x = Vector3d_UnaryCrossProduct( self.Normal )\n        y = Vector3d.CrossProduct( self.Normal, x )\n\n        x.Unitize( )\n        y.Unitize( )\n\n        return PlaneParametric( o, x, y )\n</code></pre> <p>A <code>Plane</code> in Rhino can be constructed using an origin and a normal vector. Internally, the plane is represented by its parametric form and thus resolves the basis vectors using a deterministic approach similar to the one presented.</p> <pre><code>\"\"\" Plane by Origin &amp; Normal\n\"\"\"\nplane = Plane( o, n )\n\nx_axis = plane.XAxis\ny_axis = plane.YAxis\n</code></pre>"},{"location":"geometry/surfaces/euclidean/#explicit","title":"Explicit","text":"<p>Yet, another form for a plane's equation is <code>Ax + By + Cz + D = 0</code>, where <code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code> real numbers, and <code>x</code>, <code>y</code> and <code>z</code> are the point's coordinates <code>p = [x, y, z]</code>. The linear coefficients seem geometrically void of semantics. However, we can expand the earlier implicit equation into <code>nx * ( x - ox ) + ny * ( y - oy ) + nz * ( z - oz )</code>, and then group the terms such as <code>nx * x + ny * y + nz * z - ( nx * ox + ny * oy + nz * oz )</code>. From this we can conclude that <code>A = nx</code>, <code>B = ny</code>, <code>C = nz</code>, thus the first three terms encode the normal vector. Moreover, the term <code>D = -( nx * ox + ny * oy + nz * oz )</code>, or <code>D = -n \u00b7 o</code> in short, can be interpreted as an offset from the world's origin along the normal direction by distance <code>D</code>.</p> <pre><code>class PlaneExplicit:\n    def __init__( self, A, B, C, D ):\n        self.A = A\n        self.B = B\n        self.C = C\n        self.D = D\n\n    def Normal( self, u, v ):\n        return Vector3d( self.A, self.B, self.C )\n\n    def ToImplicit( self ):\n        o = Point3d( n * -self.D )\n        n = Vector3d( self.A, self.B, self.C )\n        return PlaneImplicit( o, n )\n\n    def ToParametric( self ):\n        o = Point3d( n * -self.D )\n        z = Vector3d( self.A, self.B, self.C )\n\n        x = Vector3d_UnaryCrossProduct( z )\n        y = Vector3d.CrossProduct( z, x )\n\n        x.Unitize( )\n        y.Unitize( )\n        return self.ToImplicit( o, x, y )\n</code></pre> <p>The explicit plane representation is the most compact requiring only 4 values as opposed to 6 and 9 for the implicit and parametric forms, respectively. It is typically used for solving systems of equations but for most other geometric constructions conversion to another form is required.</p> <p>Rhino's <code>Plane</code> also supports creating planes using their explicit form as seen below. Note that internally the parametric form is used.</p> <pre><code>\"\"\" Plane from Equation\n\"\"\"\nA = 1.0\nB = 0.0\nC = 0.0\nD = 1.0\n\nP = Plane( A, B, C, D )\n</code></pre>"},{"location":"geometry/surfaces/euclidean/#triangle","title":"Triangle","text":"<p>A plane may be defined by three points or a triangle in space. It is typically constructed with the first point as the origin and the triangle's sides defining the basis vectors by orthonormalization as seen below.</p> <pre><code>\"\"\" Triangle\n\"\"\"\na = Point3d( ax, ay, az )\nb = Point3d( bx, by, bz )\nc = Point3d( cx, cy, cz )\n\n\"\"\" Orthonormal Basis\n\"\"\"\no = a     #-- origin    or ( a + b + c ) / 3\nx = b - a #-- primary   or a - o\nw = c - b #-- auxiliary or c - a\n\nz = Vector3d.CrossProduct( x, w )\ny = Vector3d.CrossProduct( z, x )\n\nx.Unitize( )\ny.Unitize( )\n\nplane = PlaneExplicit( o, x, y )\n</code></pre> <p>Rhino's <code>Plane</code> supports construction from three points as seen below.</p> <pre><code>\"\"\" Triangle\n\"\"\"\na = Point3d( ax, ay, az )\nb = Point3d( bx, by, bz )\nc = Point3d( cx, cy, cz )\n\nplane = Plane( a, b, c )\n</code></pre>"},{"location":"geometry/surfaces/euclidean/#fitting","title":"Fitting","text":"<p>Constructing a plane using more than three points is known as plane fitting, where the plane is a form of approximation in the sense that it passes as close as possible by the points. There are several very interesting algorithms to compute fitted planes.</p> <p>Rhino provides the static method <code>FitPlaneToPoints</code> which computes a fitted plane as long the number of points is greater or equal to three.</p> <pre><code>\"\"\" Plane Fitting\n\"\"\"\npoints = [\n    Point3d( 0.0, 0.0,-1.0 ),\n    Point3d( 1.0, 0.0, 0.0 ),\n    Point3d( 0.0, 1.0, 1.0 ),\n    Point3d( 1.0, 1.0, 2.0 )]\n\n_, plane = Plane.FitPlaneToPoints( points )\n</code></pre>"},{"location":"geometry/surfaces/euclidean/#sphere","title":"Sphere","text":"<p>A sphere may be considered as an extension of the circle from the plane to space in the sense that it expresses points equidistance from a fixed location. Spheres are as fundamental as planes and the oldest surfaces studied of non-zero curvature, also known as non-Euclidean. There are several representations that parallel those of the circle but generally the implicit and parametric forms are more common.</p>"},{"location":"geometry/surfaces/euclidean/#parametric_1","title":"Parametric","text":"<p>The parametric equation of a sphere is defined using trigonometric functions as <code>S( u, v ) = r[cos( u ) * cos( v ), sin( u ) * sin( v ), sin( v )]</code>, with the parameters typically within <code>u: [0, 2\u03c0]</code> or <code>u: [-\u03c0, \u03c0]</code> and <code>v: [-\u03c0/2, \u03c0/2]</code>.</p> <pre><code>class SphereParametric:\n    def __init__( self, basis, radius ):\n        self.Basis  = basis\n        self.Radius = radius\n\n    def Evaluate( self, u, v ):\n        su, cu = math.sin( u ), math.cos( u )\n        sv, cv = math.sin( v ), math.cos( v )\n\n        x = self.Radius * cu * cv\n        y = self.Radius * su * cv\n        z = self.Radius *      sv\n\n        return ( self.Basis.Origin +\n                 self.Basis.XAxis * x +\n                 self.Basis.YAxis * y +\n                 self.Basis.ZAxis * z )\n\n    def NormalAt( self, u, v ):\n        su, cu = math.sin( u ), math.cos( u )\n        sv, cv = math.sin( v ), math.cos( v )\n\n        return ( self.Basis.XAxis * cu * cv +\n                 self.Basis.YAxis * su * cv +\n                 self.Basis.ZAxis *      sv )\n</code></pre> <p>Recovering the <code>u</code> and <code>v</code> parameters from a point in space, in the closest point sense, is shown below. Note that <code>u</code> is in <code>[-\u03c0, \u03c0]</code> because of the <code>math.atan2( )</code>. Moreover, for computing the parameter <code>v</code> the expression <code>min( max( -1, value ), 1 )</code> is used to ensure that the result is clamped within <code>[-1, 1]</code> otherwise the <code>math.asin( )</code> function will raise an exception.</p> <pre><code>class SphereParametric:\n    def __init__( self, basis, radius ):\n        self.Basis  = basis\n        self.Radius = radius\n\n    def ClosestPoint( self, point ):\n        r = point - self.Basis.Origin\n        u = math.atan2( r.Y, r.X )\n        v = math.asin( min( max( -1, r.Z / r.Length ), 1 ) )\n        return ( u, v )\n</code></pre> <p>In Rhino <code>Sphere</code> objects are internally parametric and can be constructed using a plane and a radius as seen below.</p> <pre><code>\"\"\" Sphere Construction\n\"\"\"\nsphere = Sphere( Plane.WorldXY, 1.0 )\n\n\"\"\" Sphere Properties\n\"\"\"\ncenter = sphere.Center\nradius = sphere.Radius\n\nnorth = sphere.NorthPole\nsouth = sphere.SouthPole\n\norigin = sphere.EquitorialPlane.Origin\nx_axis = sphere.EquitorialPlane.XAxis\ny_axis = sphere.EquitorialPlane.YAxis\nz_axis = sphere.EquitorialPlane.ZAxis\n</code></pre>"},{"location":"geometry/surfaces/euclidean/#implicit_1","title":"Implicit","text":"<p>The implicit form of the sphere is defined by an origin <code>o</code> and a radius <code>r</code>, expressing points <code>p</code> in space constrained by <code>|p - o| = r</code>. With this definition we can determine relationships between points in space and the sphere including their distance, projection and whether they are on the sphere or otherwise.</p> <pre><code>class SphereImplicit:\n    def __init__( self, origin, radius ):\n        self.Origin = origin\n        self.Radius = radius\n\n    def Distance( self, point ):\n        return self.Origin.DistanceTo( point )\n\n    def IsPointOnSphere( self, point, epsilon = 1e-5 ):\n        return abs( self.Distance( point ) - self.Radius ) &lt;= epsilon\n\n    def ProjectPoint( self, point ):\n        u = point - self.Origin; u.Unitize( )\n        return self.Origin + u * self.Radius\n</code></pre> <p>In the same way a plane splits space in front and back parts, a sphere splits also splits space but in the inside and outside sense. Exactly because of this feature spheres may considered as both surfaces and solids at the same time.</p> <pre><code>class SphereImplicit:\n    def __init__( self, origin, radius ):\n        self.Origin = origin\n        self.Radius = radius\n\n    def IsPointInside( self, point ):\n        return self.Distance( point ) &lt; self.Radius\n\n    def IsPointOutside( self, point ):\n        return self.Distance( point ) &gt; self.Radius\n</code></pre> <p>A sphere in Rhino can be constructed from a center point and a radius as seen below.</p> <pre><code>\"\"\" Sphere Construction\n\"\"\"\nsphere = Sphere( Point3d.Origin, 1.0 )\n\n\"\"\" Sphere Properties\n\"\"\"\ncenter = sphere.Center\nradius = sphere.Radius\n</code></pre>"},{"location":"geometry/surfaces/euclidean/#stereographic","title":"Stereographic","text":"<p>The stereographic form is a representation of a sphere analogous to the rational form of a circle. Suppose a sphere is defined by a basis <code>{ o, x, y, z }</code> and radius <code>r</code> as in the parametric case. Its north and south poles are <code>n = o + z * r</code> and <code>s = o - z * r</code>, respectively. Any point <code>p</code> in space can be parameterized as <code>q = [u, v]</code> by the intersection of a line from <code>s</code> to <code>p</code> and the tangent plane at <code>n</code>, see relevant information.</p> <p>The implementation below provides the <code>Evaluate( )</code> and <code>ClosestPoint( )</code> methods in a constructive geometry sense. Note that as in the case of the rational parameterization of the circle, a point is missing from this representation, namely the point at the south pole.</p> <pre><code>class SphereStereo:\n    def __init__( self, basis, radius ):\n        self.Basis  = basis\n        self.Radius = radius\n\n    def _Expand( self ):\n        o = self.Basis.Origin\n        x = self.Basis.XAxis\n        y = self.Basis.YAxis\n        z = self.Basis.ZAxis\n        r = self.Radius\n        n = o + z * r          #-- North Pole\n        s = o - z * r          #-- South Pole\n        return ( o, x, y, z, r, n, s )\n\n    def Evaluate( self, u, v ):\n        o, x, y, z, r, n, s = self._Expand( )\n        p = n + x * u + y * v  #-- Point in North Plane\n        w = p - s              #-- Line from South\n        d = w.Length           #-- Distance s -&gt; p\n        l = w * z * r / d      #-- Proj z*r on w/|w|\n        q = s + w * l * 2 / d  #-- Point on Sphere\n        return q\n\n   def ClosestPoint( self, point ):\n        o, x, y, z, r, n, s = self._Expand( )\n        w = point - s           #-- Line from South\n        d = w.Length            #-- Distance s -&gt; p\n        h = z * w               #-- Vertical Height\n        f = 2 * r * d / h       #-- Similar Triangles\n        q = s + w * f / d       #-- Point in North Plane\n        m = q - n               #-- Vector in North Plane\n        u = x * m               #-- Parameter U\n        v = y * m               #-- Parameter V\n        return ( u, v )\n</code></pre>"},{"location":"geometry/surfaces/euclidean/#tetrahedron","title":"Tetrahedron","text":"<p>A sphere may be defined using four non-coplanar points in space or tetrahedron's vertices. There are at least two approaches in finding the origin <code>o = [x, y, z]</code> and radius   <code>r</code> of the sphere, that is by geometric construction or solving a system of equations.</p>"},{"location":"geometry/surfaces/euclidean/#fitting_1","title":"Fitting","text":"<p>A sphere that passes as close as possible to a number of points greater than four can be constructed via fitting. There are several algorithms available.</p> <p>Rhino provides the <code>FitSphereToPoints</code> for fitting spheres to point clouds.</p> <pre><code>\"\"\" Sphere Fitting\n\"\"\"\npoints = [\n    Point3d( 0.0, 0.0,-1.0 ),\n    Point3d( 1.0, 0.0, 0.0 ),\n    Point3d( 0.0, 1.0, 1.0 ),\n    Point3d( 1.0, 1.0, 2.0 ),\n    Point3d( 0.5, 0.0, 0.5 )]\n\nsphere = Sphere.FitSphereToPoints( points )\n</code></pre>"},{"location":"geometry/surfaces/euclidean/#coordinates","title":"Coordinates","text":"<p>The parametric sphere's <code>Evaluate( )</code> and <code>ClosestPoint( )</code> methods provide the principles for converting between Cartesian <code>[x, y, z]</code> and spherical coordinates <code>[r, t, p]</code>, where <code>r</code>, <code>\u03c1</code> or rho is the radial coordinate, <code>t</code>, <code>\u03b8</code> or theta is the azimuthal angle, and <code>p</code>, <code>\u03c6</code> or phi is the polar angle, as seen below.</p> <pre><code>def Point3d_FromSphere( r, t, p ):\n    sp, cp = math.sin( p ), math.cos( p )\n    st, ct = math.sin( t ), math.cos( t )\n    return ( r * cp * ct +\n             r * sp * ct +\n             r *      st )\n\ndef Point3d_ToSphere( x, y, z ):\n    r = math.sqrt( x * x + y * y + z * z )\n    t = math.asin( min( max( -1, z / r ), 1 ) )\n    p = math.atan2( y, x )\n    return ( r, t, p )\n</code></pre> <p>Spheres in Rhino may be represented using either a <code>Sphere</code>, <code>NurbSuface</code> or <code>Brep</code> objects. However, note that surfaces and breps do not retain their center and radius properties.</p> <pre><code>\"\"\" Sphere Conversions\n\"\"\"\nsurface = sphere.ToNurbsSurface( )\nsurface = NurbsSurface.CreateFromSphere( sphere )\n\nsolid = sphere.ToBrep( )\nsolid = Brep.CreateFromSphere( sphere )\n</code></pre>"},{"location":"geometry/surfaces/euclidean/#ellipsoid","title":"Ellipsoid","text":"<p>The ellipsoid has an analogous relationship with the sphere in the same way an ellipse relates to a circle. It thus requires three different radii, one per direction, instead of just one. Those may be considered as scaling factors for stretching a sphere in a non-uniform fashion.</p>"},{"location":"geometry/surfaces/euclidean/#parametric_2","title":"Parametric","text":"<p>The parametric ellipsoid is nearly identical with a sphere requiring a basis <code>{ o, x, y, z }</code>, where <code>o</code> is the origin and <code>x</code>, <code>y</code> and <code>z</code> are orthonormal basis vectors, apart from the radius member which is a 3D vector <code>r = [rx, ry, rz]</code> instead of a <code>float</code>. The parameters <code>u</code> and <code>v</code> are both angles in <code>[0, 2\u03c0]</code> or <code>[-\u03c0, \u03c0]</code>.</p> <pre><code>class EllipsoidParametric:\n    def __init__( self, basis, radius ):\n        self.Basis  = basis\n        self.Radius = radius\n\n    def Evaluate( self, u, v ):\n        su, cu = math.sin( u ), math.cos( u )\n        sv, cv = math.sin( v ), math.cos( v )\n\n        x = self.Radius.X * cu * cv\n        y = self.Radius.Y * su * cv\n        z = self.Radius.Z *      sv\n\n        return ( self.Basis.Origin +\n                 self.Basis.XAxis * x +\n                 self.Basis.YAxis * y +\n                 self.Basis.ZAxis * z )\n</code></pre>"},{"location":"geometry/surfaces/euclidean/#cylinder","title":"Cylinder","text":"<p>Cylinders combine a periodic and a linear motion. The canonical right cylinder follows a circular motion in a plane and a linear in the normal direction. Alternatively, a cylinder expresses points in space with a fixed distance from a line. Yet another form expresses the cylinder as the surface of revolution between two parallel lines. A generalized cylinder is a surface described by a profile and a direction of extrusion, in the sense that the periodic curve does not need to be a circle and the axis does not have to be orthogonal to the profile.</p>"},{"location":"geometry/surfaces/euclidean/#parametric_3","title":"Parametric","text":"<p>The parametric form requires a basis plane <code>{ o, x, y }</code>, where <code>o</code> is the origin and <code>x</code> and <code>y</code> the basis vectors, and the radius of the circular base profile <code>r</code>. The linear motion is assumed in the perpendicular direction <code>z = x \u00d7 y</code>. The parameter <code>u</code> is an angle and thus in <code>[0, 2\u03c0]</code>, while the parameter <code>v</code> can take any real value. Note that the parameters are heterogenous.</p> <pre><code>class CylinderParametric:\n    def __init__( self, basis, radius ):\n        self.Basis  = basis\n        self.Radius = radius\n\n    def Evaluate( self, u, v ):\n        return ( self.Basis.Origin +\n                 self.Basis.XAxis * self.Radius * math.cos( u ) +\n                 self.Basis.YAxis * self.Radius * math.sin( u ) +\n                 self.Basis.ZAxis * v )\n</code></pre>"},{"location":"geometry/surfaces/euclidean/#implicit_2","title":"Implicit","text":"<p>Implicitly a cylinder may be constructed from an axis and a radius <code>{ o, z, r }</code>, where <code>o</code> is the origin, <code>z</code> is the unit direction of the axis, and <code>r</code> is the radius. With those, points on a cylinder are expressed as <code>|z \u00d7 w| = r</code> or <code>|z \u00b7 w \u00b7 z - w| = r</code>, where <code>w = p - o</code>. Both constraint points in space such that their distance from a line has the desired radius, using either the cross or dot products to measure the projected distance.</p> <pre><code>class CylinderImplicit:\n    def __init__( self, origin, axis, radius ):\n        self.Origin = origin\n        self.Axis   = axis\n        self.Radius = radius\n\n    def Distance( self, point ):\n        return Vector3d.CrossProduct( self.Axis,\n            point - self.Origin ).Length\n\n    def Project( self, point ):\n        return ( self.Origin + self.Axis *\n            ( point - self.Origin ) * self.Axis )\n\n    def ContainsPoint( self, point, epsilon = 1-5 ):\n        return self.Distance( point ) &lt;= epsilon\n\n    def IsPointInside( self, point ):\n        return self.Distance( point ) &lt; self.Radius\n\n    def IsPointOutside( self, point ):\n        return self.Distance( point ) &gt; self.Radius\n</code></pre>"},{"location":"geometry/surfaces/euclidean/#cone","title":"Cone","text":"<p>Cones combine a periodic and a linear motion but unlike cylinders the two motions are coupled. Alternatively, a cone can be defined as the surface of revolution between two lines that intersect.</p>"},{"location":"geometry/surfaces/euclidean/#parametric_4","title":"Parametric","text":"<p>The parametric cone requires a basis plane <code>{ o, x, y }</code>, where <code>o</code> is the origin and <code>x</code> and <code>y</code> the basis vectors, the radius of the circular profile <code>r</code> and the included angle <code>a</code>. The linear motion is assumed in the perpendicular direction <code>z = x \u00d7 y</code>. The parameter <code>u</code> is an angle and thus in <code>[0, 2\u03c0]</code> while the parameter <code>v</code> is the distance from the cone's apex and thus it can take any real value. Note that the relationship between the distance along the axis and radius of the circle at that height is given by <code>radius = distance * tan( angle / 2 )</code>.</p> <pre><code>class ConeParametric:\n    def __init__( self, basis, radius, angle ):\n        self.Basis  = basis\n        self.Radius = radius\n        self.Alpha  = math.tan( angle / 2 )\n\n    def Evaluate( self, u, v ):\n        r = v * self.Alpha\n        x = r * math.cos( u )\n        y = r * math.sin( u )\n        z = v\n\n        return ( self.Basis.Origin +\n                 self.Basis.XAxis * x +\n                 self.Basis.YAxis * y +\n                 self.Basis.ZAxis * z )\n</code></pre>"},{"location":"geometry/surfaces/euclidean/#torus","title":"Torus","text":"<p>A torus combines two coupled circular motions. Alternatively, it can be considered as the surface of revolution of a circle about a line in the same plane as the circle.</p>"},{"location":"geometry/surfaces/euclidean/#parametric_5","title":"Parametric","text":"<p>The parametric torus requires a basis <code>{ o, x, y, z }</code>, where <code>o</code> is the origin and <code>x</code>, <code>y</code> and <code>z</code> are orthonormal basis vectors, as well as the <code>major</code> and <code>minor</code> radii. The parameters <code>u</code> and <code>v</code> are both angles in <code>[0, 2\u03c0]</code> or <code>[-\u03c0, \u03c0]</code>.</p> <pre><code>class TorusParametric:\n    def __init__( self, basis, major, minor ):\n        self.Basis = basis\n        self.Major = major\n        self.Minor = minor\n\n    def Evaluate( self, u, v ):\n        su, cu = math.sin( u ), math.cos( u )\n        sv, cv = math.sin( v ), math.cos( v )\n\n        x = ( self.Major + self.Minor * cv ) * cu\n        y = ( self.Major + self.Minor * cv ) * su\n        z =                self.Minor * sv\n\n        return ( self.Basis.Origin +\n                 self.Basis.XAxis * x +\n                 self.Basis.YAxis * y +\n                 self.Basis.ZAxis * z )\n</code></pre>"},{"location":"geometry/vectors/","title":"The Geometry of Points and Vectors","text":"<p>The objective of this section is to cover basic concepts of computational geometry, namely working with 3D points and vectors, via the python programming language.</p>"},{"location":"geometry/vectors/#mathematical-representation","title":"Mathematical Representation","text":"<p>Points and vectors, as mathematical objects, are ordered collections of numbers: <code>[5, -2.5, 4/3, \u03c0, \u2026, e]</code>. The number of elements in the collection n determines the size or degrees of freedom or dimensions spanned by the vector. Some examples:  <code>1D: [5.0]</code>, <code>2D: [6.1, 9.54]</code>, <code>3D: [3, 2, 1]</code>, <code>4D: [1.2, 2.3, 3.4, 4.5]</code>. The numbers have no relationship with one another except the order they appear in the collection. They can appear multiple times in the same vector, unlike a set which is an unordered collection and each element can appear only once.</p> <p></p> <p></p>"},{"location":"geometry/vectors/#geometric-semantics","title":"Geometric Semantics","text":"<p>Points and vectors are both represented as ordered collections of numbers. However, they are semantically slightly different: A point represents a location in relationship to a reference frame while a vector represents a displacement. Points represent spatial location identities: a point is a unique location in space no other point shares unless it shares exactly the same coordinates. A vector is a more abstract concept that represents the direction of all parallel lines. There are rules that allow us to perform operations among these different types of objects. For the time being it is important to keep this subtle distinction in mind.</p> <p></p>"},{"location":"geometry/vectors/#computational-representation","title":"Computational Representation","text":"<p>There are several ways to represent points and vectors but the most commonly used in computing are:</p> <ol> <li>Using lists of numbers, such as <code>p = [1, 2, 3]</code> and <code>u = [4, 5, 6]</code>. The benefit of using lists is that they are more general, points and vectors have the same representation, and many python libraries, such as <code>numpy</code> and <code>pytorch</code>, follow this convention. The limitation of using lists is that performing operations with them is slightly less intuitive.</li> <li>Using objects, such as <code>p = Point3d( 1, 2, 3 )</code> and <code>u = Vector3d( 4, 5, 6 )</code>. The benefit of using objects is that the operations performed on points and vectors are much more intuitive but on the other hand they are slower and require more memory.</li> </ol>"},{"location":"geometry/vectors/#python-representation","title":"Python Representation","text":"<p>Here we will use the object representation for all geometric entities exactly because it is easier to follow the geometric logic. Rhino's geometry library provides some fairly good definitions for points and vectors. To use those pre-fabricated data types, importing the relevant libraries is required as seen below</p> <pre><code>from Rhino.Geometry import Point3d, Vector3d\n\n\"\"\" Constructing a new point by coordinates\n\"\"\"\npnt = Point3d( 1, 2, 3 )\n\n\"\"\" Constructing a new vector by components\n\"\"\"\nvec = Vector3d( 4, 5, 6 )\n</code></pre> <p>Getting and setting point coordinates and vector components may be performed using their <code>X</code>, <code>Y</code> and <code>Z</code> members using the dot notation as seen below.</p> <pre><code>pnt.X = 3.1415  ''' Setting the X-coordinate '''\nprint( pnt.X )  ''' Getting and printing the X-coordinate '''\n\nvec.Y = 0.0     ''' Setting the Y-component to zero '''\nvec.Z = vec.X   ''' Getting the X-component and setting it to the Z-component '''\n</code></pre>"},{"location":"geometry/vectors/#world-coordinate-system","title":"World Coordinate System","text":"<p>In 3D space there are three special unit vectors, also known as basis vectors or world axes, <code>X = [1.0, 0.0, 0.0]</code>, <code>Y = [0.0, 1.0, 0.0]</code> and <code>Z = [0.0, 0.0, 1.0]</code>, which encode the three independent directions that span the space.</p> <pre><code>o =  Point3d( 0.0, 0.0, 0.0 )\nO = Vector3d( 0.0, 0.0, 0.0 )\nX = Vector3d( 1.0, 0.0, 0.0 )\nY = Vector3d( 0.0, 1.0, 0.0 )\nZ = Vector3d( 0.0, 0.0, 1.0 )\n</code></pre> <p>In Rhino the world's origin is defined as static members of the <code>Point3d</code> class and the world's axes in the <code>Vector3d</code> class, as seen below.</p> <pre><code>o =  Point3d.Origin\nO = Vector3d.Zero\nX = Vector3d.XAxis\nY = Vector3d.YAxis\nZ = Vector3d.ZAxis\n</code></pre>"},{"location":"geometry/vectors/#data-type-conversion","title":"Data Type Conversion","text":"<p><code>Point3d</code> and <code>Vector3d</code> cannot be used interchangeably without conversion. Even though both provide access to the same internal attributes, namely their <code>X</code>, <code>Y</code>, and <code>Z</code> components, they are different types.</p> <pre><code>\"\"\" Conversions\n\"\"\"\np =  Point3d( vec )  ''' Vector3d to Point3d '''\nu = Vector3d( pnt )  ''' Point3d to Vector3d '''\n</code></pre>"},{"location":"geometry/vectors/#approximate-equality","title":"Approximate Equality","text":"<p>The data type used for encoding the <code>X</code>, <code>Y</code> and <code>Z</code> point coordinates and vector components are floating point numbers which are approximations of real numbers in the sense that floats have only finite precision, see documentation. The limited precision of floats complicates comparing points and vectors. Comparing point and vector objects using the equality operator is not in generally appropriate.</p> <pre><code>\"\"\" Not Recommended!\n\"\"\"\nif( p == q ):\n    print( 'The points are equal !?' )\n</code></pre> <p>This is because floats <code>x</code> and <code>y</code> cannot be compared like <code>x == y</code> in the mathematical sense. Instead the approximate equality expressed as <code>-e \u2264 x - y \u2264 e</code> or more concisely as <code>| x - y | \u2264 e</code>, where <code>e</code> is a small value near zero such as <code>1e-5</code>, also known as epsilon, error or tolerance, must be used. This concept can be extended to points and vectors as seen below.</p> <p><pre><code>\"\"\" Coordinate / Component-wise Equality\n\"\"\"\nif( ( abs( p.X - q.X ) &lt;= 1e-5 ) and\n    ( abs( p.Y - q.Y ) &lt;= 1e-5 ) and\n    ( abs( p.Z - q.Z ) &lt;= 1e-5 ) ):\n    print( 'p and q are approximately equal' )\n</code></pre> However, it is also possible and actually more common to use the Euclidean distance and length as a measure for approximate equality.</p> <pre><code>\"\"\" Distance near Zero (slow)\n\"\"\"\nif( math.sqrt( ( p.X - q.X ) ** 2 +\n               ( p.Y - q.Y ) ** 2 +\n               ( p.Z - q.Z ) ** 2 ) &lt;= 1e-5 ):\n    print( 'p and q are approximately equal' )\n\n\"\"\" Distance Squared near Zero (fast)\n\"\"\"\nif( ( ( p.X - q.X ) ** 2 +\n      ( p.Y - q.Y ) ** 2 +\n      ( p.Z - q.Z ) ** 2 ) &lt;= 1e-10 ):\n    print( 'p and q are approximately equal' )\n</code></pre> <p>Note that geometrically the coordinate test checks whether a point is inside a tiny square, whereas the distance test, checks whether a point is within a tiny circle.</p>"},{"location":"geometry/vectors/addition/","title":"Points and Vectors Addition","text":"<p>Point and vector addition has the same properties as regular real numbers. It is performed element-wise for each of the <code>X</code>, <code>Y</code> and <code>Z</code> coordinates / components. Specifically, suppose the following two points and vectors are defined:</p> <pre><code>p = Point3d( px, py, pz )\nq = Point3d( qx, qy, qz )\n\nu = Vector3d( ux, uy, uz )\nv = Vector3d( vx, vy, vz )\n</code></pre> <p>The results of adding those respectively are seen below. Note that Rhino's geometry library support natively the addition of points and vectors using the <code>+</code> operator.</p> <p></p> <pre><code>\"\"\" Addition\n\"\"\"\no =  Point3d( px + qx,\n              py + qy,\n              pz + qz )\nw = Vector3d( ux + vx,\n              uy + vy,\n              uz + vz )\n\"\"\" Shortcut\n\"\"\"\no = p + q\nw = u + v\n</code></pre>"},{"location":"geometry/vectors/addition/#algebraic-properties","title":"Algebraic Properties","text":"<ol> <li> <p>Point and vector addition is commutative in the sense that it doesn\u2019t matter in which order vectors are added. It is thus symmetric in the sense <code>p + q = q + p</code> and <code>u + v = v + u</code>.</p> </li> <li> <p>Addition is also associative in that the terms can be grouped in different ways with the same result: <code>( p + q ) + o = p + ( q + o )</code> and <code>( u + v ) + w = u + ( v + w )</code>.</p> </li> <li> <p>There exists a special identity point and vector, namely <code>[0.0, 0.0, 0.0]</code> that produces no effect under addition. For points this is also known as the origin and for vectors as the zero or null vector.</p> </li> </ol>"},{"location":"geometry/vectors/addition/#geometric-interpretation","title":"Geometric Interpretation","text":"<p>The semantics of point and vector addition are associated with the geometric transformation of translation and compounding displacements, respectively.</p>"},{"location":"geometry/vectors/addition/#point-translation","title":"Point Translation","text":"<p>Adding a point and a vector can be considered as the act of moving the point by the displacement encoded in the vector.</p> <p></p>"},{"location":"geometry/vectors/addition/#compounding-vectors","title":"Compounding Vectors","text":"<p>Summing two of more vectors can be considered as computing the combined motion along multiple directions. Note that both the direction and the length of the resulting vector change. Additionally, from the figure below it is easy to see that the order of performing addition does not matter.</p> <p></p>"},{"location":"geometry/vectors/addition/#peculiar-cases","title":"Peculiar Cases","text":"<p>Adding two or more points is not as conceptually straight forward, unless we interpret points as vector from some origin. For instance consider points <code>p = [px, py, pz]</code> and <code>q = [qx, qy, qz]</code>. We can consider the points <code>p</code> and <code>q</code> as vectors from an origin <code>o = [0.0, 0.0, 0.0]</code>, as <code>u = [px - 0.0, py - 0.0, pz - 0.0]</code> and <code>v = [qx - 0.0, qy - 0.0, qz - 0.0]</code>. Adding the two vectors produces <code>u + v = [px + qx, py + qy, pz + qz]</code>. Now we reverse the points are vectors from an origin logic to conclude that <code>p + q = u + v</code>.</p> <p></p>"},{"location":"geometry/vectors/addition/#type-conversion","title":"Type Conversion","text":"<p>The following rules of automatic type conversion are enforced by Rhino when mixing points and vectors. Interestingly, the type conversion is not symmetric but instead prioritizes points. The reason for this is because point and vector addition, independent of the order is logically associated with translation. The summation of points can be considered as a process of compounding their coordinates. This by itself makes little sense, but if we consider that points can be understood as vectors from from an implied origin at <code>[0.0, 0.0, 0.0]</code> then it is equivalent of computing the aggregate displacement.</p> Type A + Type B = Type A + B Interpretation Point3d + Point3d = Point3d  Compounding Point3d + Vector3d = Point3d  Translation Vector3d + Point3d = Point3d  Translation Vector3d + Vector3d = Vector3d  Compounding"},{"location":"geometry/vectors/cross-product/","title":"Vector Cross Product","text":"<p>The cross product between two vectors produces a new vector which is perpendicular to both. The concept of the cross product for points is only meaningful if we interpret the points as vectors from the origin. Specifically, suppose the following two vectors are defined:</p> <pre><code>u = Vector3d( ux, uy, uz )\nv = Vector3d( vx, vy, vz )\n</code></pre> <p>The result of multiplying those is seen below.</p> <p></p> <pre><code>\"\"\" General\n\"\"\"\nn = Vector3d(\n    u.Y * v.Z - u.Z * v.Y,\n    u.Z * v.X - u.X * v.Z,\n    u.X * v.Y - u.Y * v.X )\n\n\"\"\" Rhino\n\"\"\"\nn = Vector3d.CrossProduct( u, v )\n</code></pre>"},{"location":"geometry/vectors/cross-product/#algebraic-properties","title":"Algebraic Properties","text":"<ol> <li> <p>The cross product is not commutative:  <code>u \u00d7 v \u2260 v \u00d7 u</code>. It is anticommutative in the sense that the direction of the result is flipped <code>u \u00d7 v = -( v \u00d7 u )</code>.</p> </li> <li> <p>The cross product is not associative: <code>( u \u00d7 v ) \u00d7 w \u2260 u \u00d7 ( v \u00d7 w )</code>. We cannot regroup the terms arbitrarily and expect the same result.</p> </li> <li> <p>The cross product is also defined as: <code>u \u00d7 v = |u| * |v| * sin( a ) * n</code>, where <code>|u|</code> and <code>|v|</code> are the lengths of the vectors, <code>a</code> is the angle between the vectors and <code>n</code> is a unit-length vector perpendicular to both <code>u</code> and <code>v</code>.</p> </li> <li> <p>The cross product of a vector <code>u</code> with itself <code>u \u00d7 u</code> is equal to the null vector <code>O = [0.0, 0.0, 0.0]</code> because <code>u \u00d7 u = |u| * |u| * sin( 0 ) * n = O</code></p> </li> </ol>"},{"location":"geometry/vectors/cross-product/#geometric-interpretation","title":"Geometric Interpretation","text":"<p>The cross product, like the dot product, is extremely rich geometrically. It is broadly associated with the notion of projection in the sense of \"raising\" perpendiculars as opposed to \"dropping\" which is associated with the dot product.</p>"},{"location":"geometry/vectors/cross-product/#measuring-areas","title":"Measuring Areas","text":"<p>The units of the cross product's magnitude are in square meters because the length of vectors are in meters and the sine has no units. We can reach the same conclusion from the alternative definition. However, unlike the dot product, which has no direct intuitive meaning, the cross product's length measures the area spanned by the two vectors.</p> <p></p> <pre><code>\"\"\" Inputs\n\"\"\"\nu = Vector3d( ux, uy, uz )\nv = Vector3d( vx, vy, vz )\n\n\"\"\" Outputs\n\"\"\"\nA = Vector3d.CrossProduct( u, v ).Length\n</code></pre>"},{"location":"geometry/vectors/cross-product/#projected-length","title":"Projected Length","text":"<p>When one of the two vectors <code>u</code> and <code>v</code> in a cross product is unit length, say <code>|u| = 1</code>, then the length of the result <code>|u \u00d7 v|</code> conveys a notion of projected length in the same sense as was with the dot product. Notice that from basic trigonometry <code>sin( a ) = opposite / hypotenuse</code>, that is the sine of angle equals the length of the opposite side of a right triangle, divided by the length of its hypotenuse. With a few transformations, as seen below, we can conclude that the length of a cross product encodes the length of the opposite side.</p> <p></p>"},{"location":"geometry/vectors/cross-product/#vector-analysis","title":"Vector Analysis","text":"<p>We can take this further by computing the triple or also known as the sandwich product between two vectors <code>u \u00d7 v \u00d7 u</code>. By doing so, we can construct a vector which encodes the projected length of the opposite side, back into the plane spanned by <code>u</code> and <code>v</code>. We can interpret the triple product operation as a transformation which transfers lengths among orthogonal directions, as long as one of the vectors, here <code>|u| = 1</code>, is unit-length. And with that, we have developed the tools to analyze a vector <code>v</code> into two orthogonal directions, where the horizontal component is given by the <code>u \u00b7 v \u00b7 u</code> and the vertical by <code>u \u00d7 v \u00d7 u</code>.</p> <p></p> <p>While the dot and cross product sandwich pair is interesting, the cross product is technically not required to perform vector analysis. The dot product suffices because the orthogonal component can be computed as <code>v - u \u00b7 v \u00b7 u</code>. Using only addition and multiplication to orthonormalize vectors is also known as the Gram-Schmidt method.</p>"},{"location":"geometry/vectors/cross-product/#matching-directions","title":"Matching Directions","text":"<p>The cross product of two vectors <code>u</code> and <code>v</code> with zero length result <code>|u \u00d7 v| = 0</code>, implies that the vectors are parallel. This is independent of their magnitude, that is we do not have to normalize the vectors. It is also the case when the two vectors have exactly the same or opposite direction.</p> <p>This property can be used for checking for exact (mis)alignment between vectors, but again the dot product is a better option because we don't need to construct new vectors and because we can distinguish between the two cases of same/opposite direction.</p> <p></p> <pre><code>\"\"\" Inputs\n\"\"\"\nu = Vector3d( ux, uy, uz )\nv = Vector3d( vx, vy, vz )\n\n\"\"\" Outputs\n\"\"\"\nif( Vector3d.CrossProduct( u, v ).Length &lt;= 1e-5 ):\n    print( 'The vectors are parallel' )\n</code></pre>"},{"location":"geometry/vectors/cross-product/#perpendicular-directions","title":"Perpendicular Directions","text":"<p>From the trigonometric definition, two unit vectors <code>u</code> and <code>v</code> with a cross product of <code>|u \u00d7 v| = 1</code>, implies that the vectors are perpendicular to one another, because <code>sin( \u00b1\u03c0/2 ) = \u00b11</code>. Note that because the length of a vector is always positive the sign of the sine is suppressed.</p> <p>Therefore, to test whether two vectors are perpendicular we can use the cross product and check if its length is exactly or near one. However, the same test can be performed more efficiently using the dot product because it involves fewer operations.</p> <p></p> <pre><code>\"\"\" Inputs\n\"\"\"\nu = Vector3d( ux, uy, uz )\nv = Vector3d( vx, vy, vz )\n\n\"\"\" Outputs\n\"\"\"\nif( ( 1.0 - Vector3d.CrossProduct(\n        u / u.Length, v / v.Length ).Length ) &lt;= 1e-5 ):\n    print( 'The vectors are perpendicular' )\n</code></pre>"},{"location":"geometry/vectors/cross-product/#computing-angles","title":"Computing Angles","text":"<p>When both vectors have unit length <code>|u| = 1</code> and <code>|v| = 1</code>, the cross product can be used for measuring the angle between the vectors <code>a = arcsin( |u \u00d7 v| )</code>. In this case also, the dot product provides a more efficient approach to computing angles between vectors.</p> <p></p> <pre><code>\"\"\" Inputs\n\"\"\"\nu = Vector3d( ux, uy, uz )\nv = Vector3d( vx, vy, vz )\n\n\"\"\" Outputs\n\"\"\"\na = math.asin( Vector3d.CrossProduct(\n    u / u.Length, v / v.Length ).Length )\n</code></pre>"},{"location":"geometry/vectors/cross-product/#coordinate-systems","title":"Coordinate Systems","text":"<p>With two non-parallel vectors <code>u</code> and <code>v</code> we can address every possible point in the 2D plane by using their linear combinations <code>u * s + v * t</code>, where <code>s</code> and <code>t</code> are real numbers. We can construct a coordinate system that spans the entire 3D space by computing the normal direction <code>n = u \u00d7 v</code> and addressing every possible point using <code>u * s + v * t + n * r</code>, where <code>r</code> is also a real number.</p> <p></p> <pre><code>\"\"\" Inputs\n\"\"\"\nu = Vector3d( ux, uy, uz )\nv = Vector3d( vx, vy, vz )\n\n\"\"\" Outputs\n\"\"\"\nn = Vector3d.CrossProduct( u, v )\n</code></pre>"},{"location":"geometry/vectors/cross-product/#orthogonal-bases","title":"Orthogonal Bases","text":"<p>Suppose we have two non-parallel but also non-orthogonal vectors <code>u</code> and <code>w</code> and we wish to construct a pair of orthogonal vectors that span the same plane. We can achieve this by applying the cross products twice.</p> <p>First we compute the normal vector <code>n = u \u00d7 w</code> which is orthogonal to both <code>u</code> and <code>w</code> by definition. Then we need to choose one of the <code>u</code> and <code>w</code> vectors, for instance <code>u</code>, before performing the second cross product <code>v = n \u00d7 u</code> with the normal. The new vector <code>v</code> will be orthogonal to both the <code>u</code> and <code>n</code>. But notice that any vector which is orthogonal to a plane's normal <code>n</code> is within the plane by definition. Therefore, the pair <code>( u, v )</code> form an orthogonal basis.</p> <p></p> <pre><code>\"\"\" Inputs\n\"\"\"\nu = Vector3d( ux, uy, uz )\nv = Vector3d( vx, vy, vz )\n\n\"\"\" Outputs\n\"\"\"\nn = Vector3d.CrossProduct( u, w )\nv = Vector3d.CrossProduct( n, u )\n</code></pre> <p>In general, we can form two distinct bases namely <code>( u, u \u00d7 w \u00d7 u )</code> and <code>( w, w \u00d7 u \u00d7 w )</code>. It is just a matter of which of the original two vectors we wish to keep unchanged. In shorthand notation this can be computed as follows:</p> <pre><code>\"\"\" Outputs\n\"\"\"\nv = Vector3d.CrossProduct( Vector3d.CrossProduct( u, w ), u )\n\"\"\" or \"\"\"\nv = Vector3d.CrossProduct( Vector3d.CrossProduct( w, u ), w )\n</code></pre> <p>By extension, if we have two non-parallel vectors <code>u</code> and <code>w</code>, which may or not be orthogonal, and we wish to form a coordinate basis with three mutually orthogonal vectors we apply the same logic and obtain <code>( u, v, n )</code> by computing <code>( u, u \u00d7 w \u00d7 u, u \u00d7 w )</code>.</p> <p>Typically, after constructing such 2D or 3D basis vectors we often normalize them to unit-length; a process is also known as orthonormalization.</p>"},{"location":"geometry/vectors/cross-product/#unary-cross-product","title":"Unary Cross Product","text":"<p>Suppose we have only one vector <code>u</code> and we wish to compute another vector <code>v</code> such that they are orthogonal to one another. What we need is an auxiliary vector <code>w</code> such that we can use the cross product to compute <code>v = u \u00d7 w</code>. Note that <code>w</code> can be really any random vector because eventually the cross product will ensure that <code>u \u00b7 v = 0</code>. The only problem that can occur is choosing a <code>w</code> that is parallel, or near parallel, to <code>u</code> which will cause <code>v = u \u00d7 w = 0</code>.</p> <p></p> <p>Geometrically, we need to select a vector such that the angle between <code>u</code> and <code>w</code> is furthest away from <code>0</code> and <code>\u03c0</code>, or closest to <code>\u03c0/2</code>. The closer the absolute value of the dot product between two vectors is to zero <code>|u \u00b7 w| -&gt; 0</code>, the closer their angle is to <code>cos( a ) -&gt; \u03c0/2</code>.</p> <p></p> <p>We may thus use one of the world vectors, <code>X = [1, 0, 0]</code>, <code>Y = [0, 1, 0]</code> or <code>Z = [0, 0, 1]</code> for <code>w</code> based on which ever <code>|u \u00b7 X| = |u.X|</code>, <code>|u \u00b7 Y| = |u.Y|</code> and <code>|u \u00b7 Z| = |u.Z|</code> has the smallest value, as seen below. This geometric construction may be considered as a unary form of the cross product because we are supplying only one vector and obtain another one which is orthogonal.</p> <pre><code>def Vector3d_UnaryCrossProduct( u ):\n    if( abs( u.X ) &lt; abs( u.Y ) ):\n        if( abs( u.X ) &lt; abs( u.Z ) ):\n            w = Vector3d.XAxis\n        else:\n            w = Vector3d.ZAxis\n    else:\n        if( abs( u.Y ) &lt; abs( u.Z ) ):\n            w = Vector3d.YAxis\n        else:\n            w = Vector3d.ZAxis\n    return Vector3d.CrossProduct( u, w )\n</code></pre>"},{"location":"geometry/vectors/distances/","title":"Point Distances and Vector Lengths","text":""},{"location":"geometry/vectors/distances/#euclidean-norm","title":"Euclidean Norm","text":"<p>Measuring the distance between points and computing the length of vectors is most frequently based on the Euclidean notion of distance: the square root of the sum of squares. The Euclidean distance is also often referred to as the Euclidean or L2 norm. Specifically, suppose the following points and vector are defined:</p> <pre><code>p = Point3d( px, py, pz )\nq = Point3d( qx, qy, qz )\n\nu = Vector3d( q.X - p.X,\n              q.Y - p.Y,\n              q.Z - p.Z )\n</code></pre> <p>Computing distances and lengths is presented below. The distance between points <code>p</code> and <code>q</code> is often denoted as <code>|q - p|</code> and the vector's <code>u</code> length as <code>|u|</code>.</p> <p></p> <pre><code>\"\"\" Euclidean Point Distance\n\"\"\"\nd = math.sqrt( ( q.X - p.X ) ** 2 +\n               ( q.Y - p.Y ) ** 2 +\n               ( q.Z - p.Z ) ** 2 )\n\n\"\"\" Euclidean Vector Length\n\"\"\"\nd = math.sqrt(\n    u.X ** 2 +\n    u.Y ** 2 +\n    u.Z ** 2 )\n\n\"\"\" Shortcuts\n\"\"\"\nd = p.DistanceTo( q )\nd = u.Length\n</code></pre> <p>Note that the distance between two points <code>|p - q|</code> is equal to the length of the vector <code>u = q - p</code> defined by the same two points because <code>|u| = |q - p| = |p - q|</code>.</p> <p>Additionally, the Euclidean distance is symmetric <code>|p - q| = |q - p|</code> and <code>|u| = |-u|</code>, because squaring removes the directionality of the difference.</p>"},{"location":"geometry/vectors/distances/#manhattan-norm","title":"Manhattan Norm","text":"<p>The Manhattan or taxi driver or L1 norm is another form of distance / length measured as the sum of the absolute values of coordinates / components. It represents the sum of the motions from point <code>p</code> to <code>q</code> as if motion is only valid along an orthogonal grid.</p> <p></p> <pre><code>\"\"\" Manhattan Distance\n\"\"\"\nd = ( abs( q.X - p.X ) +\n      abs( q.Y - p.Y ) +\n      abs( q.Z - p.Z ) )\n\n\"\"\" Manhattan Length\n\"\"\"\nd = ( abs( u.X ) +\n      abs( u.Y ) +\n      abs( u.Z ) )\n</code></pre>"},{"location":"geometry/vectors/dot-product/","title":"Vector Dot Product","text":"<p>The dot product, also known as scalar product, between two vectors is defined as the sum-product of their components. The concept of the dot product for points is only meaningful if we interpret the points as vectors from the origin. Specifically, suppose the following two vectors are defined:</p> <pre><code>u = Vector3d( ux, uy, uz )\nv = Vector3d( vx, vy, vz )\n</code></pre> <p>The result of multiplying those is seen below.</p> <p></p> <pre><code>\"\"\" General\n\"\"\"\nd = ( u.X * v.X +\n      u.Y * v.Y +\n      u.Z * v.Z )\n\n\"\"\" Rhino\n\"\"\"\nd = u * v\n</code></pre>"},{"location":"geometry/vectors/dot-product/#algebraic-properties","title":"Algebraic Properties","text":"<ol> <li>The dot product is commutative:  <code>u \u00b7 v = v \u00b7 u</code>.</li> <li>The dot product is not associative: <code>( u \u00b7 v ) \u00b7 w \u2260 u \u00b7 ( v \u00b7 w )</code> (see note below).</li> <li>The dot product is also defined as: <code>u \u00b7 v = |u| * |v| * cos( a )</code>, where <code>|u|</code> and <code>|v|</code> are the lengths of the vectors and <code>a</code> is the angle between the vectors.</li> <li>The dot product of a vector <code>u</code> with itself <code>u \u00b7 u</code> is equal to its square length <code>|u|\u00b2</code>. This is because <code>u \u00b7 u = |u| * |u| * cos( 0 ) = |u|\u00b2</code></li> </ol> <p>Note</p> <p>The product <code>( u \u00b7 v ) \u00b7 w</code> is a vector in the direction of <code>w</code> and the product <code>u \u00b7 ( v \u00b7 w )</code> is a vector in the direction of <code>u</code>. But <code>w</code> and <code>u</code> may not have the same directions to begin with. Therefore, associativity falls apart.</p> <p>However, for <code>( u \u00b7 v ) \u00b7 u</code> it works because <code>u \u00b7 ( v \u00b7 u )</code> is the same scaled version of vector <code>u</code> by <code>u \u00b7 v = v \u00b7 u</code>. Nevertheless, it is incorrect to swap terms such as  <code>u \u00b7 v \u00b7 u != u \u00b7 u \u00b7 v != v \u00b7 u \u00b7 u</code>.</p>"},{"location":"geometry/vectors/dot-product/#geometric-interpretation","title":"Geometric Interpretation","text":"<p>The dot product is extremely rich geometrically. It is broadly associated with the notion of projection in the sense of \"dropping perpendiculars\" or going from 3D to 1D since the inputs are three-dimensional vectors and the output is just a single real number.</p>"},{"location":"geometry/vectors/dot-product/#dimensional-analysis","title":"Dimensional Analysis","text":"<p>The units of the dot product are in square meters because the length of vectors are in meters and the cosine has no units. We can reach the same conclusion using the sum-product definition because vector components express displacements in length units. This is counterintuitive but once either or both vectors are normalized, the dot product starts having more clear geometric meaning.</p> <p></p>"},{"location":"geometry/vectors/dot-product/#perpendicular-directions","title":"Perpendicular Directions","text":"<p>From the trigonometric definition of the dot product, zero dot product <code>u \u00b7 v = 0</code>, implies that the vectors are perpendicular to one another, because <code>cos( \u00b1\u03c0/2 ) = 0</code>. Therefore, to test whether two vectors are perpendicular, independent of their length, we can take the dot product and check if it is exactly or near zero.</p> <p></p>"},{"location":"geometry/vectors/dot-product/#matching-directions","title":"Matching Directions","text":"<p>The dot product can be a positive or negative number, since <code>-1.0 \u2264 cos( a ) \u2264 1.0</code>. Geometrically, two vectors have exactly the same direction when their dot product is <code>1.0</code> and exactly the opposite direction in the case of <code>-1.0</code>. This property can be used for checking for exact (mis)alignment between vectors.</p> <p></p>"},{"location":"geometry/vectors/dot-product/#measuring-alignment","title":"Measuring Alignment","text":"<p>In a fuzzy sense, two vectors have the same-ish direction when their dot product is positive <code>u \u00b7 v &gt; 0</code> and against one another when <code>u \u00b7 v &lt; 0</code>. The dot product can be used as a measure of alignment in this sense. If both vectors have unit length <code>|u| = 1</code> and <code>|v| = 1</code> then the dot product provides a unit-less value <code>-1 \u2264 u \u00b7 v \u2264 1</code> which measures similarity or corelation, also known as cosine similarity.</p> <p></p>"},{"location":"geometry/vectors/dot-product/#computing-angles","title":"Computing Angles","text":"<p>When both vectors have unit length <code>|u| = 1</code> and <code>|v| = 1</code>, the dot product provides the angle between the vectors <code>a = arccos( u \u00b7 v )</code>. Therefore, given two known vectors, to compute the angle between them, we first need to compute their lengths, or normalize them, and then take inverse cosine of their dot product.</p> <p></p>"},{"location":"geometry/vectors/dot-product/#projected-length","title":"Projected Length","text":"<p>When one of the two vectors is unit-length, say <code>|\u00fb| = 1</code>, then the dot product is the projected length of vector <code>v</code> onto <code>\u00fb</code>. Notice that <code>\u00fb \u00b7 v = 1.0 * |v| * cos( a )</code>. Therefore, <code>cos( a ) = ( \u00fb \u00b7 v ) / |v|</code>. By the definition of the cosine <code>cos = adj / hyp</code> and thus <code>\u00fb \u00b7 v = adj</code>. This operation is extremely useful for geometric constructions and vector analysis.</p> <p>Note that the dot product may be either a positive or a negative number, while distances are by definition only positive. Thus the projected distance produced by the dot product is also known as the signed distance. The sign just represents whether the distance is towards the vector or against it. Therefore, the projection work either when the two vectors point towards the same or opposite directions.</p> <p></p>"},{"location":"geometry/vectors/dot-product/#type-conversion","title":"Type Conversion","text":"<p>In Rhino only the dot product between vectors is supported using the regular multiplication operator. Multiplying points results in exceptions. This behavior can be bypassed, if needed, by first casting points to vectors.</p> Type A * Type B = Type A - B Interpretation Point3d * Point3d = None  Exception! Vector3d * Vector3d = float  Dot Product"},{"location":"geometry/vectors/multiplication/","title":"Points and Vectors Multiplication","text":"<p>Multiplication of points and vectors is more complicated than regular real numbers. There are three distinct definitions. This section start with the simplest kind, namely point or vector times number. It is performed element-wise for each of the <code>X</code>, <code>Y</code> and <code>Z</code> coordinates / components. Specifically, suppose the following point, vector and real number are defined:</p> <pre><code>p =  Point3d( px, py, pz )\nu = Vector3d( ux, uy, uz )\ns = float( num )\n</code></pre> <p>The result of multiplying those respectively are seen below for different values of <code>s</code>. Note that Rhino supports point and vector multiplication with real numbers using the <code>*</code> operator.</p> <p></p> <pre><code>\"\"\" Multiplication\n\"\"\"\nq =  Point3d( px * s, py * s, pz * s )\nv = Vector3d( ux * s, uy * s, uz * s )\n\n\"\"\" Shortcut\n\"\"\"\nq = p * s\nv = u * s\n</code></pre>"},{"location":"geometry/vectors/multiplication/#algebraic-properties","title":"Algebraic Properties","text":"<ol> <li> <p>Point and vector multiplication with scalars is commutative in the sense that it doesn't matter in which order vectors are multiplied <code>p * s = s * p</code> and <code>u * s = s * u</code>.</p> </li> <li> <p>Multiplication is associative, as the terms can be grouped in different ways with the same result: <code>( p * s ) * s = p * ( s * s )</code> and <code>( u * s ) * s = u * ( s * s )</code>.</p> </li> <li> <p>There exists a special multiplicative identity value, namely <code>1.0</code> that produces no effect under multiplication.</p> </li> </ol>"},{"location":"geometry/vectors/multiplication/#geometric-interpretation","title":"Geometric Interpretation","text":"<p>The semantics of point and vector multiplication with numbers are associated with the geometric transformation of uniform scaling.</p>"},{"location":"geometry/vectors/multiplication/#scaling-points","title":"Scaling Points","text":"<p>In CAD systems, scaling geometry is performed about a user-selected origin and a scaling factor. Multiplying points with scalars has the same effects as CAD scaling using the origin <code>[0.0, 0.0, 0.0]</code> as the selected reference point. To emulate CAD's scaling behavior for a point <code>p</code> about an origin <code>o</code> with a scaling factor <code>s</code>, we first  compute the intermediate point <code>q = p - o</code>. This is equivalent to moving the geometry, represented by the point <code>p</code>, to the standard CAD origin <code>[0.0, 0.0, 0.0]</code>. Now can apply the scaling operation <code>q * s</code>, and finally move back the result <code>q * s + o</code>. We thus in total performed the following operation: <code>( p - o ) * s + o</code>.</p> <p></p> <pre><code>\"\"\" Inputs\n\"\"\"\npoint  = Point3d( 1, 2, 3 )\norigin = Point3d( 0, 1, 0 )\nfactor = 2.0\n\n\"\"\" Outputs\n\"\"\"\nscaled = ( point - origin ) * factor + origin\n</code></pre>"},{"location":"geometry/vectors/multiplication/#scaling-vectors","title":"Scaling Vectors","text":"<p>The concept of vector times scalar multiplication <code>u * s</code> is associated changing the vector's length. Conceptually we are stretching or shrinking the vector but we do not change its direction.</p> <pre><code>\"\"\" Inputs\n\"\"\"\nu = Vector3d( 1, 2, 3 )\n\n\"\"\" Outputs\n\"\"\"\nv = u * 0.5 ''' Half size   '''\nv = u * 2.0 ''' Double size '''\n</code></pre>"},{"location":"geometry/vectors/multiplication/#flipping-vectors","title":"Flipping Vectors","text":"<p>Multiplying a vector with <code>-1</code> results into a new vector with the same magnitude but exactly the opposite direction. Therefore, negating vectors is equivalent to flipping their direction.</p> <pre><code>\"\"\" Inputs\n\"\"\"\nO = Vector3d( 0, 0, 0 )\nu = Vector3d( 1, 2, 3 )\n\n\"\"\" Operators\n\"\"\"\nv = u * -1   ''' Multiplication '''\nv = O - u    ''' Subtraction    '''\nv = -u       ''' Negation       '''\n</code></pre> <p>Vectors can be flipped using the <code>Reverse( )</code> method provided by Rhino's geometry implementation as seen below. Note that the operation is performed in-place, that is the vector object is modified internally.</p> <pre><code>\"\"\" Rhino\n\"\"\"\nu.Reverse( )\n</code></pre>"},{"location":"geometry/vectors/multiplication/#type-conversion","title":"Type Conversion","text":"<p>The rhino / grasshopper library supports point and vector by scalar multiplication using the standard notation. Note that the implementation support this symmetrically.</p> Type A * Type B = Type A - B Interpretation Point3d * float = Point3d  Scaling float * Point3d = Point3d  Scaling Vector3d * float = Vector3d  Scaling float * Vector3d = Vector3d  Scaling"},{"location":"geometry/vectors/multiplication/#division-with-scalars","title":"Division with Scalars","text":"<p>Division of points and vectors by real numbers is also defined as an extension to multiplication. It is equivalent of taking the reciprocal of the scalar and performing the multiplication as seen above <code>p / s = p * ( 1 / s )</code> and <code>u / s = u * ( 1 / s )</code>.</p> <p>However, the scalar can only appear in the right-hand side of the expression. This is a limitation of the library implementation.</p> Type A / Type B = Type A - B Interpretation Point3d / float = Point3d  Scaling float / Point3d = None  Exception! Vector3d / float = Vector3d  Scaling float / Vector3d = None  Exception!"},{"location":"geometry/vectors/normalize/","title":"Vector Normalization","text":"<p>The objective of normalizing or unitizing vectors is to retain the same direction but adjust their magnitude to unit length. It is performed by dividing vectors, in the scaling sense, by their length. Therefore, for a vector <code>u</code> with length <code>|u|</code>, its normalized direction is <code>v = u / |u|</code>. Computing the length of <code>|v|</code> shows that <code>|u / |u||</code> equals <code>|u| / |u|</code> or just <code>1.0</code>. Unit-length vectors are sometimes denoted with a caret/hat <code>^</code> symbol over the letter such as <code>\u00fb</code>. However, since it is difficult to use these symbols in code they will be avoided.</p> <p></p>"},{"location":"geometry/vectors/normalize/#dimensional-analysis","title":"Dimensional Analysis","text":"<p>The components of a vector are expressed in linear units of length, such as meters. The process of dividing each with another length, which is also in the same units, in some sense cancels the units out. Therefore, unit vectors can be considered as pure or unit-less directions.</p>"},{"location":"geometry/vectors/normalize/#unsafe-computation","title":"Unsafe Computation","text":"<p>The code below creates a unit-length vector <code>v</code>, without modifying the original vector <code>u</code>. Note that if the vector has zero length, then we have a division by zero problem. So while the approach presented below makes mathematical sense, it is not appropriate for computing.</p> <pre><code>\"\"\" Normalize Vector Fast\n\"\"\"\ndef Normalize( u ):\n      length = math.sqrt(\n            u.X ** 2 +\n            u.Y ** 2 +\n            u.Z ** 2 )\n      \"\"\" length ?= 0.0\n      \"\"\"\n      return u / length\n\nu = Vector3d( 1, 1, 1 )\nv = Normalize( u )\n</code></pre>"},{"location":"geometry/vectors/normalize/#safe-computation","title":"Safe Computation","text":"<p>A convention often used for safe normalization of vectors returns the zero vector if the length is zero. However, this approach is also without problems because when the vector's length is near zero the division is also unstable.</p> <pre><code>\"\"\" Normalize Vector Safe\n\"\"\"\ndef Normalize( u ):\n      length = u.Length\n      if( length == 0.0 ):\n            return Vector3d.Zero\n      return u / length\n\nu = Vector3d( 1, 1, 1 )\nv = Normalize( u )\n</code></pre>"},{"location":"geometry/vectors/normalize/#decomposition","title":"Decomposition","text":"<p>Sometimes it is useful to normalize a vector but also retain the computed length for subsequent computation. The implementation below returns both a new unit-length vector as well as the original vector's length.</p> <pre><code>\"\"\" Decompose Vector\n\"\"\"\ndef Decompose( u ):\n      length = u.Length\n      if( length == 0.0 ):\n            return ( Vector3d.Zero, length )\n      return ( u / length, length )\n\nu = Vector3d( 1, 1, 1 )\ndirection, length = Decompose( u )\n</code></pre>"},{"location":"geometry/vectors/normalize/#unitize-normalize","title":"Unitize / Normalize","text":"<p>Rhino's equivalent is seen below. The <code>Unitize( )</code> method normalizes the vector and returns a boolean success / failure value depending on whether the vector has non-zero length or otherwise.</p> <pre><code>\"\"\" Normalize In-Place\n\"\"\"\nv = Vector3d( 1, 2, 3 )\nsuccess = v.Unitize( )\n</code></pre> <p>Note that the <code>Unitize( )</code> method modifies the vector itself rather than creating a new normalized vector. The method <code>Normalize( )</code> demonstrates how to normalize a vector and return a new copy without modifying the original.</p> <pre><code>\"\"\" Normalize New Copy\n\"\"\"\ndef Normalize( u ):\n      v = Vector3d( u )\n      v.Unitize( )\n      return v\n</code></pre>"},{"location":"geometry/vectors/subtraction/","title":"Points and Vectors Subtraction","text":"<p>Point and vector subtraction has the same properties as regular real numbers. It is performed element-wise for each of the <code>X</code>, <code>Y</code> and <code>Z</code> coordinates / components. Specifically, suppose the following two points and vectors are defined:</p> <pre><code>p = Point3d( px, py, pz )\nq = Point3d( qx, qy, qz )\n\nu = Vector3d( ux, uy, uz )\nv = Vector3d( vx, vy, vz )\n</code></pre> <p>The results of subtracting those respectively are seen below. Note that the standard Rhino library support natively the addition of points and vectors. However, because it is targeting geometric use, the resulting types may be unexpected.</p> <p></p> <pre><code>\"\"\" Subtraction\n\"\"\"\no = Vector3d( p.X - q.X,\n              p.Y - q.Y,\n              p.Z - q.Z )\n\nw = Vector3d( u.X - v.X,\n              u.Y - v.Y,\n              u.Z - v.Z )\n\"\"\" Shortcut\n\"\"\"\nw = u - v\no = p - q\n</code></pre>"},{"location":"geometry/vectors/subtraction/#algebraic-properties","title":"Algebraic Properties","text":"<ol> <li> <p>Point and vector subtraction is not commutative <code>p - q \u2260 q - p</code> and <code>u - v \u2260 v - u</code>. It is in fact anti-commutative because <code>p - q = -( q - p )</code> and <code>u - v = -( v - u )</code>. In other words the direction is flipped.</p> </li> <li> <p>Subtraction is associative in that the terms can be grouped in different ways with the same result: <code>( p + q ) - o = p + ( q - o )</code> and <code>( u + v ) - w = u + ( v - w )</code>.</p> </li> <li> <p>There exists a special vector, namely <code>O = [0.0, 0.0, 0.0]</code> that produces no effect under subtraction, also known as the zero vector.</p> </li> <li> <p>Subtracting the zero vector <code>O</code> from another vector <code>u =[ux, uy, uz]</code> results into a vector with opposite direction <code>O - u = -u = [-ux, -uy, -uz]</code>.</p> </li> </ol>"},{"location":"geometry/vectors/subtraction/#geometric-interpretation","title":"Geometric Interpretation","text":"<p>The semantics of point and vector subtraction are a bit more nuanced compared to addition. Subtraction encompasses the notions of constructing vectors from points, translating points by vectors, and compounding vectors with one having its direction flipped.</p>"},{"location":"geometry/vectors/subtraction/#constructing-vectors","title":"Constructing Vectors","text":"<p>Subtraction between points implies the construction of a vector which contains the relative displacement between the two locations. The vector <code>target - source</code> is sometimes visually represented with an arrow starting from point <code>source</code> and ending at point <code>target</code>. Note that the way we express the displacement <code>source</code> \u2192 <code>target</code> is the flipped in the subtraction <code>target - source</code>.</p> <p></p>"},{"location":"geometry/vectors/subtraction/#translating-points","title":"Translating Points","text":"<p>Subtraction between a point <code>p</code> and a vector <code>u</code> is associated with translating the point towards the opposite direction of the vector <code>p - u = p + ( -u )</code>.</p> <p></p>"},{"location":"geometry/vectors/subtraction/#vector-algebra","title":"Vector Algebra","text":"<p>Subtracting vectors conveys the notion of computing an aggregate direction. Subtraction between vectors can be expressed in the same sense as addition but with the second operand's direction flipped.</p>"},{"location":"geometry/vectors/subtraction/#peculiar-case","title":"Peculiar Case","text":"<p>Subtracting a point from a vector is geometrically awkward. It may be interpreted as regular vector subtraction, if the point is considered as a vector from the origin.</p>"},{"location":"geometry/vectors/subtraction/#type-conversion","title":"Type Conversion","text":"<p>Rhino's geometry library supports point and vector subtraction using the same operator as for numbers. However, it throws an exception for the ambiguous case, perhaps to demotivate its use. This can be bypassed by casting the point into a vector before subtracting.</p> Type A - Type B = Type A - B Interpretation Point3d - Point3d = Vector3d  Construction Point3d - Vector3d = Point3d  Translation Vector3d - Point3d = None  Exception! Vector3d - Vector3d = Vector3d  Compounding"},{"location":"geometry/vectors/systems/","title":"Bases and Planes","text":"<p>Coordinate systems, also known as bases or reference frames, provide a way to look at the same geometry from different perspectives. The reason for doing so is because certain operations are easier to approach from a local versus a global or world perspective. For example, in purely 2D problems it is easier to work in the XY-plane than any arbitrarily oriented plane in 3D. If we solve the problem in the XY-plane then all problems are solved in space up to a transformation from the XY to any other plane.</p> <p></p>"},{"location":"geometry/vectors/systems/#definition","title":"Definition","text":"<p>Defining a coordinate system requires an origin point <code>O</code> and as many non-parallel basis vectors as the number of dimensions spanned. For two dimensions, two vectors are required <code>X</code> and <code>Y</code>, for three <code>X</code>, <code>Y</code> and <code>Z</code> for three dimensions, etc. Generally, the basis vectors do not need to be unit-length and/or orthogonal with one another. However, when they do have these properties, their linear combinations, that is addition and multiplication of the basis vectors, do not cause directions to contribute onto one another. This simplifies many operations by avoiding the need to solve linear systems of equations.Therefore, it is most convenient to use coordinate systems with orthonormal basis vectors. Thus unless otherwise specified, all coordinate systems may be assumed as orthonormal.</p>"},{"location":"geometry/vectors/systems/#world-coordinates","title":"World Coordinates","text":"<p>Points by default, or unless otherwise specified, are always expressed in relationship to an implied <code>World</code> coordinate system defined by the origin point <code>O = [0.0, 0.0, 0.0]</code>, and the world axes <code>X = [1.0, 0.0, 0.0]</code>, <code>Y = [0.0, 1.0, 0.0]</code>, and <code>Z = [0.0, 0.0, 1.0]</code>.</p> <p></p> <pre><code>\"\"\" World Basis\n\"\"\"\nO =  Point3d( 0.0, 0.0, 0.0 )\nX = Vector3d( 1.0, 0.0, 0.0 )\nY = Vector3d( 0.0, 1.0, 0.0 )\nZ = Vector3d( 0.0, 0.0, 1.0 )\n</code></pre> <p>This <code>World</code> coordinate system is also known as the <code>global</code> or <code>ambient</code> space coordinate system. Sometimes the notation p<sup>w</sup> is used for clarifying that a point <code>p</code> is expressed with respect to the <code>World</code> frame.</p> <pre><code>\"\"\" World Basis\n\"\"\"\nO = Point3d.Origin\nX = Vector3d.XAxis\nY = Vector3d.YAxis\nZ = Vector3d.ZAxis\n</code></pre> <p>With this in mind, a point <code>p = [px, py, pz]</code> is just a shorthand notation for <code>p = O + X * px + Y * py + Z * pz</code> because <code>[0.0, 0.0, 0.0] + [px, 0.0, 0.0] + [0.0, py, 0.0] + [0.0, 0.0, pz] = [px, py, pz]</code>.</p> <pre><code>\"\"\" Equivalent\n\"\"\"\np = Point3d( 1.0, 2.0, 3.0 )\n\np = ( Point3d.Origin +\n      Vector3d.XAxis * p.X +\n      Vector3d.YAxis * p.Y +\n      Vector3d.ZAxis * p.Z )\n</code></pre> <p>In other words, the coordinates of a point express the sum of orthogonal motions from the origin by a multiple of its axes. In the same sense, the components of a vector <code>u = p - O</code> represent the combined motion <code>X * ux + Y * uy + Z * uz</code>.</p>"},{"location":"geometry/vectors/systems/#plane-as-3d-basis","title":"Plane as 3D Basis","text":"<p>A plane <code>P</code> in space defined by its origin <code>o = [ox, oy, oz]</code> and basis vectors <code>u = [ux, uy, uz]</code> and <code>v = [vx, vy, vz]</code>, where <code>|u| = |v| = 1</code> and <code>u \u00b7 v = 0</code>,  is somewhat equivalent to a coordinate system (1). This is because we can easily derive another orthogonal unit vector by using the cross product <code>n = u \u00d7 v</code> and form the basis <code>{ o, u, v, n }</code>.</p> <ol> <li>In fact we can define two coordinate systems depending on whether we use <code>n = u \u00d7 v</code> or <code>n = v \u00d7 u</code>. Swapping the cross product's order is equivalent to switching the handedness of the coordinate system.</li> </ol> <p></p> <p>In Rhino the concept of the 3D plane and coordinate system are equivalent. Constructing a <code>Plane</code> object from an origin and two basis 3D vectors is presented below.</p> <pre><code>\"\"\" Constructing a Plane\n\"\"\"\no =  Point3d( 0.0, 0.0, 0.0 )\nu = Vector3d( 1.0, 0.0, 0.0 )\nv = Vector3d( 0.0, 1.0, 0.0 )\n\nP = Plane( o, u, v )\n</code></pre> <p>Once a plane is constructed, its origin and basis vectors can be accessed as seen below. Note that Rhino automatically orthonormalizes the plane's axes. Therefore, <code>Plane( o, u, v )</code> is different than <code>Plane( o, v, u )</code>. <pre><code>\"\"\" Plane as Basis\n\"\"\"\no = P.Origin\nu = P.XAxis\nv = P.YAxis\nn = P.ZAxis\n</code></pre></p>"},{"location":"geometry/vectors/systems/#local-to-world","title":"Local to World","text":"<p>Suppose a plane is defined by <code>{ o, u, v }</code>, where <code>o</code> is its origin and <code>u</code>,  and <code>v</code> are its basis vectors. Furthermore, we have a local point <code>p = [px, py]</code> defined with respect to the plane. Its world coordinates can be computed by <code>o + u * px + v * py</code>. This transformation is also known as local-to-global or local-to-world change of reference. (1)</p> <ol> <li>Notice that this expression works even when the basis vectors are not orthonormal.</li> </ol> <pre><code>\"\"\" Local to World\n\"\"\"\nplane = Plane(  Point3d( ox, oy, oz ),\n               Vector3d( ux, uy, uz ),\n               Vector3d( vx, vy, vz ) )\n\nlocal = Point2d( px, py )\n\nworld = ( plane.Origin +\n          plane.XAxis * p.X +\n          plane.YAxis * p.Y )\n</code></pre> <p>The way to understand this by considering that the coordinates of a point, in reference to a basis, represent the distances required to move from the origin towards each axis. By extension, this can be used to map between points between coordinate systems.</p> <p></p> <pre><code>\"\"\" Local to World\n\"\"\"\nplane = Plane(  Point3d( ox, oy, oz ),\n               Vector3d( ux, uy, uz ),\n               Vector3d( vx, vy, vz ) )\n\nlocal = Point3d( px, py, pz )\n\nworld = ( plane.Origin +\n          plane.XAxis * p.X +\n          plane.YAxis * p.Y +\n          plane.ZAxis * p.Z )\n</code></pre>"},{"location":"geometry/vectors/systems/#world-to-local","title":"World to Local","text":"<p>Expressing world points in relationship with other frames is slightly more complicated. Recall that the coordinates of a point represent the motion from the origin of a reference coordinate system by multiples of its basis vectors. Therefore, what is needed is to compute the magnitude of those motions, one per axis.</p> <p>Suppose we have a plane defined by <code>{ o, u, v }</code>, where <code>o</code> is its origin and <code>u</code>,  and <code>v</code> are its basis vectors. Furthermore, we have a world point <code>p = [px, py, py]</code> for which we wish to find its local coordinates with respect to the plane <code>q = [qx, qy]</code>.</p> <p>First we define the vector <code>w = p - o</code> which encodes the translation from <code>o</code> to <code>p</code>, in the world sense. Then we compute its dot products with the plane's axes <code>u \u00b7 w</code> and <code>v \u00b7 w</code>. Note that the dot products capture the projected lengths we need to move about each axis. Which is what we looking for, namely <code>q = [u \u00b7 w, v \u00b7 w]</code> (1)</p> <ol> <li>Note that this expression does NOT works when the basis vectors are not orthonormal. Instead we need to establish and solve a system of linear equations.</li> </ol> <pre><code>\"\"\" Local to World\n\"\"\"\nplane = Plane(  Point3d( ox, oy, oz ),\n               Vector3d( ux, uy, uz ),\n               Vector3d( vx, vy, vz ) )\n\nworld = Point3d( px, py, pz )\n\nlocal = Point2d(\n    plane.XAxis * ( world - plane.Origin ),\n    plane.YAxis * ( world - plane.Origin ) )\n</code></pre> <p></p> <p>By extension this can be used for expressing the transformation for changing points between the world and arbitrary coordinate systems.</p> <pre><code>\"\"\" Local to World\n\"\"\"\nplane = Plane(  Point3d( ox, oy, oz ),\n               Vector3d( ux, uy, uz ),\n               Vector3d( vx, vy, vz ) )\n\nworld = Point3d( px, py, pz )\n\ndelta = world - plane.Origin\n\nlocal = Point3d(\n    plane.XAxis * delta,\n    plane.YAxis * delta,\n    plane.ZAxis * delta )\n</code></pre>"},{"location":"geometry/vectors/systems/#basis-to-basis","title":"Basis to Basis","text":"<p>A common geometric operation requires copying points from one basis to another. This gets a bit confusing because of the multiplicity of looking at the same object from different frames, but conceptually to perform this operation is the combination of the previous concepts of world-to-local and local-to-world mapping.</p> <p></p> <p>Consider a point <code>p</code> expressed in relationship to the world basis <code>{ O, X, Y, Z }</code> and two  bases <code>{ d, a, b, c }</code> and <code>{ o, u, v, n }</code>. The goal is to compute point <code>q</code> which represents the process of copying <code>q</code> from a source frame <code>{ d, a, b, c }</code> to a target frame <code>{ o, u, v, n }</code>. The requirement is that the transformation is rigid in the sense that both lengths and angles are preserved.</p> <p>This is performed by first transforming <code>p</code> from world-to-local coordinates <code>p -&gt; p_s</code>. However, localizing the point is equivalent to expressing it as a vector in every coordinate system, including the target basis, thus <code>p_s = p_t</code>. To situate it back in the world <code>p_t -&gt; q</code> with respect to the target frame just requires a local-to-world mapping.</p> <pre><code>\"\"\" World to Source\n\"\"\"\np = Point3d( px, py, pz )\n\nsource = Plane(  Point3d( dx, dy, dz ),\n                Vector3d( ax, ay, az ),\n                Vector3d( bx, by, bz ) )\n\ndelta = p - source.Origin\n\np_s = Point3d(\n    source.XAxis * delta.X,\n    source.YAxis * delta.Y,\n    source.ZAxis * delta.Z )\n\n\"\"\" Source to Target\n\"\"\"\np_t = p_s\n\n\"\"\" Target to World\n\"\"\"\ntarget = Plane(  Point3d( ox, oy, oz ),\n                Vector3d( ux, uy, uz ),\n                Vector3d( vx, vy, vz ) )\n\nq = ( target.Origin +\n      target.XAxis * p_t.X +\n      target.YAxis * p_t.Y +\n      target.ZAxis * p_t.Z )\n</code></pre>"},{"location":"geometry/vectors/transforms/","title":"Transformations","text":"<p>This section introduces matrix operations associated with geometric transformations such as translation, scaling, reflection and rotation. Technically matrices are not required for performing geometric transformations. Vector addition and multiplication suffice for 99.9% of geometric constructions. This content is presented because matrices are extremely common and thus it is beneficial to develop some familiarity.</p>"},{"location":"geometry/vectors/transforms/#matrix-transforms","title":"Matrix Transforms","text":"<p>Linear algebra matrices provide the mechanism for expressing geometric transformations. There are a few reasons for using them including: (a) they unify every possible linear transformations in one representation, (b) they allow for combining several consecutive transformations in one data structure, (c) modern GPUs provide hardware acceleration for matrix transformations.</p>"},{"location":"geometry/vectors/transforms/#basis-vectors","title":"Basis Vectors","text":"<p>In computational geometry, square matrices are mostly used such as 2x2, 3x3 and 4x4. One interpretation for such matrices is that they just provide a convenient data structure for grouping the basis vectors of a coordinate system.</p> <p>A basis is defined in 3D by its three orthonormal vectors <code>X = [Xx, Xy, Xz]</code>, <code>Y = [Yx, Yy, Yz]</code>, and <code>Z = [Zx, Zy, Zz]</code>. A 3x3 matrix captures these vectors in a compact representation as seen below. Note that the vectors are arranged in columns but often shown in rows.</p> <pre><code>\"\"\" General Basis 3D\n\"\"\"\nxform  = [[ Xx, Yx, Zx ],\n          [ Xy, Yy, Zy ],\n          [ Xz, Yz, Zz ]]\n\n\"\"\" World Basis 3D\n    Identity Matrix\n\"\"\"\nworld = [[1.0, 0.0, 0.0],\n         [0.0, 1.0, 0.0],\n         [0.0, 0.0, 1.0]]\n</code></pre> <p>While this captures the basis vectors, it misses the origin point <code>O = [Ox, Oy, Oz]</code> or translation. Therefore, the matrix representation is expanded with an additional column to host the origin and a row to keep the matrix square. Adding the last row is for computational convenience, namely performing matrix multiplications. Note that for the basis <code>X</code>, <code>Y</code> and <code>Z</code> column vectors their 4th component is <code>0.0</code> but for the origin or translation vector it is <code>1.0</code>.</p> <pre><code>\"\"\" General Affine 3D\n\"\"\"\nxform  = [[ Xx, Yx, Zx, Ox ],\n          [ Xy, Yy, Zy, Oy ],\n          [ Xz, Yz, Zz, Oz ],\n          [  0,  0,  0   1 ]]\n\n\"\"\" World Affine 3D\n    Identity Matrix\n\"\"\"\nworld = [[1.0, 0.0, 0.0, 0.0],\n         [0.0, 1.0, 0.0, 0.0],\n         [0.0, 0.0, 1.0, 0.0],\n         [0.0, 0.0, 0.0, 1.0]]\n</code></pre> <p>There are several variations for encoding a matrix using programming language constructs. The representation above is known as row-major style because the first subscript is the row and second is the column when using <code>matrix[row][col]</code>. Its transpose is known as column-major. GPUs prefer flat lists instead of nested lists. It is also possible to encode a matrix as a class containing four column vector members as seen below.</p> <pre><code>\"\"\" Transformation Matrix Column\n\"\"\"\nclass Vec4:\n    def __init__( self, x, y, z, w ):\n        self.X = x\n        self.Y = y\n        self.Z = z\n        self.W = w\n\n\"\"\" Transformation Matrix\n\"\"\"\nclass Mat4:\n    def __init__( self,\n            xx = 1.0, yx = 0.0, zx = 0.0, wx = 0.0,\n            xy = 0.0, yy = 1.0, zy = 0.0, wy = 0.0,\n            xz = 0.0, yz = 0.0, zz = 1.0, wz = 0.0,\n            xw = 0.0, yw = 0.0, zw = 0.0, ww = 1.0 ):\n        self.X = Vec4( xx, xy, xz, xw )\n        self.Y = Vec4( yx, yy, yz, yw )\n        self.Z = Vec4( zx, zy, zz, zw )\n        self.W = Vec4( wx, wy, wz, ww )\n\n     \"\"\" Identity Matrix\n     \"\"\"\n    @staticmethod\n    def Identity( ):\n        return Mat4( )\n\n     \"\"\" Matrix from Basis\n     \"\"\"\n    @staticmethod\n    def Basis( o, x, y, z ):\n          return Mat4( x.X, y.X, z.X, o.X,\n                       x.Y, y.Y, z.Y, o.Y,\n                       x.Z, y.Z, z.Z, o.Z,\n                       0.0, 0.0, 0.0, 1.0 )\n\n     \"\"\" Matrix from Plane\n     \"\"\"\n    @staticmethod\n    def Plane( o, x, y ):\n        return self.Basis( o, x, y,\n            Vector3d.CrossProduct( x, y ) )\n</code></pre> <p>In Rhino 4x4 transformation matrices are represented by the <code>Transform</code> class, see also the documentation. <code>Transform</code> objects support several useful operations that can be performed. Manually constructing and editing matrices is rather demotivated by Rhino but there are still some methods for accessing a matrix's elements as seen below.</p> <pre><code>\"\"\" Create World Basis\n\"\"\"\nworld = Transform.Identity\n\n\"\"\" Getting [row, col]\n\"\"\"\nprint( world.Item[3, 3] )\n\n\"\"\" Setting [row, col]\n\"\"\"\nworld.Item[0, 0] = 1.0\n</code></pre>"},{"location":"geometry/vectors/transforms/#matrix-point","title":"Matrix Point","text":"<p>The multiplication of matrices with points and vectors captures the process of transforming them. The process involves computing three dot products which represent the transformed coordinates or components.</p> <pre><code>\"\"\" Transformation Matrix M\n\"\"\"\nM = [[ Xx, Yx, Zx, Ox ],\n     [ Xy, Yy, Zy, Oy ],\n     [ Xz, Yz, Zz, Oz ],\n     [  0,  0,  0   1 ]]\n\n\"\"\" Matrix Point Product q = M x p\n\"\"\"\np = Point3d( px, py, pz )\nq = Point3d(\n     Xx * px + Yx * py + Zx * pz + Ox * 1.0,\n     Xy * px + Yy * py + Zy * pz + Oy * 1.0,\n     Xz * px + Yz * py + Zz * pz + Oz * 1.0 )\n\n\"\"\" Matrix Vector Product v = M x u\n\"\"\"\nu = Vector3d( ux, uy, uz )\nv = Vector3d(\n     Xx * ux + Yx * uy + Zx * uz + Ox * 0.0,\n     Xy * ux + Yy * uy + Zy * uz + Oy * 0.0,\n     Xz * ux + Yz * uy + Zz * uz + Oz * 0.0 )\n</code></pre> <p>Point and vector multiplication by a matrix is slightly different even though the same notation is used. A point <code>p</code> with coordinates <code>[px, py, pz]</code> is converted to <code>[px, py, pz, 1.0]</code> while a vector <code>u</code> with components <code>[ux, uy, uz]</code> is converted to <code>[ux, uy, uz, 0.0]</code> before being multiplied with a transformation matrix. This is because vectors do not convey the notion of position but only direction, therefore the 4th column of the matrix which conveys position or translation, must not be used. Only the upper-left 3x3 sub-matrix is relevant to vectors. The value of <code>0.0</code> or <code>1.0</code> in the 4th element is therefore used as a mask to apply or not the translation.</p> <pre><code>\"\"\" Point and Vector Transformation\n\"\"\"\nclass Mat4:\n    def MatrixPointProduct( self, point ):\n          xx, yx, zx = self.X.X, self.Y.X, self.Z.X\n          xy, yy, zy = self.X.Y, self.Y.Y, self.Z.Y\n          xz, yz, zz = self.X.Z, self.Y.Z, self.Z.Z\n          ox, oy, oz = self.W.X, self.W.Y, self.W.Z\n\n          return Point3d(\n               ox + xx * point.X + yx * point.Y + zx * point.Z,\n               oy + xy * point.X + yy * point.Y + zy * point.Z,\n               oz + xz * point.X + yz * point.Y + zz * point.Z )\n\n     def MatrixVectorProduct( self, vector ):\n          xx, yx, zx = self.X.X, self.Y.X, self.Z.X\n          xy, yy, zy = self.X.Y, self.Y.Y, self.Z.Y\n          xz, yz, zz = self.X.Z, self.Y.Z, self.Z.Z\n\n          return Vector3d(\n               xx * vector.X + yx * vector.Y + zx * vector.Z,\n               xy * vector.X + yy * vector.Y + zy * vector.Z,\n               xz * vector.X + yz * vector.Y + zz * vector.Z )\n</code></pre> <p>In Rhino there are two ways to perform matrix times point or vector multiplication as seen below. Using the multiplication operator <code>*</code> produces a new point or vector, while using the point's or vector's <code>Transform( )</code> method modifies the point or vector in-place. Note that while <code>M * p</code> is supported, the reverse <code>p * M</code> raises an exception.</p> <pre><code>\"\"\" Matrix and Point\n\"\"\"\nM = Transform.Identity\np = Point3d( 1, 2, 3 )\n\n\"\"\" Transform -&gt; Creates new point\n\"\"\"\nq = M * p\n\n\"\"\" Transform -&gt; Modifies in-place\n\"\"\"\np.Transform( M )\n</code></pre>"},{"location":"geometry/vectors/transforms/#matrix-matrix","title":"Matrix Matrix","text":"<p>Multiplication between two 4x4 matrices produces a new 4x4 matrix that encodes the combined or compounded transformation. You may recall that multiplication between two matrices <code>A</code> and <code>B</code> is not commutative, that is <code>A x B != B x A</code>.</p> <pre><code>\"\"\" Matrix Multiplication\n\"\"\"\nclass Mat4:\n     def MatrixMatrixProduct( self, that ):\n          \"\"\" Unpack Matrix Elements\n          \"\"\"\n          sxx, syx, szx, swx = self.X.X, self.Y.X, self.Z.X, self.W.X\n          sxy, syy, szy, swy = self.X.Y, self.Y.Y, self.Z.Y, self.W.Y\n          sxz, syz, szz, swz = self.X.Z, self.Y.Z, self.Z.Z, self.W.Z\n          sxw, syw, szw, sww = self.X.W, self.Y.W, self.Z.W, self.W.W\n\n          txx, tyx, tzx, twx = that.X.X, that.Y.X, that.Z.X, that.W.X\n          txy, tyy, tzy, twy = that.X.Y, that.Y.Y, that.Z.Y, that.W.Y\n          txz, tyz, tzz, twz = that.X.Z, that.Y.Z, that.Z.Z, that.W.Z\n          txw, tyw, tzw, tww = that.X.W, that.Y.W, that.Z.W, that.W.W\n\n          \"\"\" Product Matrix Elements\n          \"\"\"\n          rxx = sxx * txx + syx * txy + szx * txz + swx * txw\n          ryx = sxx * tyx + syx * tyy + szx * tyz + swx * tyw\n          rzx = sxx * tzx + syx * tzy + szx * tzz + swx * tzw\n          rwx = sxx * twx + syx * twy + szx * twz + swx * tww\n\n          rxy = sxy * txx + syy * txy + szy * txz + swy * txw\n          ryy = sxy * tyx + syy * tyy + szy * tyz + swy * tyw\n          rzy = sxy * tzx + syy * tzy + szy * tzz + swy * tzw\n          rwy = sxy * twx + syy * twy + szy * twz + swy * tww\n\n          rxz = sxz * txx + syz * txy + szz * txz + swz * txw\n          ryz = sxz * tyx + syz * tyy + szz * tyz + swz * tyw\n          rzz = sxz * tzx + syz * tzy + szz * tzz + swz * tzw\n          rwz = sxz * twx + syz * twy + szz * twz + swz * tww\n\n          rxw = sxw * txx + syw * txy + szw * txz + sww * txw\n          ryw = sxw * tyx + syw * tyy + szw * tyz + sww * tyw\n          rzw = sxw * tzx + syw * tzy + szw * tzz + sww * tzw\n          rww = sxw * twx + syw * twy + szw * twz + sww * tww\n\n          return Mat4(\n               rxx, ryx, rzx, rwx,\n               rxy, ryy, rzy, rwy,\n               rxz, ryz, rzz, rwz,\n               rxw, ryw, rzw, rww )\n</code></pre> <p>For geometric transformations this makes sense, because the result of combining a rotation and a translation, for example depends on the order on the order of performing those two operations. Note that the way the multiplication is written <code>A x B</code> is the opposite of the application order, namely first <code>B</code> is applied followed by <code>A</code>, that is read right-to-left.</p> <pre><code>\"\"\" Matrix Multiplication\n\"\"\"\nclass Mat4:\n     def __mul__( self, that ):\n          if( isinstance( that, Point3d ) ):\n               return self.MatrixPointProduct( that )\n\n          if( isinstance( that, Vector3d ) ):\n               return self.MatrixVectorProduct( that )\n\n          if( isinstance( that, Mat4 ) ):\n               return self.MatrixMatrixProduct( that )\n\n          raise Exception( 'Unsupported Operation' )\n</code></pre> <p>In Rhino, <code>Transform</code> objects implement multiplication using the standard <code>*</code> operator. Therefore, compounding transformations is performed as seen below.</p> <pre><code>\"\"\" Constructing Matrices\n\"\"\"\nR = Transform.Rotation( ... )\nT = Transform.Translation( ... )\n\n\"\"\" Combining Matrices\n\"\"\"\nRT = R * T #-- Translate then Rotate\nTR = T * R #-- Rotate then Translate\n</code></pre>"},{"location":"geometry/vectors/transforms/#translation","title":"Translation","text":"<p>Point and vector addition provides the mechanics for translating geometry. Using matrices, translation is encoded in the last column as seen below.</p> <p></p> <pre><code>\"\"\" Translation Matrix\n\"\"\"\nclass Mat4:\n    @staticmethod\n    def Translation( direction ):\n        return Mat4(\n            xx = 1.0, yx = 0.0, zx = 0.0, wx = direction.X,\n            xy = 0.0, yy = 1.0, zy = 0.0, wy = direction.Y,\n            xz = 0.0, yz = 0.0, zz = 1.0, wz = direction.Z,\n            xw = 0.0, yw = 0.0, zw = 0.0, ww = 1.0 )\n</code></pre> <p>Note</p> <p>For translation matrices, the matrix-point multiplication simplifies as seen below. As expected translation is just point-vector addition.</p> <pre><code>\"\"\" Translation Matrix x Point\n\"\"\"\np =  Point3d( px, py, pz )\nT = Mat4.Translation( Vector3d( tx, ty, tz ) )\n\nq = Point3d( #-- q = T * p\n     1.0 * px + 0.0 * py + 0.0 * pz + tx * 1.0,\n     0.0 * px + 1.0 * py + 0.0 * pz + ty * 1.0,\n     0.0 * px + 0.0 * py + 1.0 * pz + tz * 1.0 )\n\nq = Point3d( px + tx, py + ty, pz + tz )\n</code></pre> <p>In Rhino the method <code>Translation( )</code> is used for constructing translation matrices as seen below. Its parameters may be either the translation vector itself or its three components.</p> <pre><code>\"\"\" Translation Vector\n\"\"\"\nt = Vector3d( tx, ty, tz )\n\n\"\"\" Translation Matrix\n\"\"\"\nT = Transform.Translation( t )\n#-- equivalent\nT = Transform.Translation( tx, ty, tz )\n</code></pre>"},{"location":"geometry/vectors/transforms/#scaling","title":"Scaling","text":"<p>Point and vector multiplication by a scalar captures the notion of geometric scaling. In matrix form this is represented by its diagonal.</p> <p></p>"},{"location":"geometry/vectors/transforms/#uniform","title":"Uniform","text":"<p>Uniform scaling stretches or shrinks all directions by the same amount. Therefore, the same value is used for all diagonal elements of the matrix as seen below.</p> <pre><code>\"\"\" Uniform Scaling Matrix\n\"\"\"\nclass Mat4:\n    @staticmethod\n    def ScaleUniform( s ): #-- s : float\n        return Mat4(\n            xx =   s, yx = 0.0, zx = 0.0, wx = 0.0,\n            xy = 0.0, yy =   s, zy = 0.0, wy = 0.0,\n            xz = 0.0, yz = 0.0, zz =   s, wz = 0.0,\n            xw = 0.0, yw = 0.0, zw = 0.0, ww = 1.0 )\n</code></pre> <p>Note</p> <p>For scaling matrices, the matrix-point and matrix-vector multiplication simplifies as seen below. As expected scaling is just point-scalar and vector-scalar multiplication.</p> <pre><code>\"\"\" Scaling Matrix x Point\n\"\"\"\nq = Point3d(\n       s * px + 0.0 * py + 0.0 * pz,\n     0.0 * px +   s * py + 0.0 * pz,\n     0.0 * px + 0.0 * py +   s * pz )\n\nq = Point3d( px * s, py * s, pz * s )\n</code></pre> <p>Rhino provides several variations for constructing scaling transforms including with or without an origin. Note that scaling about an origin, or anchor point, combines translation and scaling.</p> <pre><code>\"\"\" Uniform Scaling Factor\n\"\"\"\ns = float( factor )\n\n\"\"\" Uniform Scaling Matrix about [0.0, 0.0, 0.0]\n\"\"\"\nS = Transform.Scale( Point3d.Origin, s )\n\n\"\"\" Uniform Scaling Origin\n\"\"\"\no = Point3d( ox, oy, oz )\n\n\"\"\" Uniform Scaling Matrix about Origin\n\"\"\"\nS = Transform.Scale( o, s )\n</code></pre>"},{"location":"geometry/vectors/transforms/#non-uniform","title":"Non-Uniform","text":"<p>Non-uniform scaling stretches or shrinks each direction by a different amount. Effectively, each diagonal element of the transformation matrix has a separate value as seen below.</p> <pre><code>\"\"\" Non-Uniform Scaling Matrix\n\"\"\"\nclass Mat4:\n    @staticmethod\n    def ScaleNonUniform( s ): #-- s : Vector3d\n        return Mat4(\n            xx = s.X, yx = 0.0, zx = 0.0, wx = 0.0,\n            xy = 0.0, yy = s.Y, zy = 0.0, wy = 0.0,\n            xz = 0.0, yz = 0.0, zz = s.Z, wz = 0.0,\n            xw = 0.0, yw = 0.0, zw = 0.0, ww = 1.0 )\n</code></pre> <p>Note</p> <p>For scaling matrices, the matrix-point and matrix-vector multiplication simplifies as seen below. As expected scaling is just point-scalar and vector-scalar multiplication but with different factors for each.</p> <pre><code>\"\"\" Scaling Matrix x Point\n\"\"\"\nq = Point3d(\n     s.X * px + 0.0 * py + 0.0 * pz,\n     0.0 * px + s.Y * py + 0.0 * pz,\n     0.0 * px + 0.0 * py + s.Z * pz )\n\nq = Point3d( px * s.X, py * s.Y, pz * s.Z )\n</code></pre> <p>In Rhino the <code>Scale( )</code> method supports non-uniform scaling with or without an origin. The origin in this scenario is expressed as a plane for flexibility. To construct a non-uniform matrix without an origin, the WorldXY plane can be used as seen below.</p> <pre><code>\"\"\" Non-Uniform Scaling Factors\n\"\"\"\ns = Vector3d( sx, sy, sz )\n\n\"\"\" Non-Uniform Scaling Matrix about [0.0, 0.0, 0.0]\n\"\"\"\nS = Transform.Scale( Plane.WorldXY, s.X, s.Y, s.Z )\n\n\"\"\" Non-Uniform Scaling Origin\n\"\"\"\no = Plane( Point3d( ox, oy, oz ),\n    Vector3d.XAxis, Vector3d.YAxis )\n\n\"\"\" Non-Uniform Scaling Matrix about Origin\n\"\"\"\nS = Transform.Scale( o, s.X, s.Y, s.Z )\n</code></pre>"},{"location":"geometry/vectors/transforms/#reflection","title":"Reflection","text":"<p>Reflection or mirror transform is conceptually performed about a reference direction or plane. The matrix below represents pure reflection about a plane with unit normal <code>n = [nx, ny, nz]</code> and origin at <code>[0.0, 0.0, 0.0]</code>. Reflecting a point <code>p</code> is constructed by computing the projection of the vector <code>p - o</code> onto the normal <code>d = n \u00b7 ( p - o )</code> and then moving back from <code>p</code> twice the distance to <code>q</code>, that is <code>q = p - 2 * n \u00b7 ( p - o ) \u00b7 n</code>.</p> <p></p> <pre><code>\"\"\" Reflection Matrix\n\"\"\"\nclass Mat4:\n     @staticmethod\n     def Reflection( normal ):\n          xx = normal.X * normal.X * 2.0\n          xy = normal.X * normal.Y * 2.0\n          xz = normal.X * normal.Z * 2.0\n          yy = normal.Y * normal.Y * 2.0\n          yz = normal.Y * normal.Z * 2.0\n          zz = normal.Z * normal.Z * 2.0\n\n          return Mat4( 1.0 - xx, 0.0 - xy, 0.0 - xz, 0.0,\n                       0.0 - xy, 1.0 - yy, 0.0 - yz, 0.0,\n                       0.0 - xz, 0.0 - yz, 1.0 - zz, 0.0,\n                       0.0,      0.0,      0.0,      1.0 )\n</code></pre> <p>Note</p> <p>For reflection matrix about the XY-plane or the Z-axis, the matrix-point multiplication simplifies as seen below. This is equivalent of changing the sign of the point's Z-coordinate.</p> <pre><code>\"\"\" Reflection XY Matrix x Point\n\"\"\"\nXY =  [[ 1.0, 0.0, 0.0, 0.0 ],\n       [ 0.0, 1.0, 0.0, 0.0 ],\n       [ 0.0, 0.0,-1.0, 0.0 ],\n       [ 0.0, 0.0, 0.0, 1.0 ]]\n\nxy = Point3d(\n     1.0 * px + 0.0 * py + 0.0 * pz,\n     0.0 * px + 1.0 * py + 0.0 * pz,\n     0.0 * px + 0.0 * py - 1.0 * pz )\n\nq = Point3d( px, py, -pz )\n</code></pre> <p>In Rhino the <code>Mirror( )</code> method supports reflection about a plane with or without an origin. Note that reflection about an origin other than <code>[0.0, 0.0, 0.0]</code> combines translation and reflection.</p> <pre><code>\"\"\" Point and Reflection Plane\n\"\"\"\np =  Point3d( px, py, pz )\nn = Vector3d( nx, ny, nz )\n\n\"\"\" Reflection about [0.0, 0.0, 0.0]\n\"\"\"\nM = Transform.Mirror( Plane( Point3d.Origin, n ) )\nq = M * p\n\n\"\"\" Reflection about Origin\n\"\"\"\no = Point3d( ox, oy, oz )\nM = Transform.Mirror( Plane( o, n ) )\nq = M * p\n</code></pre>"},{"location":"geometry/vectors/transforms/#rotation","title":"Rotation","text":"<p>Rotation is a significantly more complex geometric transformation and there are several ways to represent and compute. Rotation matrices are represented by the upper-left 3x3 components of a 4x4 transformation matrix. A pure rotation is equivalent to three orthonormal basis vectors, one per column.</p>"},{"location":"geometry/vectors/transforms/#axis-angle","title":"Axis Angle","text":"<p>The most intuitive approach for performing rotations is the axis-angle representation. It requires an axis of rotation represented by a unit vector <code>axis</code> and and <code>angle</code> in radians. (1)</p> <ol> <li>Sometimes, these two pieces of information are packed into a single vector with the angle encoded as the vector's magnitude.</li> </ol> <p></p> <pre><code>\"\"\" Axis and Angle Rotation\n\"\"\"\nclass Mat4:\n     @staticmethod\n     def AxisAngle( axis, angle ):\n          sin = math.sin( angle )\n          cos = math.cos( angle )\n          soc = 1.0 - cos\n\n          return Mat4( xx = axis.X * axis.X * soc + cos,\n                       yx = axis.X * axis.Y * soc - axis.Z * sin,\n                       zx = axis.X * axis.Z * soc + axis.Y * sin,\n\n                       xy = axis.Y * axis.X * soc + axis.Z * sin,\n                       yy = axis.Y * axis.Y * soc + cos,\n                       zy = axis.Y * axis.Z * soc - axis.X * sin,\n\n                       xz = axis.Z * axis.X * soc - axis.Y * sin,\n                       yz = axis.Z * axis.Y * soc + axis.X * sin,\n                       zz = axis.Z * axis.Z * soc + cos )\n</code></pre> <p>In Rhino the <code>Rotation( )</code> method supports the axis-angle representation with or without an origin of rotation. Note that using an origin produces a matrix combining translation and rotation.</p> <pre><code>\"\"\" Rotation Axis and Angle\n\"\"\"\naxis  = Vector3d( ux, uy, uz )\nangle = float( rads )\n\n\"\"\" Rotation Matrix about [0.0, 0.0, 0.0]\n\"\"\"\nR = Transform.Rotation( angle, axis, Point3d.Origin )\n\n\"\"\" Rotation Matrix about Origin\n\"\"\"\nR = Transform.Rotation( angle, axis, Point3d( ox, oy, oz ) )\n</code></pre>"},{"location":"geometry/vectors/transforms/#euler-angles","title":"Euler Angles","text":"<p>Rotation can be also expressed by combining elementary rotations about the World's basis vectors <code>X</code>, <code>Y</code> and <code>Z</code>. This approach is known as the Euler-Angles rotation and requires three angles, one per axis. First the elementary rotation matrices are defined and then their product is computed as seen below.</p> <p></p> <pre><code>\"\"\" Elementary and Euler Angles Rotation\n\"\"\"\nclass Mat4:\n     @staticmethod\n     def RotateX( angle ):\n          sin = math.sin( angle )\n          cos = math.cos( angle )\n          return Mat4( 1.0, 0.0, 0.0, 0.0,\n                       0.0, cos,-sin, 0.0,\n                       0.0, sin, cos, 0.0,\n                       0.0, 0.0, 0.0, 1.0 )\n     @staticmethod\n     def RotateY( angle ):\n          sin = math.sin( angle )\n          cos = math.cos( angle )\n          return Mat4( cos, 0.0, sin, 0.0,\n                       0.0, 1.0, 0.0, 0.0,\n                      -sin, 0.0, cos, 0.0,\n                       0.0, 0.0, 0.0, 1.0 )\n     @staticmethod\n     def RotateZ( angle ):\n          sin = math.sin( angle )\n          cos = math.cos( angle )\n          return Mat4( cos,-sin, 0.0, 0.0,\n                       sin, cos, 0.0, 0.0,\n                       0.0, 0.0, 1.0, 0.0,\n                       0.0, 0.0, 0.0, 1.0 )\n     @staticmethod\n     def RotateZYX( ax, ay, az ):\n          return ( Mat4.RotateX( ax ) *\n                   Mat4.RotateY( ay ) *\n                   Mat4.RotateZ( az ) )\n</code></pre> <p>Rhino supports two common permutation of Euler-Angle rotation, namely <code>RotationZYX( )</code> and <code>RotationZYZ( )</code>.</p> <pre><code>\"\"\" Angles per Axis\n\"\"\"\nax, ay, az = ...angles\n\n\"\"\" Combined Rotation Matrix\n\"\"\"\nR = Transform.RotationZYX( az, ay, ax )\n</code></pre> <p>Euler-Angle rotation is very old-fashioned, rather counterintuitive and degenerates for certain rotation combinations. As such it is recommended to be avoided. However, because it is still used in robotics applications, it is good to be generally aware of.</p>"},{"location":"geometry/vectors/transforms/#quaternions","title":"Quaternions","text":"<p>The modern representation for rotation is based on the concept of a unit quaternion. Quaternions are counterintuitive because they represent complex number 4D vectors which cannot be visually comprehended. Quaternions are not required for 99% of geometric constructions. However, they are presented because they are often used in game engines and robotics applications.</p> <p>Quaternions are popular because of their properties including (a) They are compact in that they required only <code>4</code> floats, compared to <code>9</code> per rotation matrix, (b) They express only rotation, unlike matrices that conflate rotation, scaling and reflection, and (c) They combine using multiplication, which is not possible with axis-angle vectors.</p> <p>The most sane way to approach quaternions is to: (a) Convert regular 3D vectors to quaternions, (b) Perform the rotational transformations required, (c) Convert back from quaternion space to normal 3D vector space.</p>"},{"location":"geometry/vectors/transforms/#representation","title":"Representation","text":"<p>Quaternions are represented as <code>q = [qx, qy, qz, qw]</code>, where approximately the <code>qx</code>, <code>qy</code> and <code>qz</code> express the axis of rotation, and <code>qw</code> the angle. They behave like vectors in that they can be added, multiplied and have length. Rotations require unit-length quaternions, so unless otherwise specified, quaternions are assumed normalized.</p> <pre><code>\"\"\" Quaternion\n\"\"\"\nclass Quat:\n     def __init__( self, x, y, z, w ):\n          self.X = x\n          self.Y = y\n          self.Z = z\n          self.W = w\n\n     @property\n     def Length( self ):\n          return math.sqrt(\n               self.X ** 2 +\n               self.Y ** 2 +\n               self.Z ** 2 +\n               self.W ** 2 )\n\n     def Normalize( self ):\n          length = self.Length\n          if( length == 0.0 ):\n               return Quat( 0.0, 0.0, 0.0, 0.0 )\n          return Quat( self.X / length,\n                       self.Y / length,\n                       self.Z / length,\n                       self.W / length )\n</code></pre>"},{"location":"geometry/vectors/transforms/#construction","title":"Construction","text":"<p>Vectors can be converted from and to quaternions, where for a vector <code>u = [ux, uy, uz]</code>, the associated quaternion is <code>q = [ux, uy, uz, 0.0]</code>. Additionally, there are several methods for converting between quaternions, Axis-Angle and Euler-Angles. Constructing a quaternion using an Axis-Angle representation is shown below.</p> <pre><code>class Quat:\n     \"\"\" Vector to Quaternion\n     \"\"\"\n     @statimethod\n     def FromVector( vector ):\n          return Quat( vector.X,\n                       vector.Y,\n                       vector.Z, 0.0 )\n\n     \"\"\" Quaternion from Axis-Angle\n     \"\"\"\n     @staticmethod\n     def FromAxisAngle( axis, angle ):\n          sin = math.sin( angle / 2.0 )\n          cos = math.cos( angle / 2.0 )\n\n          return Quat( axis.X * sin,\n                       axis.Y * sin,\n                       axis.Z * sin,\n                                cos )\n</code></pre> <p>Rhino's <code>Quaternion</code> expressing the same construction from Axis-Angle is presented below. Note that Rhino's naming convention uses <code>q = [a, b, c, d]</code>, where <code>a = qw</code> and  <code>b</code>, <code>c</code>, and <code>d</code> map to <code>qx</code>, <code>qy</code>, and <code>qz</code>, respectively.</p> <pre><code>\"\"\" Quaternion from Axis-Angle\n\"\"\"\nq = Quaternion.Rotation( angle, axis )\n</code></pre>"},{"location":"geometry/vectors/transforms/#compound-rotations","title":"Compound Rotations","text":"<p>Combining rotations, expressed as quaternions, is achieved by regular multiplication. Note that quaternion multiplication is not commutative <code>u * v != v * u</code>, so the order is important.</p> <pre><code>\"\"\" Quaternion Quaternion Product\n\"\"\"\nclass Quat:\n     def QuatQuatProduct( self, that ):\n          sx, sy, sz, sw = self.X, self.Y, self.Z, self.W\n          tx, ty, tz, tw = that.X, that.Y, that.Z, that.W\n\n          return Quat(\n               sw * tx +   sx * tw + sy * tz - sz * ty\n               sw * ty +   sy * tw + sz * tx - sx * tz\n               sw * tz +   sz * tw + sx * ty - sy * tx\n               sw * tw - ( sx * tx + sy * ty + sz * tz ) )\n\n     def __mul__( self, that ):\n          if( isinstance( that, Quat ) ):\n               return self.QuatQuatProduct( that )\n\n          raise Exception( 'Unsupported Operation' )\n\n\"\"\" Combined Rotation\n\"\"\"\nu = Quat.Rotation( Vector3d( ux, uy, uz ), ua )\nv = Quat.Rotation( Vector3d( vx, vy, vz ), ub )\nw = u * v\n</code></pre>"},{"location":"geometry/vectors/transforms/#quaternion-to-matrix","title":"Quaternion To Matrix","text":"<p>Rotating points and vectors using unit quaternions can be achieved in several ways. One approach is to convert the quaternion to a 4x4 matrix and perform the transformation as usual.</p> <pre><code>\"\"\" Quaternion to Transformation Matrix\n\"\"\"\nclass Quat:\n     def ToMatrix( self ):\n          x, y, z, w = self.X, self.Y, self.Z, self.W\n\n          xx, yy, zz = x * x, y * y, z * z\n          xy, zx, yz = x * y, z * x, y * z\n          xw, yw, zw = x * w, y * w, z * w\n\n          return Mat4( 1.0 - 2.0 * ( yy + zz ),\n                             2.0 * ( xy - zw ),\n                             2.0 * ( zx + yw ), 0.0,\n\n                             2.0 * ( xy + zw ),\n                       1.0 - 2.0 * ( xx + zz ),\n                             2.0 * ( yz - xw ), 0.0,\n\n                             2.0 * ( zx - yw ),\n                             2.0 * ( yz + xw ),\n                       1.0 - 2.0 * ( xx + yy ), 0.0 )\n\n\"\"\" Point Rotation\n\"\"\"\np = Point3d( px, py, pz )\nu = Quat.FromAxisAngle( Vector3d( ux, uy, uz ), ua )\nq = u.ToMatrix( ) * p\n</code></pre> <p>The equivalent in Rhino uses the <code>GetRotation( )</code> method which returns the transformation matrix, as seen below.</p> <pre><code>\"\"\" Point Rotation\n\"\"\"\np = Point3d( px, py, pz )\nu = Quaternion.Rotation( ua, Vector3d( ux, uy, uz ) )\nq = u.GetRotation( ) * p\n</code></pre>"},{"location":"geometry/vectors/transforms/#quaternion-sandwich-product","title":"Quaternion Sandwich Product","text":"<p>The same rotational operation can be achieved using the quaternion product <code>q' * u * q</code>, where <code>q  = [qx, qy, qz, qw]</code> is the rotation quaternion, <code>q' = [-qx, -qy, -qz, qw]</code> is its conjugate, in the complex number sense, and <code>u = [ux, uy, uz]</code> is a vector converted to a quaternion.</p> <pre><code>class Quat:\n     @property\n     def Conjugate( self ):\n          return Quat( -self.X,\n                       -self.Y,\n                       -self.Z,\n                        self.W )\n\n     @property\n     def Inverse( self ):\n          length = self.Length\n          if( length == 0.0 ):\n               return Quat( 0.0, 0.0, 0.0 ,0.0 )\n          return Quat(\n               self.X / length,\n               self.Y / length,\n               self.Z / length,\n               self.W /-length )\n\n     def RotateVector( self, u ):\n          return ( self.Conjugate *\n                   Quat.FromVector( u ) *\n                   self )\n\n\"\"\" Point and Rotation\n\"\"\"\nu = Vector3d( ux, uy, uz )\nq = Quat.FromAxisAngle( Vector3d( ax, ay, az ), angle )\nv = q.RotateVector( u )\n</code></pre> <p>Note that quaternion rotation only makes sense for vectors. It can work with points if they are assumed in reference to the world. Otherwise, points must be first mapped to the world basis, then rotated using quaternions, and finally mapped back to their local basis.</p> <p>Rhino provides the <code>Rotate( )</code> method with the same semantics as above.</p> <pre><code>\"\"\" Point and Rotation\n\"\"\"\nu = Vector3d( ux, uy, uz )\nq = Quaternion.Rotation( angle, Vector3d( ax, ay, az ) )\nv = q.Rotate( u )\n</code></pre>"},{"location":"geometry/vectors/transforms/#interpolation-of-rotations","title":"Interpolation of Rotations","text":"<p>Interpolating rotations using quaternions is one of their earliest applications that motivated their use. This is because interpolating both between transformation matrices and axis-angle vectors, element-wise, produces unreasonable results. On the other hand, quaternion interpolation rotates all three basis vectors of a coordinate system smoothly, with minimal twists.</p> <p>There are a couple of versions of quaternion interpolation: Linear interpolation which is not unlike regular point and vector interpolation. Note that using linear combinations requires quaternion normalization. Additionally, there is spherical linear interpolation, which can be considered as a rotation about a major circle, that is passing through the center, of a sphere at equal angle steps.</p> <pre><code>class Quat:\n     \"\"\" Linear Interpolation\n     \"\"\"\n     def Lerp( self, that, t ):\n          quat = Quat(\n               self.X * ( 1.0 - t ) + that.X * t,\n               self.Y * ( 1.0 - t ) + that.Y * t,\n               self.Z * ( 1.0 - t ) + that.Z * t,\n               self.W * ( 1.0 - t ) + that.W * t )\n          return quat.Normalize( )\n\n     \"\"\" Spherical Linear Interpolation\n     \"\"\"\n     def Slerp( self, that, t ):\n          cos = ( self.X * that.X +\n                  self.Y * that.Y +\n                  self.Z * that.Z +\n                  self.W * that.W )\n          cos = min( max( cos, -1 ), 1 )\n\n          ang = math.acos( cos )\n          sin = math.sin ( ang )\n\n          if( abs( ang ) == 0.0 ):\n               return that\n          sin = 1.0 / sin\n\n          u = sin * math.sin( ( 1.0 - t ) * ang )\n          v = sin * math.sin( t * ang )\n\n          return Quat(\n               self.X * u + that.X * v,\n               self.Y * u + that.Y * v,\n               self.Z * u + that.Z * v,\n               self.W * u + that.W * v )\n</code></pre>"},{"location":"geometry/vectors/transforms/#matrix-inverse","title":"Matrix Inverse","text":"<p>The inverse of a square matrix M<sup>-1</sup> multiplied with the matrix itself M<sup>-1</sup>M = I produces the identity matrix. A matrix is invertible if its determinant is not zero. A transformation matrix constructed by compounding translation, rotation, scaling and reflection, is generally invertible. The inverse of transformation matrix has some interesting properties. Note that from the point transformation formula Mp = q, by multiplying both sides with the inverse produces M<sup>-1</sup>Mp = M<sup>-1</sup>q or p = M<sup>-1</sup>q.</p> <p>The interpretation of this is that transforming a point by a matrix Mp = q is equivalent to local-to-global coordinates transform, while transforming a point by the inverse of the matrix p = M<sup>-1</sup>q produces the global-to-local mapping.</p> <pre><code>\"\"\" Matrix Inverse\n\"\"\"\nclass Mat4:\n     @property\n     def Inverse( self ):\n          \"\"\" Unpack Matrix Elements\n          \"\"\"\n          xx, yx, zx, wx = self.X.X, self.Y.X, self.Z.X, self.W.X\n          xy, yy, zy, wy = self.X.Y, self.Y.Y, self.Z.Y, self.W.Y\n          xz, yz, zz, wz = self.X.Z, self.Y.Z, self.Z.Z, self.W.Z\n          wx, wy, wz, ww = self.W.X, self.W.Y, self.W.Z, self.W.W\n\n          \"\"\" Minor Determinants\n          \"\"\"\n          t00 = xx * yy - yx * xy\n          t01 = xx * zy - zx * xy\n          t02 = xx * wy - wx * xy\n          t03 = yx * zy - zx * yy\n          t04 = yx * wy - wx * yy\n          t05 = zx * wy - wx * zy\n          t06 = xz * yw - yz * xw\n          t07 = xz * zw - zz * xw\n          t08 = xz * ww - wz * xw\n          t09 = yz * zw - zz * yw\n          t10 = yz * ww - wz * yw\n          t11 = zz * ww - wz * zw\n\n          \"\"\" Determinant (unsafe)\n          \"\"\"\n          det = 1.0 / ( t00 * t11 - t01 * t10 +\n                        t02 * t09 + t03 * t08 -\n                        t04 * t07 + t05 * t06 )\n\n          \"\"\" Matrix Inverse\n          \"\"\"\n          return Mat4(\n               det * ( yy * t11 - zy * t10 + wy * t09 ),\n               det * ( zx * t10 - wx * t09 - yx * t11 ),\n               det * ( yw * t05 - zw * t04 + ww * t03 ),\n               det * ( zz * t04 - wz * t03 - yz * t05 ),\n\n               det * ( zy * t08 - wy * t07 - xy * t11 ),\n               det * ( xx * t11 - zx * t08 + wx * t07 ),\n               det * ( zw * t02 - ww * t01 - xw * t05 ),\n               det * ( xz * t05 - zz * t02 + wz * t01 ),\n\n               det * ( xy * t10 - yy * t08 + wy * t06 ),\n               det * ( yx * t08 - wx * t06 - xx * t10 ),\n               det * ( xw * t04 - yw * t02 + ww * t00 ),\n               det * ( yz * t02 - wz * t00 - xz * t04 ),\n\n               det * ( yy * t07 - zy * t06 - xy * t09 ),\n               det * ( xx * t09 - yx * t07 + zx * t06 ),\n               det * ( yw * t01 - zw * t00 - xw * t03 ),\n               det * ( xz * t03 - yz * t01 + zz * t00 ) )\n</code></pre> <p>Inverting general transformation matrices as seen above is computationally involved. However, inverting elementary transformations is much simpler: The inverse of a translation matrix is a translation matrix with the negative displacement values. The inverse of a scaling matrix is a scaling matrix with the inverse scaling factors. The inverse of a rotation matrix is its transpose.</p> <pre><code>\"\"\" Matrix Inverse\n\"\"\"\nclass Mat4:\n    def TranslationInverse( self ):\n          xx, yx, zx, wx = self.X.X, self.Y.X, self.Z.X, self.W.X\n          xy, yy, zy, wy = self.X.Y, self.Y.Y, self.Z.Y, self.W.Y\n          xz, yz, zz, wz = self.X.Z, self.Y.Z, self.Z.Z, self.W.Z\n          wx, wy, wz, ww = self.W.X, self.W.Y, self.W.Z, self.W.W\n\n          return Mat4(\n               xx = xx, yx = yx, zx = zx, wx = -wx,\n               xy = xy, yy = yy, zy = zy, wy = -wy,\n               xz = xz, yz = yz, zz = zz, wz = -wz,\n               xw = xw, yw = yw, zw = zw, ww =  ww )\n\n    def ScaleUniformInverse( self ):\n          xx, yx, zx, wx = self.X.X, self.Y.X, self.Z.X, self.W.X\n          xy, yy, zy, wy = self.X.Y, self.Y.Y, self.Z.Y, self.W.Y\n          xz, yz, zz, wz = self.X.Z, self.Y.Z, self.Z.Z, self.W.Z\n          wx, wy, wz, ww = self.W.X, self.W.Y, self.W.Z, self.W.W\n\n          return Mat4(\n               xx = 1 / xx, yx =     yx, zx =     zx, wx = wx,\n               xy =     xy, yy = 1 / yy, zy =     zy, wy = wy,\n               xz =     xz, yz =     yz, zz = 1 / zz, wz = wz,\n               xw =     xw, yw =     yw, zw =     zw, ww = ww )\n\n     def RotationInverse( self ):\n          return self.Transpose\n\n     @property\n     def Transpose( self )\n          xx, yx, zx, wx = self.X.X, self.Y.X, self.Z.X, self.W.X\n          xy, yy, zy, wy = self.X.Y, self.Y.Y, self.Z.Y, self.W.Y\n          xz, yz, zz, wz = self.X.Z, self.Y.Z, self.Z.Z, self.W.Z\n          wx, wy, wz, ww = self.W.X, self.W.Y, self.W.Z, self.W.W\n\n          return Mat4(\n               xx = xx, yx = xy, zx = xz, wx = xw,\n               xy = yx, yy = yy, zy = yz, wy = yw,\n               xz = zx, yz = zy, zz = zz, wz = zw,\n               xw = wx, yw = wy, zw = wz, ww = ww )\n</code></pre> <p>Therefore, a transformation M = T * S * R, composed of translation <code>T</code>, scaling <code>S</code> and rotation <code>R</code>, can be inverted using M<sup>-1</sup> = R<sup>T</sup> * S<sup>-1</sup> * T<sup>-1</sup>, because M<sup>-1</sup> * M =  R<sup>T</sup> * S<sup>-1</sup> * ( T<sup>-1</sup> * T ) * S * R, and thus M<sup>-1</sup> * M =  R<sup>T</sup> * ( S<sup>-1</sup> * S ) * R which yields M<sup>-1</sup> * M = R<sup>T</sup> * R = I, which just the identity matrix.</p> <p>Moreover, for orthonormal matrices, there is no scaling component, therefore M<sup>-1</sup> = R<sup>T</sup> * T<sup>-1</sup> which can be expanded as seen below. This computation is much simpler and  matches the process of world-to-local mapping  presented earlier, where the dot products of between the translation vector and the basis vectors were computed.</p> <pre><code>\"\"\" Inverse of Basis Matrix\n\"\"\"\nclass Mat4:\n    @property\n    def Reverse( self ):\n        xx, yx, zx, wx = self.X.X, self.Y.X, self.Z.X, self.W.X\n        xy, yy, zy, wy = self.X.Y, self.Y.Y, self.Z.Y, self.W.Y\n        xz, yz, zz, wz = self.X.Z, self.Y.Z, self.Z.Z, self.W.Z\n        wx, wy, wz, ww = self.W.X, self.W.Y, self.W.Z, self.W.W\n\n        return Mat4(\n          xx, xy, xz, -( wx * xx + wy * xy + wz * xz ),\n          yx, yy, yz, -( wx * yx + wy * yy + wz * yz ),\n          zx, zy, zz, -( wx * zx + wy * zy + wz * zz ) )\n</code></pre>"},{"location":"geometry/vectors/transforms/#basis-to-basis","title":"Basis to Basis","text":"<p>Transforming geometries in a rigid way between coordinate systems was discussed earlier using the concept of basis-to-basis mapping. This operation can be performed using matrices. Since a matrix and its inverse encompass the change from local-to-global coordinates it is just a matter of composing two transformations, namely the inverse of the source basis followed by the target basis transform.</p> <p></p> <pre><code>\"\"\" Basis to Basis Transform\n\"\"\"\nclass Mat4:\n     def BasisToBasis( source, target ):\n          return target * source.Reverse\n\n\"\"\" World to Source\n\"\"\"\nsource = Mat4.Plane(  Point3d( sox, soy, soz ),\n                     Vector3d( sxx, sxy, sxz ),\n                     Vector3d( syx, syy, syz ) )\n\ntarget = Mat4.Plane(  Point3d( tox, toy, toz ),\n                     Vector3d( txx, txy, txz ),\n                     Vector3d( tyx, tyy, tyz ) )\n\ntransform = Mat4.BasisToBasis( source, target )\n\npoint = Point3d( px, py, pz )\npoint.Transform( transform )\n</code></pre> <p>Rhino provides the <code>PlaneToPlane( )</code> method for constructing such transforms, where the first parameter is a source plane and the second parameter is the target plane. Note that mapping from world-to-local space can be performed using <code>PlaneToPlane( source, Plane.WorldXY )</code> and local-to-world using <code>PlaneToPlane( Plane.WorldXY, target )</code>. In that sense plane-to-plane is just a composition of these two transformations.</p> <pre><code>\"\"\" Plane to Plane Transform\n\"\"\"\nsource = Plane(  Point3d( sox, soy, soz ),\n                Vector3d( sxx, sxy, sxz ),\n                Vector3d( syx, syy, syz ) )\n\ntarget = Plane(  Point3d( tox, toy, toz ),\n                Vector3d( txx, txy, txz ),\n                Vector3d( tyx, tyy, tyz ) )\n\ntransform = Transform.PlaneToPlane( source, target )\n\npoint = Point3d( px, py, pz )\npoint.Transform( transform )\n</code></pre>"},{"location":"geometry/vectors/transforms/#conversions","title":"Conversions","text":"<p>With so many representations of rotation it is often required to convert between one another. This section provides some common conversions which are mainly presented because of their use in robotics. Quaternion to axis-angle conversion is straight forward as seen below.</p> <pre><code>\"\"\" Quaternion to Axis Angle\n\"\"\"\nclass Quat:\n     def ToAxisAngle( self ):\n          length = math.sqrt( self.X ** 2 +\n                              self.Y ** 2 +\n                              self.Z ** 2 )\n          if( length == 0.0 ):\n               return ( Vector3d.ZAxis, 0.0 )\n\n          angle = 2.0 * math.atan2( length, self.W )\n          return ( Vector3d( self.X / scale,\n                             self.Y / scale,\n                             self.Z / scale ), angle )\n</code></pre> <p>Matrix to quaternion conversion is not a straight forward with several implementations available. UR robots use Java's conversion, see relevant repository on github.</p> <pre><code>class Mat4:\n     \"\"\" Mat4 to Quat for UR\n     \"\"\"\n     def ToQuatUR( self ):\n          ww = 0.25 * ( self.X.X +\n                        self.Y.Y +\n                        self.Z.Z + 1.0 )\n          if( ww &gt;= 0.0 ):\n               if( ww &gt;= 1e-30 ):\n                    qw = math.sqrt( ww )\n                    ww = 0.25 / qw\n                    qx = ( self.Y.Z - self.Z.Y ) * ww\n                    qy = ( self.Z.X - self.X.Z ) * ww\n                    qz = ( self.X.Y - self.Y.X ) * ww\n                    return Quat( qx, qy, qz, qw )\n          else return Quat( 0, 0, 1, 0 )\n\n          qw = 0.0\n          ww = -0.5 * ( self.Y.Y + self.Z.Z )\n          if( ww &gt;= 0.0 ):\n               if( ww &gt;= 1e-30 ):\n                    qx = math.sqrt( ww )\n                    ww = 0.5 / qx\n                    qy = self.X.Y * ww\n                    qz = self.X.Z * ww\n                    return Quat( qx, qy, qz, qw )\n          else return Quat( 0, 0, 1, 0 )\n\n          qx = 0.0\n          ww = 0.5 * ( 1.0 - matrix.Z.Z )\n          if( ww &gt;= 1e-30 ):\n               qy = math.sqrt( ww )\n               qz = ( 0.5 * self.Y.Z / qy )\n               return Quat( 0, qy, qz, 0 )\n          return Quat( 0, 0, 1, 0 )\n</code></pre> <p>The matrix to quaternion conversion used by ABB robots is compatible with the branchless implementation, see Christian's derivation of the expressions found below.</p> <pre><code>def math_sign( value ):\n     if( value == 0.0 ): return 0\n     return 1 if( value &gt; 0 ) else -1\n\nclass Mat4:\n     \"\"\" Mat4 to Quat ABB\n     \"\"\"\n     def ToQuatABB( self ):\n          x = ( 0.5 * math.sqrt( max( 0,\n                1.0 + self.X.X - self.Y.Y - self.Z.Z ) )\n                    * math_sign( self.Y.Z - self.Z.Y ) )\n          y = ( 0.5 * math.sqrt( max( 0,\n                1.0 - self.X.X + self.Y.Y - self.Z.Z ) )\n                    * math_sign( self.Z.X - self.X.Z ) )\n          z = ( 0.5 * math_sqrt( max( 0,\n                1.0 - self.X.X - self.Y.Y + self.Z.Z ) )\n                    * math_sign( self.X.Y - self.Y.X ) )\n          w = ( 0.5 * math.sqrt( max( 0,\n                1.0 + self.X.X + self.Y.Y + self.Z.Z ) ) )\n        return Quat( x, y, z, w )\n</code></pre> <p>There is yet another implementation from Euclidean Space presented below for completeness, even though it does not seem to be compatible with either robot system.</p> <pre><code>class Mat4:\n     \"\"\" Euclidean Space Mat4 to Quat\n     \"\"\"\n     def ToQuatES( self ):\n          s = self.X.X + self.Y.Y + self.Z.Z\n          if( s &gt; 0.0 ):\n               s = 0.5 / math.sqrt( s + 1 )\n               return Quat(\n                    s * ( self.Y.Z - self.Z.Y ),\n                    s * ( self.Z.X - self.X.Z ),\n                    s * ( self.X.Y - self.Y.X ),\n                    0.25 / s )\n\n          if( ( self.X.X &gt; self.Y.Y ) and\n              ( self.X.X &gt; self.Z.Z ) ):\n               s = 0.5 / math.sqrt( 1 + self.X.X -\n                                        self.Y.Y -\n                                        self.Z.Z )\n               return Quat(\n                    0.25 / s,\n                    s * ( self.Y.X + self.X.Y ),\n                    s * ( self.Z.X + self.X.Z ),\n                    s * ( self.Y.Z - self.Z.Y ) )\n\n          if( self.Y.Y &gt; self.Z.Z ):\n               s = 0.5 / math.sqrt( 1 + self.Y.Y -\n                                        self.X.X -\n                                        self.Z.Z )\n               return Quat(\n                    s * ( self.Y.X + self.X.Y ),\n                    0.25 / s,\n                    s * ( self.Z.Y + self.Y.Z ),\n                    s * ( self.Z.X - self.X.Z ) )\n\n          s = 0.5 / math.sqrt( 1 + self.Z.Z -\n                                   self.X.X -\n                                   self.Y.Y )\n          return Quat(\n               s * ( self.Z.X + self.X.Z ),\n               s * ( self.Z.Y + self.Y.Z ),\n               0.25 / s,\n               s * ( self.X.Y - self.Y.X ) )\n</code></pre> <p>Extracting the Euler angles from a rotation matrix is another ambiguous conversion with several implementations. KUKA robots use <code>A</code>, <code>B</code> and <code>C</code> Euler angles which map to the <code>Z</code>, <code>Y</code> and <code>X</code> axes, respectively. Additionally, the method <code>ToEulerAnglesKUKA( )</code>, when angle <code>B</code> is <code>\u00b1\u03c0/2</code>, the solution in not the inverse of <code>FromEulerKUKA( )</code> as <code>A</code> is set to <code>0</code>, see documentation.</p> <p>Two alternative implementations are presented, the conventional <code>ToEulerAngles( )</code>, which is the inverse of <code>RotateZYX( )</code>, and a safe version proposed by Mike Day, see derivation. Note that the results are subject to sign changed based on whether the elementary matrices are considered in the clockwise or counter-clockwise sense.</p> <pre><code>class Mat4:\n     \"\"\" KUKA Compatible Euler Rotation\n     \"\"\"\n     def FromEulerKUKA( a, b, c ):\n        sa, ca = math.sin( a ), math.cos( a )\n        sb, cb = math.sin( b ), math.cos( b )\n        sc, cc = math.sin( c ), math.cos( c )\n\n        return Mat4( xx = ca * cb,\n                     yx = ca * sb * sc - sa * cc,\n                     zx = ca * sb * cc + sa * sc,\n\n                     xy = sa * cb,\n                     yy = sa * sb * sc + ca * cc,\n                     zy = sa * sb * cc - ca * sc,\n\n                     xz = -sb,\n                     yz = cb * sc,\n                     zz = cb * cc )\n\n     \"\"\" KUKA Compatible Euler Angles\n     \"\"\"\n     def ToEulerAnglesKUKA( self, epsilon = 1e-15 ):\n          b = math.atan2( -self.X.Z, math.sqrt(\n               self.X.X * self.X.X +\n               self.X.Y * self.X.Y ) )\n          cos = math.cos( b )\n          if( abs( cos ) &lt;= 1e-15 ):\n              a = 0.0 #-- !\n              c = b * math.atan2( self.Y.Z, self.Z.Z ) / abs( b )\n          else:\n              a = math.atan2( self.X.Y / cos, self.X.X / cos )\n              c = math.atan2( self.Y.Z / cos, self.Z.Z / cos )\n          return ( a, b, c )\n\n     \"\"\" Euler Angles from Matrix\n     \"\"\"\n     def ToEulerAngles( self ):\n          x = math.atan2(-self.Z.Y, self.Z.Z )\n          y = math.atan2( self.Z.X, math.sqrt(\n               self.X.X * self.X.X +\n               self.Y.X * self.Y.X ) )\n          z = math.atan2(-self.Y.X, self.X.X )\n          return ( x, y, z )\n\n     \"\"\" Euler Angles from Matrix MD\n     \"\"\"\n     def ToEulerAnglesMD( self ):\n          x = math.atan2(-self.Z.Y, self.Z.Z )\n          y = math.atan2( self.Z.X, math.sqrt(\n               self.X.X * self.X.X +\n               self.Y.X * self.Y.X ) )\n          s, c = math.sin( x ), math.cos( x )\n          z = math.atan2( c * self.X.Y + s * self.X.Z,\n                          c * self.Y.Y + s * self.Y.Z )\n          return ( x, y, z )\n</code></pre>"},{"location":"parametrics/components/","title":"Python for Grasshopper","text":"<p>The objective of this section is to introduce basic conventions for setting up python script components in grasshopper and explain how to configure them before editing their code contents.</p>"},{"location":"parametrics/components/#default-configuration","title":"Default Configuration","text":"<p>To create a new python component switch the component palette to the Maths tab and insert a GHPython Script component in the document. The default component setup contains two input parameters, <code>x</code> and <code>y</code>, as well as two output parameters, <code>out</code> and <code>a</code>.</p>"},{"location":"parametrics/components/#standard-operating-procedure","title":"Standard Operating Procedure","text":""},{"location":"parametrics/components/#component-name","title":"Component Name","text":"<p>The first configuration step is to rename the component from \"GhPython Script\" to something more appropriate. To achieve this right click over the name of the component and edit the first pop-up menu entry. Note that the name of the component is merely for mnemonic purposes. It does not affect the way python will execute the code provided.</p>"},{"location":"parametrics/components/#number-of-input-parameters","title":"Number of Input Parameters","text":"<p>The number of parameters, zero or more, depends on the objective of the component. To adjust the number of input and output parameter requires zooming in the viewport and using the +/- handles that appear between the parameter names.</p>"},{"location":"parametrics/components/#input-parameter-names","title":"Input Parameter Names","text":"<p>Next we need to rename the input parameters. The same operation as before applies where we right click over each parameter's name and change the first entry in the pop-up menu. Unlike renaming the component, changing parameter names affects python.</p>"},{"location":"parametrics/components/#common-name-challenges","title":"Common Name Challenges","text":"<ol> <li>Parameter names map directly to python variable names. As such it is important to be aware that the letter case used is important. The names \"point\", \"Point\", \"PoInT\" etc, are all different. Python variable names are case sensitive.</li> <li>Parameter names must not include spaces, white space in general, because python does not allow that for variables. Instead you may use one of the following naming conventions \"twoWords\", \"TwoWords\" or \"two_words\".</li> <li>Some names are already used by python and Rhino. For instance \"if\" is a python language construct, so using this as a parameter name will cause errors. The word \"Surface\" is a class name used by Rhino, so using this as a parameter name will cause naming conflict in the code.</li> <li>Renaming parameters does not automatically rename the associated variables in the code. Instead the code must be edited and saved before the name change has any effects.</li> </ol>"},{"location":"parametrics/components/#input-parameter-types","title":"Input Parameter Types","text":"<p>Input parameters may be annotated with data type information before being used in python to avoid programming errors. To adjust an input parameter's type right click over its name and select one of the available types presented by the \"Type hint\" menu.</p> <p>Below is a list of the most commonly encountered data type hints and the description for when they should be used. Note that the default <code>object</code> type hint will almost always cause automatic conversion between data types which can result in annoying python errors. It is highly recommended to properly annotate all input parameters with the expected data type.</p> Type Description <code>None</code> Used for suppressing data type information and automatic conversions. <code>Object</code> Used for dynamic values that can take any data type. Default option. <code>Guid</code> Used for referencing objects contained in the Rhino document. <code>float</code> Used for real number values such as coordinates and decimal quantities. <code>bool</code> Used for True / False values such as enable toggles and flags. <code>int</code> Used for integer number values such as indices and counts. <code>str</code> Used for string values including single and multiline text. <code>Geometry</code> Used for grasshopper geometries which are not same as Rhino objects."},{"location":"parametrics/components/#common-type-challenges","title":"Common Type Challenges","text":"<p>Below are some common error messages which hint that the data type information is either missing or incorrectly assigned.</p> <ol> <li> <p><code>TypeErrorException</code> occurs when the expected and received types of data do not match. For example a numerical-looking value, say \"3.1415\", is passed from a panel to a python component. The parameter was NOT annotated as <code>float</code> and its was used for performing math eg. computing the cosine. The problem here is that \"3.1415\" is a <code>str</code>, which cannot be used for regular math. However, if the type hint is set to <code>float</code> then the value will be converted into a number before being received by python.</p> </li> <li> <p><code>MissingMemberException</code> occurs when an object with a known attribute is expected but it is not found. For example a point 3D is connected to a python component input and in the code its X-coordinate is used. If the input parameter is not typed as Point3d this error will occur.</p> </li> <li> <p><code>Guid</code> object has no attribute <code>identifier</code> is the same as above. It typically happens when some geometric values is passed to an input parameter without a hint. Apply the appropriate type hint and the error will be resolved.</p> </li> </ol>"},{"location":"parametrics/components/#input-parameter-access","title":"Input Parameter Access","text":"<p>Grasshopper support three access modes for processing data based on their multiplicity, namely <code>Item</code>, <code>List</code> and <code>Tree</code>. To change the access mode, right click over the name of input parameter and select the appropriate item from the pop-up menu. It is highly recommended to use only the <code>Item</code> access mode, when you wish to pass a single value, and the <code>List</code> access mode, for passing multiple items. Avoid all other combinations as they will cause unnecessary complications.</p> <ol> <li> <p><code>Item</code>: The component will execute as many times as the number of items passed to the input, which may be a single value, a list of values or a tree of values. In the python code, the variable with the same name as the input parameter will contain one element at a time. This is equivalent of asking grasshopper to automatically create the requisite loops for processing items one by one. Use the <code>Item</code> option for only sending single input values. Avoid using the automatic enumeration because it complicates the way the output values are emitted.</p> </li> <li> <p><code>List</code>: The component expects a list of items to be passed via the input parameter and the code to receive a python list to be processed manually. If a single value is passed, the component will wrap it into a python list. If a tree is passed, the component will receive multiple python lists one at a time. Use the <code>List</code> option for only sending single or simple list values. Avoid using the automatic tree to list enumeration because it complicates the way the output values are emitted.</p> </li> <li> <p><code>Tree</code>: The component expects a tree of items to be passed as-is to the python code. Single values and lists are wrapped automatically. The way multi-dimensional arrays are implemented in grasshopper is highly unusual and does not map to any python programming language concepts. As such it is recommended to avoid using trees.</p> </li> </ol>"},{"location":"parametrics/components/#common-access-challenges","title":"Common Access Challenges","text":"<ol> <li><code>list</code> object has no attribute <code>identifier</code> is the result of sending a single value while using the <code>list</code> access mode. For example a single point 3D is passed as input parameter named <code>point</code> with list access mode and in the code X-coordinate is used <code>point.X</code>. The problem is that point is a list not a single object. You may either change the access option to <code>item</code> (not recommended) or access the item from the list as <code>point[0].X</code>.</li> </ol>"},{"location":"parametrics/components/#output-parameters","title":"Output Parameters","text":"<p>Next we need to set the number of the output parameters and name them appropriately. The same process as adjusting and renaming the input parameters applies here but there is a catch. The out parameter is special because it is used for capturing messages emitted using python's <code>print( )</code> method. It is recommended to rename it to <code>messages</code> and to avoid deleting it. If you remove it by accident it is possible to restore by right clicking over the component's name and selecting the \"Show output parameter\" menu item.</p> <p>Notice that there is no way to annotate output parameters with either type or access information. This is handled automatically by grasshopper. In most cases this works fine but there are some special scenarios where it is problematic.</p>"},{"location":"parametrics/components/#special-output-challenges","title":"Special Output Challenges","text":"<ol> <li>Outputting nested lists, or list of lists in python, for example <code>[[1], [2]]</code> produces grasshopper lists containing <code>IronPython.Runtime.List</code> items. Those do not work well with other grasshopper components except other python components. It is possible to convert such nested lists to a <code>Tree</code> data structure but it is not recommended.</li> <li>Outputting dictionaries such as <code>{'a':1, 'b':2}</code> produces grasshopper lists containing only the keys, that is <code>['a', 'b']</code> without the values. The workaround in this case is simple: wrap the dictionary in a list <code>[{'a':1, 'b':2}]</code>. This will retain the data which can be accessed by another python component.</li> <li>Outputting a Polyline object produces a grasshopper list of points instead of a single polyline. This is because the Polyline object is an enumerable of points and grasshopper automatically unwraps it. To prevent this behavior you may either use the wrap output in list as above, or emit a PolylineCurve object instead.</li> <li>The data type of the <code>out</code> parameter is <code>str</code> so it is not recommended to use it for emitting any other type of information. For example even through the statement <code>print( 3.1415 )</code> will output a value that looks like a number, it is in fact as string which may cause problems when used in mathematical expressions.</li> </ol>"},{"location":"parametrics/cpython/","title":"CPython Component","text":"<p>The objective of this section is to overcome the incompatibilities between IronPython and CPython. The python used in Rhino in version 7 is known as IronPython and its interpreter is based on the .NET framework. This is unlike \"regular\" python, known as CPython, which causes problems such as (a) the version of IronPython used is a bit too old, namely python 2, while the current version of python is 3, featuring significant language changes, and (b) most of the interesting libraries such as numpy, matplotlib, pytorch etc. are incompatible with IronPython.</p>"},{"location":"parametrics/cpython/#component-usage","title":"Component Usage","text":"<p>To evaluate python code using the CPython interpreter requires a setup as seen below, where the <code>ipy</code> script component contains your code and the <code>cpy</code> component contains boilerplate code for invoking CPython, processing the result and reporting errors. The input parameters go into the <code>ipy</code> script component and the output parameters, or results, come out of the <code>cpy</code> component. Therefore, the <code>cpy</code> component can be reused as is and does not need any modifications. Note that it is assumed that CPython is already installed on the computer.</p> <p></p>"},{"location":"parametrics/cpython/#usage-conventions","title":"Usage Conventions","text":"<p>There are some conventions to be followed for bridging between IronPython and CPython. The code below provides a template.</p> <pre><code>\"\"\" CPython Code\n\"\"\"\ndef PythonCode( params ):\n    import sys\n    return params + '\\n&lt;&lt;--- Python ' + sys.version\n\n\"\"\" IronPython -&gt; CPython Parameter Conversion\n\"\"\"\ndef PythonParams( params ):\n    import sys\n    if( params is not None ):\n        return params + '\\n---&gt;&gt; Python ' + sys.version\n    else:\n        return '---&gt;&gt; Python ' + sys.version\n\n\"\"\" CPython -&gt; IronPython Result Conversion\n\"\"\"\ndef PythonResult( params ):\n    import sys\n    return params + '\\n---&gt;&gt; Python ' + sys.version\n\nContext = ( ghenv,          #-- Required\n    PythonCode,             #-- Required\n    PythonParams( Input ),  #-- Optional\n    PythonResult )          #-- Optional\n</code></pre> <ol> <li>The code in the IronPython side must define a function that will be executed in the CPython context, see <code>PythonCode( )</code>. Inside this function, libraries unavailable to IronPython can be used. However, the language syntax must be python 2 compatible, otherwise the script editor will raise exceptions. The name of this function is not important.</li> <li>The data between IronPython and CPython must be simple, that is strings, numbers, lists and dictionaries. This is because not all libraries are available in both environments. Additionally, exchange of data may require some conversions. Indicatively, the function <code>PythonParams( )</code> converts data from IronPython to CPython and the function <code>PythonResult( )</code> performs the opposite. The names of these functions is also not important.</li> <li>The component must output a <code>Context</code> parameter containing some required and some optional information which are passed to the [Run] component's <code>Context</code> input parameter.<ol> <li>Required: the Grasshopper environment variable.</li> <li>Required: The function that will be execute in the CPython context.</li> <li>Optional: The parameter data sent to the CPython context or <code>None</code>.</li> <li>Optional: The function to convert the CPython result to IronPython or <code>None</code></li> </ol> </li> </ol> <p>Note that the all functions require a single parameter that will receive data passed around the different contexts. If more than one parameters are needed, they can be packed in a list and unpacked as needed.</p>"},{"location":"parametrics/cpython/#installation-path","title":"Installation Path","text":"<p>Since it is often the case that more than one CPython versions are installed, the  <code>cpy</code> component can be supplied with the path of the desired version. If the <code>None</code> is provided then it will use the python as set in the system <code>PATH</code> environment variable. During python installation there is an option to set the <code>PATH</code>, if this was not selected, then the python's path must be supplied to the <code>cpy</code> component.</p>"},{"location":"parametrics/cpython/#rhino-to-numpy","title":"Rhino to NumPy","text":"<p>The sample below demonstrates how to use <code>numpy</code> to compute the average among a list of points. It assumes that <code>numpy</code> is already installed, otherwise use <code>pip install numpy</code>. The <code>PointAverage( )</code> function expects a list of point coordinates, which it converts to a <code>numpy</code> array, computes the mean value and returns a list of coordinates. The <code>ToNumPy( )</code> as well as the <code>ToRhino( )</code> functions take care of the conversion between <code>Point3d</code> and <code>list[float]</code>.</p> <pre><code>\"\"\" Point Average using NumPy\n\"\"\"\ndef PointAverage( points ):\n    import numpy as np\n    mean = np.mean( np.array( points ), axis = 0 )\n    return mean.tolist( )\n\n\"\"\" Points to Coordinate Lists\n\"\"\"\ndef ToNumPy( points ):\n    return [[point.X, point.Y, point.Z]\n        for point in points]\n\n\"\"\" Coordinate List to Point\n\"\"\"\ndef ToRhino( point ):\n    from Rhino.Geometry import Point3d\n    return Point3d( point[0], point[1], point[2] )\n\nContext = ( ghenv, PointAverage, ToNumPy( Points ), ToRhino )\n</code></pre>"},{"location":"parametrics/cpython/#rhino-to-rhino","title":"Rhino to Rhino","text":"<p>Rhino provides a version of its common objects library known as <code>rhino3dm</code> which is compatible with CPython, see documentation available. To install the library use the command <code>pip install rhino3dm</code> in a console window. While the CPython library is limited, it is possible to exchange complex object data between the two environments using the serialization methods available in both contexts. The process is pestered with conversions, from and to json objects, however the logic is simple and follows the steps listed below.</p> Step Method Context Source Target 1 <code>object.ToJSON( )</code> IronPython object str 2 <code>json.loads( )</code> CPython str dict 3 <code>class.Decode( )</code> CPython dict object 4 <code>object.Encode( )</code> CPython object dict 5 <code>json.dumps( )</code> CPython dict str 6 <code>class.FromJSON( )</code> IronPython str object <p>The example below demonstrates passing a curve object across boundaries, splitting into two parts and returning it back.</p> <pre><code>\"\"\" Load Curve from Json Data\n\"\"\"\ndef Exchange( data ):\n    import json\n    from rhino3dm import Curve\n    curve = Curve.Decode( json.loads( data ) )\n    parts = curve.Split( 0.5 )\n    return [json.dumps( part.Encode( ) )\n        for part in parts]\n\n\"\"\" Encode Curve to Json Data\n\"\"\"\ndef Encode( curve ):\n    return curve.ToJSON( None )\n\n\"\"\" Load Curves from Json Data\n\"\"\"\ndef Decode( data ):\n    from Rhino.Runtime import CommonObject\n    parts = [CommonObject.FromJSON( item )\n        for item in data]\n    return parts\n\nContext = ( ghenv, Exchange, Encode( spline ), Decode )\n</code></pre>"},{"location":"parametrics/cpython/#advanced-topics","title":"Advanced Topics","text":"<p>The source of the <code>cpy</code> component is listed below for potential customization, such as activating virtual environments etc. Overall, the function <code>InvokePython( )</code>: (a) extracts the relevant code from the connected <code>ipy</code> component; (b) it appends some boilerplate code and writes the code into a CPython file saved on the desktop; (c) then the python code is executed and the results are saved in a json file also on the desktop; finally, (d) the result value is read, decoded and exported as the <code>Result</code> parameter. Errors are reported through the <code>Messages</code> output parameter and a success or failure <code>Status</code> code is also exported.</p> <pre><code>import os, sys, json, traceback, ast\n\ndef InvokePython( context, method, params, callback ):\n    \"\"\" Extract Source Code from Connected Component\n        Note: The method's co_code member is empty.\n    \"\"\"\n    try:\n        source, target = -1, -1\n        code = context.Component.Code.replace( '\\r\\n', '\\n' )\n        module = ast.parse( code )\n        ast.fix_missing_locations( module )\n        for node in ast.walk( module ):\n            if( source &lt; 0 ):\n                if( 'Function' in str( type( node ) ) ):\n                    if( node.name == method.__name__ ):\n                       source = node.lineno - 1\n            else:\n                target = node.lineno - 1\n                break\n        lines = code.split( '\\n' )\n        code = '\\n'.join( lines[source:target] ).strip( )\n        if( Debug ): print( '#-- Code\\n{}'.format( code ) )\n    except:\n        print( 'Failed loading the CPython function.' )\n        print( traceback.format_exc( ) )\n        return False, None\n\n    \"\"\" Serialize Parameters\n        Note: Not required for certain data types but\n        enforced for checking data compatibility.\n    \"\"\"\n    try:\n        if( params is not None ):\n            params = json.dumps( params )\n        else:\n            params = []\n        if( Debug ): print( '#-- Params\\n{}'.format( params ) )\n    except:\n        print( 'Failed serializing parameters.' )\n        print( traceback.format_exc( ) )\n        return False, None\n\n    \"\"\" Complete Script with Boilerplate\n        Include parameters, invoke function and\n        persist results to json file.\n    \"\"\"\n    desktop = os.path.join( os.path.join(\n        os.path.expanduser( '~' ) ), 'Desktop' )\n    target = os.path.join( desktop, 'target.json' )\n\n    code += '\\n'.join( ['',\n        'params = ' + params,\n        'result = {}( params )'.format( method.__name__ ),\n        'import json',\n        'target = r\"{}\"'.format( target ),\n        'with open( target, \\'w\\' ) as stream:',\n        '  stream.write( json.dumps( result ) )'] )\n    if( Debug ): print( '#-- Target\\n{}'.format( target ) )\n    if( Debug ): print( '#-- Method\\n{}( )'.format( method.__name__ ) )\n\n    \"\"\" Write Script to Desktop\n    \"\"\"\n    try:\n        source = os.path.join( desktop, 'source.py'   )\n        with open( source, 'w' ) as stream:\n            stream.write( code )\n        if( Debug ): print( '#-- Source\\n{}'.format( source ) )\n    except:\n        print( 'Failed writing python script file.' )\n        print( traceback.format_exc( ) )\n        return False, None\n\n    \"\"\" Invoke CPython Interpreter\n        Note: Maybe detect OS and omit startupinfo.\n        Note: Maybe use pipes instead of file io.\n        Note: Some subprocess combos crash Rhino.\n    \"\"\"\n    try:\n        if( Python is not None ):\n            python = Python\n        else:\n            python = 'python'\n        command = '{} \"{}\"'.format( python, source )\n        if( Debug ): print( '#-- Command\\n{}'.format( command ) )\n        import subprocess\n        info = subprocess.STARTUPINFO( )\n        info.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n        result = subprocess.check_output( command,\n            startupinfo = info, stderr=subprocess.STDOUT )\n        if( not Debug ): os.remove( source )\n    except subprocess.CalledProcessError as exc:\n        print( exc.output )\n        return False, None\n    except:\n        print( 'Failed executing python script.' )\n        print( traceback.format_exc( ) )\n        return False, None\n\n    \"\"\" Load Result Data from Json\n    \"\"\"\n    try:\n        with open( target ) as stream:\n            data = stream.read( )\n        if( Debug ): print( '#-- Result\\n{}'.format( data ) )\n    except:\n        print( 'Failed loading result data.' )\n        print( traceback.format_exc( ) )\n        return False, None\n\n    \"\"\" Parse Result from Json Data\n    \"\"\"\n    try:\n        result = json.loads( data )\n        if( not Debug ): os.remove( target )\n    except:\n        print( 'Failed parsing json result data.' )\n        print( traceback.format_exc( ) )\n        return False, None\n\n    \"\"\" Convert Data to IronPython\n    \"\"\"\n    try:\n        if( callback is not None ):\n            result = callback( result )\n    except:\n        print( 'Failed decoding the result data.' )\n        print( traceback.format_exc( ) )\n\n    print( '#-- Success' )\n    return True, result\n\nStatus, Result = InvokePython( *Context )\n</code></pre> <p>Grasshopper </p>"},{"location":"parametrics/template/","title":"Template","text":"<p>In early stages of design computing experimentation, not all input and output parameters are known in advance. The recommended setup for this scenario is to prepare the component as seen below.</p> <ol> <li>Rename the <code>out</code> parameter to <code>messages</code> and connect a panel component, where you can view standard outputs and errors.</li> <li>Create a <code>geometry</code> output parameter to publish any geometric objects to be displayed in the viewport. In the code you need to initialize output with an empty list <code>geometry = []</code>, and you may <code>append( )</code> any type of items as the script's logic is developed.</li> </ol> <p>When the specific format and type of output information becomes more clear, it is only a matter of creating new parameters and updating the code as needed.</p>"},{"location":"parametrics/template/#template-python-code","title":"Template Python Code","text":"<p>You may set the following code snippet as the default python script template by pasting the code below into the python script editor and selecting the <code>Tools / Set Template Code...</code> menu item.</p> <pre><code>import math, random\nfrom Rhino import RhinoApp, RhinoDoc\nfrom Rhino.Geometry import *\nfrom Rhino.Geometry.Intersect import *\nfrom System.Drawing import Color\n\ngeometry = []\n\nprint( 'done' )\n</code></pre> <ol> <li>The <code>math</code> module is used for accessing built-in mathematics functions such as <code>sin</code>, <code>cos</code>, <code>sqrt</code>, <code>exp</code> etc.  See relevant documentation. The <code>random</code> provides random number generators.</li> <li>The <code>RhinoDoc</code> class enables direct manipulation of Rhino's currently opened document. It can be used for loading and saving geometries outside of Grasshopper. See relevant documentation. The <code>RhinoApp</code> class accesses the application itself.</li> <li>The <code>Geometry</code> namespace contains definitions for creating and manipulating points, vectors, curves, surfaces, meshes, breps etc. See relevant documentation</li> <li>The <code>Intersect</code> namespace contains definitions for computing intersections between different kinds of geometries. See relevant documentation.</li> <li>The <code>Color</code> class is used for creating color objects as defined by the .NET system and used by Rhino. See relevant documentation</li> </ol>"},{"location":"parametrics/template/#bulk-importing","title":"Bulk Importing","text":"<p>The use of bulk symbol importing such as <code>from Rhino.Geometry import *</code> is not recommended and may cause issues especially for mac users. Instead it is recommended to be more specific by importing definitions by name such as <code>from Rhino.Geometry import Point3d, Line, Mesh</code>. Alteratively, you may use namespace aliases such as <code>import Rhino.Geometry as rg</code> and prefix constructors appropriately <code>point = rg.Point3d( 1, 2, 3 )</code>.</p> <pre><code>import math, random\nfrom Rhino import RhinoApp, RhinoDoc\nfrom Rhino.Geometry import ( Point3d, Vector3d, Plane, Transform,\n    Interval, Point2d, Point3f, Vector3f, Point2f, Line, Circle,\n    Curve, Surface, NurbsCurve, NurbsSurface, Brep, Mesh, ArcCurve,\n    BezierCurve, Cone, ControlPoint, Cylinder, Ellipse, Extrusion,\n    LineCurve, LoftType, Point4d, PointCloud, PolyCurve, Polyline,\n    PolylineCurve, Quaternion, Sphere, Arc )\nfrom Rhino.Geometry.Intersect import Intersection\nfrom System.Drawing import Color\n\ngeometry = []\n</code></pre>"},{"location":"parametrics/template/#annotated-template","title":"Annotated Template","text":"<p>It is often useful to visualize text labels at specific points in the viewport. As it is not possible to emit certain types of visuals from python components, we need to adapt the template to output pairs of points and labels and use the <code>Text Tag 3D</code> component. The cluster is used for decoupling the data packed in lists.</p> <pre><code>import math, random\nfrom Rhino import RhinoApp, RhinoDoc\nfrom Rhino.Geometry import *\nfrom Rhino.Geometry.Intersect import *\nfrom System.Drawing import Color\n\n''' Annotation Helpers\n'''\nannotations = []\ndef Anno( point, label ):\n    annotations.append( [point, label] )\n\n''' Annotation Usage Example\n'''\nAnno( source, 's' )\nAnno( target, 't' )\n\ngeometry = []\n</code></pre>"},{"location":"parametrics/template/#vectors-template","title":"Vectors Template","text":"<p>The template provided below simplifies the process of visualizing vectors. The <code>Vec( )</code> method can be used to specify the origin and direction as well as the color of a 3D vector, which is then rendered using the <code>Vector Display Ex</code> component. The cluster is used for decoupling the data packed in lists.</p> <pre><code>import math, random\nfrom Rhino import RhinoApp, RhinoDoc\nfrom Rhino.Geometry import *\nfrom Rhino.Geometry.Intersect import *\nfrom System.Drawing import Color\n\n''' Vectors Helpers\n'''\nvectors = []\ndef Vec( point, direction, color ):\n    vectors.append( [point, direction, color] )\n\n''' Vectors Usage Example\n'''\nVec( source, target - source, Color.Blue )\n\ngeometry = []\n</code></pre>"},{"location":"parametrics/template/#resources","title":"Resources","text":"<p>Grasshopper </p>"},{"location":"programming/collections/","title":"Python Collections","text":"<p>This section presents some commonly used data collections, namely lists and dictionaries, and their use.</p>"},{"location":"programming/collections/#lists","title":"Lists","text":"<p>Lists are the most commonly used data collection in python. It represents an ordered container of values which can be expanded as needed and its items can be accessed by their index.</p>"},{"location":"programming/collections/#initializing","title":"Initializing","text":"<p>Empty lists are created either using the empty square brackets notation <code>[]</code> or by using the <code>list( )</code> function. Using the square bracket's notation for initializing lists is more concise.</p> <pre><code>empty = []\nempty = list( )\n</code></pre> <p>Initialization can be performed using literal values or using other variables.</p> <pre><code>numbers = [1, 2, 3]\n\na = 1\nb = 2\nc = 3\nnumbers = [a, b, c]\n</code></pre> <p>The following syntax can be used to create list with an initial number of elements of a specific value.</p> <pre><code>zeros = [0] * 10\n#-- ... instead of writing\nzeros = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n</code></pre> <p>It is possible to place lists within lists forming nested or multi-dimensional lists. By nesting lists it is possible to represent concepts such as lists of points, matrices, spreadsheets, raster images etc.</p> <pre><code>points = [[1, 0, 0],\n          [0, 1, 0],\n          [0, 0, 1]]\n\nrow = [0, 0, 0, 0]\nmat = [row, row, row]\n</code></pre>"},{"location":"programming/collections/#collecting","title":"Collecting","text":"<p>Adding items to lists is performed using the <code>append( )</code> method as seen below. The append method places the item at the end of the list. Note that lists grow automatically.</p> <pre><code>sequence = []\nfor value in range( 10 ):\n    sequence.append( value )\n</code></pre> <p>The same operation as above can be performed using the following syntax. As it is more concise for performing simple data operations it is preferred.</p> <pre><code>sequence = [value\n    for value in range( 10 )]\n</code></pre> <p>List generators can be nested, as seen below, to create both flat as well as nested lists such as tables, grids of points etc.</p> <pre><code>grid = [[( i, j )\n    for i in range( 2 )]\n        for j in range( 3 )]\n\"\"\" Grid of Points\n    [[( 0, 0 ), ( 1, 0 )],\n     [( 0, 1 ), ( 1, 1 )],\n     [( 0, 2 ), ( 1, 2 )]]\n\"\"\"\n\nrows = [( i, j )\n    for i in range( 2 )\n        for j in range( 3 )]\n\"\"\" List of Points\n    [( 0, 0 ),\n     ( 0, 1 ),\n     ( 0, 2 ),\n     ( 1, 0 ),\n     ( 1, 1 ),\n     ( 1, 2 )]]\n\"\"\"\n</code></pre> <p>The <code>insert( )</code> method is used for placing the items at specific locations. In the sample below, items are placed at the start of the list. In this fashion, the list will eventually contain a list of numbers in reverse order.</p> <pre><code>sequence = []\nfor value in range( 10 ):\n    sequence.insert( 0, value )\n</code></pre>"},{"location":"programming/collections/#measuring","title":"Measuring","text":"<p>The number of items in a list, also known as the list's length, is a read-only value obtained using the <code>len( )</code> function. It is not possible to set the length of the list directly.</p> <pre><code>items = [1, 2, 3, 4]\ncount = len( items )\n</code></pre>"},{"location":"programming/collections/#accessing","title":"Accessing","text":"<p>Getting and setting items within a list is performed using the square bracket notation. The number within the square brackets. Note that indexing starts at <code>0</code>, that is the first element of a list has index <code>0</code>. Therefore, the last element has value <code>len( items ) - 1</code>.</p> <pre><code>items = [1, 2, 3, 4]\n\nprint( items[0] )\nprint( items[1] )\nprint( items[2] )\nprint( items[3] )\n</code></pre> <p>Accessing a list's item with an index value is larger than the number of items available, results into an index out of range error.</p> <pre><code>items = [1, 2, 3, 4]\nprint( items[4] ) #-- Exception!\n</code></pre> <p>Python supports negative values for list indices. Those represent addressing items from the end of the list. The most commonly used case is getting the value of the last item using <code>items[-1]</code> notation as opposed to the equivalent but more verbose <code>items[len( items ) - 1]</code>.</p> <pre><code>print( items[ 0] ) #-- First item\nprint( items[-1] ) #-- Last item\n</code></pre>"},{"location":"programming/collections/#removing","title":"Removing","text":"<p>The <code>del</code> keyword can be used for removing an item from a specific index within a list. In the example below the first item is deleted.</p> <pre><code>numbers = [1, 2, 3, 4, 5]\ndel numbers[0]\n</code></pre> <p>The 'pop( )' method enables removing items from a list at specific locations by index. Note that 'pop( )' returns the value of the element removed which is useful. On the other hand, the equivalent using <code>del</code> does not. If the index is not provided, 'pop( )' removes the last item from the list.</p> <pre><code>numbers = [1, 2, 3, 4, 5]\nnumbers.pop( 0 ) #-- Remove first item\nnumbers.pop(   ) #-- Remove last item\n</code></pre> <p>The <code>remove( )</code> method can be used for removing items by value. Note that it removes the first item encountered with the provided value, instead of removing all the items. Also if the items does not exist it will raise an exception.</p> <pre><code>numbers = [1, 2, 888, 3, 4]\nnumbers.remove( 888 )\n</code></pre>"},{"location":"programming/collections/#enumerating","title":"Enumerating","text":"<p>Enumerating is for accessing items one by one from the start to the end of a list. Below are three equivalent versions.</p> <pre><code>numbers = [1, 2, 3, 4, 5]\n\n#-- Need only values\n#--\nfor number in numbers:\n    print( number )\n\n#-- Need index and value\n#--\nfor index in range( len( numbers ) ):\n    number = numbers[index]\n    print( index, number )\n\nfor index, number in enumerate( numbers ):\n    print( index, number )\n</code></pre>"},{"location":"programming/collections/#searching","title":"Searching","text":"<p>Testing whether a value is already in a list can be perform with the <code>in</code> operator. Its result is a boolean value which is typically used in conditional operations.</p> <pre><code>numbers = [1, 2, 3, 4, 5]\nprint( 4 in numbers )\n\nnumber = 8\nif( not ( number in numbers ) ):\n    numbers.append( number )\n</code></pre> <p>The <code>index( )</code> method is used for finding the location of a value in a list. If the value is not present in the list then an exception is used.</p> <pre><code>numbers = [1, 2, 3, 4, 5]\nprint( numbers.index( 3 ) )\n</code></pre> <p>Generally it is not convenient to manage code which throws exceptions. Below is an alternative implementation which either returns the index of the item if it is present in the list or <code>-1</code> to signal that the item was not found.</p> <pre><code>def IndexOf( items, item ):\n    for index, value in enumerate( items ):\n        if( value == item ): return index\n    return -1\n\nnumbers = [1, 2, 3, 4, 5]\nprint( IndexOf( numbers, 3 ) )\n</code></pre>"},{"location":"programming/collections/#merging","title":"Merging","text":"<p>The addition operator <code>+</code> can be used for concatenating lists. The result of the operation is a new list with the items appended in sequence.</p> <pre><code>a = [1, 2, 3]\nb = [4, 5, 6]\nc = a + b\n\"\"\" c = [1, 2, 3, 4, 5, 6] \"\"\"\n</code></pre>"},{"location":"programming/collections/#slicing","title":"Slicing","text":"<p>Extracting sub-lists of items from lists, also known as slices, can be performed using the square brackets notation but instead of indicating a single index, a range. The semantics of the expression in the square brackets follows the properties of the <code>range( )</code> function.</p> <p>Some very common idioms are presented below, namely <code>items[1:]</code> which creates a list without the first item, <code>items[:-1]</code> which creates a list without the last item and <code>items[::2]</code> which skips every other item.</p> <pre><code>items = [1, 2, 3, 4, 5]\n\ntrim_head = items[1:]   \"\"\" [2, 3, 4, 5] \"\"\"\ntrim_tail = items[:-1]  \"\"\" [1, 2, 3, 4] \"\"\"\ntrim_odds = items[::2]  \"\"\" [1, 3, 5]    \"\"\"\n</code></pre>"},{"location":"programming/collections/#filtering","title":"Filtering","text":"<p>List generators can be used for filtering by adding a conditional after the for-loop. Generators and filters are also known as list comprehensions.</p> <pre><code>numbers = [0, -3, 8, 1, -10]\npositive = [number\n    for number in numbers\n        if( number &gt;= 0 )]\n\"\"\" positive = [0, 8, 1] \"\"\"\n\nitems = [item\n    for item in range( 10 )\n        if( item % 2 == 0 )]\n\"\"\" items = [0, 2, 4, 8] \"\"\"\n</code></pre>"},{"location":"programming/collections/#patterning","title":"Patterning","text":"<p>The <code>zip( )</code> function can be used for enumerating multiple lists simultaneously, in the sense of lacing items across. It is commonly used for creating pairs as seen below.</p> <pre><code>source = [1, 2, 3, 4]\ntarget = [5, 6, 7, 8]\n\nfor s, t in zip( source, target ):\n    print( s, t )\n\nlist_of_pairs = [( s, t )\n    for s, t in zip( source, target )]\n\"\"\" list_of_pairs = [\n        ( 1, 5 ),\n        ( 2, 6 ),\n        ( 3, 7 ),\n        ( 4, 8 )]\n\"\"\"\n</code></pre> <p>Additionally, it can be used for pairing consecutive items using the idiom below. The expression <code>items[:-1]</code> produces the list <code>[1, 2, 3, 4]</code> and <code>items[1:]</code> results into <code>[2, 3, 4, 5]</code>. Zipping the lists creates pairs of consecutive numbers <code>[[1, 2], [2, 3], [3, 4], [4, 5]]</code>.</p> <pre><code>items = [1, 2, 3, 4, 5]\n\nfor a, b in zip( items[:-1], items[1:] ):\n    print( a, b )\n\nlist_of_pairs = [( a, b )\n    for a, b in zip( items[:-1], items[1:] )]\n\"\"\" list_of_pairs = [\n        ( 1, 2 ),\n        ( 2, 3 ),\n        ( 3, 4 ),\n        ( 4, 5 )]\n\"\"\"\n</code></pre>"},{"location":"programming/collections/#ordering","title":"Ordering","text":"<p>The <code>reverse( )</code> method is used for flipping the order of the items in a list. Note that reversing means swapping positions front to back. It has nothing to do with the values of the items.</p> <pre><code>items = [4, 3, 1, 2]\nitems.reverse( )\n\"\"\" items = [2, 1, 3, 4] \"\"\"\n</code></pre> <p>The <code>sort( )</code> method is used for ordering a list's values in ascending or descending fashion. This works for lists which contain values that are comparable, such as numbers.</p> <pre><code>items = [9, 3, 5, 8]\n\nitems.sort( )\n\"\"\" items = [3, 5, 8, 9] \"\"\"\n\nitems.sort( reverse = True )\n\"\"\" items = [9, 8, 5, 3] \"\"\"\n</code></pre> <p>For sorting more complex data types we need to pass a function using the <code>key</code> parameter, that given an item from the list, it returns the item's priority.</p> <p>In the example below the list <code>vectors</code> contains lists of pairs of numbers we can interpret as 2D vectors. In addition, there are three functions <code>ByX</code>, <code>ByY</code> and <code>ByLength</code> which allow us to sort the list based on their X-component, Y-component or Euclidean norm of the vector.</p> <pre><code>vectors = [[5, 0], [1, 9], [1, 3], [2, 1]]\n\ndef ByX( vector ):\n    return vector[0]\n\ndef ByY( vector ):\n    return vector[1]\n\ndef ByLength( vector ):\n    return math.sqrt(\n        vector[0] ** 2 +\n        vector[1] ** 2 )\n\nvectors.sort( key = ByX )\nvectors.sort( key = ByY )\nvectors.sort( key = ByLength )\n</code></pre> <p>The same example can be simplified using lambda expressions as follows:</p> <pre><code>vectors = [[5, 0], [1, 9], [1, 3], [2, 1]]\n\nvectors.sort( key = lambda vector : vector[0] )\nvectors.sort( key = lambda vector : vector[1] )\nvectors.sort( key = lambda vector :\n    math.sqrt( vector[0] ** 2 + vector[1] ** 2 ) )\n</code></pre> <p>It is possible to sort lists in a cascading manner, where first the items are sorted by a primary key, and then items with the same primary key are sorted by a secondary key. To achieve this, the key function needs to return a list of values instead of a single one, representing the first and second priority.</p> <p>For example, we may wish to sort the vectors first by their X-component and then by their Y-component. In this scenario we are in luck because we can either return the vector itself. In the case of sorting the vectors in a polar coordinates' sense, we can return a list containing their angle and radius.</p> <pre><code>vectors = [[5, 0], [1, 9], [1, 3], [2, 1]]\n\nvectors.sort( key = lambda vector : vector )\nvectors.sort( ) #-- also works in this case\n\n#-- Polar Sorting\n#--\nvectors.sort( key = lambda vector : [\n    math.atan2( vector[1], vector[0] ),\n    math.sqrt( vector[0] ** 2 + vector[1] ** 2 )] )\n</code></pre>"},{"location":"programming/collections/#dictionaries","title":"Dictionaries","text":"<p>Dictionaries are the second most important built-in collection supported by python. A dictionary represents an unordered collection of unique items. We cannot therefore sort dictionaries as well as add duplicate items.</p> <p>Dictionaries are used for associating a simple key value, which is often a number or string, which a more complex data value, such as a surface object. For this behavior they are also known as key-value stores.</p>"},{"location":"programming/collections/#initializing_1","title":"Initializing","text":"<p>There are two ways to construct an empty dictionary, namely using the empty curly brackets notation as well as the <code>dict( )</code> function.</p> <p><pre><code>pairs = { }\npairs = dict( )\n</code></pre> Initializing dictionaries follows the <code>key:value</code> notation seen below. In the example code, we define two dictionaries, the first one maps numbers to their string representation. Note that this can be achieved with a list, however the second dictionary maps strings to numbers which is not possible with a list.</p> <pre><code>num_to_str = { 0: 'zero', 1: 'one', 2: 'two', 3: 'three' }\nstr_to_num = { 'zero': 1, 'one': 1, 'two': 2, 'three': 3 }\n</code></pre> <p>Using the <code>dict( )</code> function can be used, where the named parameters passed are converted to keys with the associated value. Because the parameters have to follow the standard python's naming conventions, we cannot pass numerals for keys. Therefore, we can only define the string-to-number dictionary using this approach.</p> <pre><code>\"\"\" Invalid syntax!\n\"\"\"\nnum_to_str = dict( 0 = 'zero', 1 = 'one', 2 = 'two', 3 = 'three' )\n\n\"\"\" Valid syntax\n\"\"\"\nstr_to_num = dict( zero = 0, one = 1, two = 2, three = 3 )\n</code></pre>"},{"location":"programming/collections/#collecting_1","title":"Collecting","text":"<p>Building dictionaries can be performed in the same sense as with lists. However, unlike lists there is no <code>append( )</code> method. Instead items are set in the dictionary using the square bracket notation. Additionally, we can use the short-hand notation to construct dictionaries but need to provide both the key and and the value as seen below.</p> <pre><code>squares = { }\nfor value in range( 10 ):\n    squares[value] = value ** 2\n\nsquares = { value: value ** 2\n    for value in range( 10 ) }\n</code></pre>"},{"location":"programming/collections/#measuring_1","title":"Measuring","text":"<p>The <code>len( )</code> function using for lists earlier, can also be used for dictionaries to compute the number of key-value pairs stored.</p> <pre><code>str_to_num = { 'zero': 1, 'one': 1, 'two': 2, 'three': 3 }\nprint( len( str_to_num ) )\n</code></pre>"},{"location":"programming/collections/#accessing_1","title":"Accessing","text":"<p>The square brackets notation is used for getting and setting values associated with keys. If the key requested while trying to get a value from a dictionary is not available, then key not found exception is emitted.</p> <pre><code>point = { 'X': 0.0, 'Y': 0.0 }\n\npoint['Y'] = 1.0    #-- Set the Y-coordinate\npoint['Z'] = 1.0    #-- Add the Z-coordinate\n\nprint( point['X'] ) #-- Get the X-coordinate\nprint( point['W'] ) #-- Key Not Found Exception!\n</code></pre> <p>The <code>get( )</code> method can be used to avoid checking if a key exists in a dictionary, to avoid raising exceptions, before getting its value. In the example below we attempt to get the value for <code>'X'</code> which a exists but also for <code>'Z'</code> which does not. The second parameter is the default value that will be returned in the case of a missing key.</p> <pre><code>point = { 'X': 0.0, 'Y': 0.0 }\nx = point.get( 'X', 0.0 )\nz = point.get( 'Z', 0.0 )\n</code></pre>"},{"location":"programming/collections/#removing_1","title":"Removing","text":"<p>Both the <code>del</code> statement and <code>pop( )</code> function are applicable to dictionaries with the same semantics as with lists.</p> <pre><code>point = { 'X': 0.0, 'Y': 0.0 }\n\ndel point['X']\npoint.pop( 'Y' ) #-- Return deleted value\n</code></pre>"},{"location":"programming/collections/#enumerating_1","title":"Enumerating","text":"<p>There are several ways to enumerate dictionaries depending on whether we are interested in their keys, values or both. This is performed using the <code>keys( )</code>, <code>values( )</code> and <code>items( )</code> methods.</p> <pre><code>point = { 'X': 0.0, 'Y': 1.0, 'Z': 2.0 }\n\n#-- Only enumerate keys\n#--\nfor key in point:\n    print( key )\n\nfor key in point.keys( ):\n    print( coordinate_key )\n\n#-- Only enumerate values\n#--\nfor value in point.values( ):\n    print( value )\n\n#-- Only enumerate keys and values\n#--\nfor key, value in point.items( ):\n    print( key, value )\n</code></pre>"},{"location":"programming/collections/#extracting","title":"Extracting","text":"<p>Sometimes it is useful to get only the keys or values from a dictionary and collect them in a list. This can be done in a single line using the list construction function, namely <code>list( )</code>. Note that the <code>keys( )</code>, <code>values( )</code> and <code>items( )</code> methods return iterators not lists.</p> <pre><code>point = { 'X': 0.0, 'Y': 1.0, 'Z': 2.0 }\n\nkeys = list( point.keys( ) )\nvals = list( point.values( ) )\n</code></pre>"},{"location":"programming/collections/#searching_1","title":"Searching","text":"<p>The <code>in</code> operator has slightly different semantics when used with dictionaries as opposed to lists. The intent of the expression something <code>in</code> dictionary is relevant to its keys not its values.</p> <pre><code>point = { 'X': 0.0, 'Y': 1.0 }\n\nif( 'Z' in point ):\n    print( 'Point 3D' )\nelse:\n    print( 'Point 2D' )\n</code></pre>"},{"location":"programming/functions/","title":"Python Functions","text":"<p>This section presents python functions and some common use cases.</p>"},{"location":"programming/functions/#definition","title":"Definition","text":"<p>Functions are used for capturing logic that is intended to be used multiple times. In this sense they help avoiding copying and pasting code. Standard python function are defined using the <code>def</code> keyword followed by the name of the function.</p> <pre><code>def Name( args ):\n    return result\n</code></pre> <p>Function may require parameters, also known as arguments, passed when calling them. They perform some computation and return a result in the mathematical sense of y = f( x ), where <code>y</code> is the result value and <code>x</code> is the supplied value or vector of values.</p> <pre><code>def Constant( ):\n    return 1.0\n\ndef NumberSquared( value ):\n    return value ** 2\n\ndef Addition( alpha, beta ):\n    return alpha + beta\n</code></pre> <p>Functions may return a single, multiple or no values at all. Functions that do not return a value are also known as procedures. On the other hand, multiple values can be return by being wrapped in a list or tuple.</p> <pre><code>def PrintHelloWorld( ):\n    print( 'Hello World' )\n\ndef InverseSquareRoot( value ):\n    return 1.0 / math.sqrt( value )\n\ndef PointOnUnitCircle( radius, angle ):\n    return ( radius * math.cos( angle ),\n             radius * math.sin( angle ) )\n</code></pre>"},{"location":"programming/functions/#calling","title":"Calling","text":"<p>Using a function, also known as calling or invoking, is performed by using its name followed by the list of parameters, if any, placed within parentheses in the exact order they are expected. The use of parentheses is what denotes that invocation. The return value can be stored in a variable or ignored.</p> <pre><code>\"\"\" No value returned\n\"\"\"\nPrintHelloWorld( )\n\n\"\"\" Returned value ignored\n\"\"\"\nInverseSquareRoot( 1.0 )\n\n\"\"\" Returned value stored\n\"\"\"\npoint = PointOnUnitCircle( 1.0, 0.0 )\n\n\"\"\" Returned values spread\n\"\"\"\nx, y = PointOnUnitCircle( 1.0, 0.0 )\n</code></pre> <p>It is also possible to use the parameters' names when calling function, which sometimes makes the code easier to read. Note that if the names are provided then the order of parameters can be rearranged.</p> <pre><code>point = PointOnUnitCircle( radius = 1.0, angle = 0.0 )\npoint = PointOnUnitCircle( angle = 0.0, radius = 1.0 )\n</code></pre>"},{"location":"programming/functions/#scopes","title":"Scopes","text":"<p>Functions have access to variables defined globally. In other words, values defined outside a function's body can be accessed within. In fact they can be also modified but this must be avoided because most often it leads to confusing logical errors.</p> <pre><code>constant = 1\ndef Compute( param ):\n    return param * 2 + constant\n\ndef Avoid( param ):\n    constant = 3 \"\"\" Don't modify \"\"\"\n    return param * 2 + constant\n</code></pre> <p>However, the opposite is not true: code outside a function cannot access variables defined within a function.</p> <pre><code>def Compute( param ):\n    constant = 1\n    return param + constant\n\n\"\"\" No access! \"\"\"\nprint( constant )\n</code></pre>"},{"location":"programming/functions/#defaults","title":"Defaults","text":"<p>Parameters may have default values which are used if the parameter is not passed when the function is called. Therefore, parameters with default values may be considered as optional.</p> <pre><code>def InverseSquareRoot( value = 1.0 ):\n    return 1.0 / math.sqrt( value )\n\none  = InverseSquareRoot(   )\nhalf = InverseSquareRoot( 4 )\n</code></pre> <p>There is a special rule about default parameter values: all parameter must have a default value after the first instance. Otherwise, a syntax error is raised. For example below, beta must also have a default value because alpha is optional.</p> <pre><code>\"\"\" Invalid syntax!\n\"\"\"\ndef Addition( alpha = 1.0, beta ):\n    return alpha + beta\n</code></pre> <p>A typical idiom for optional parameters where we want to know if the parameter was passed or it is missing is to set the default to <code>None</code> and check as follows.</p> <pre><code>def Operation( required, optional = None ):\n    if( optional is None ): \"\"\" Is missing? \"\"\"\n        optional = 'assign value'\n    # ...\n</code></pre>"},{"location":"programming/functions/#as-values","title":"As Values","text":"<p>Functions in python can be used as values. It is possible to store a function in a variable for instance. As long as the parentheses syntax for calling the function is not used, its name can be used as a value. Variables that contain function values are callable.</p> <p>In the example below there are two functions with the same parameters defined <code>L1</code> and <code>L2</code>. The first computes the Manhattan distance and the second the Euclidean distance. We can assign either function is a variable called <code>norm</code> based on some condition and invoke the function using the alias.</p> <pre><code>def L1( a, b ):\n    return abs( a ) + abs( b )\n\ndef L2( a, b ):\n    return math.sqrt( a ** 2 + b ** 2 )\n\nnorm = L2 if( metric == 'Euclidean' ) else L1\nprint( norm( 1, 2 ) )\n</code></pre> <p>It is possible to pass functions as arguments to another function or use it as a default value as seen in the example below.</p> <pre><code>def Norm( a, b, method = L2 ):\n    return method( a, b )\n\nl1 = Norm( 1, 2, method = L1 )\nl2 = Norm( 1, 2 )\n</code></pre> <p>It is also possible to store functions in lists or dictionaries associated with a key.</p> <pre><code>\"\"\" List of functions\n\"\"\"\ndef L0( a, b ):\n    return 0.0\n\nnorms = [L0, L1, L2]\nprint( norms[2]( 1, 2 ) )\n\n\"\"\" Dictionary of functions\n\"\"\"\nnorms = {\n    'Manhattan': L1,\n    'Euclidean': L2 }\n\nprint( norms['Euclidean']( 1, 2 ) )\n</code></pre>"},{"location":"programming/functions/#recursion","title":"Recursion","text":"<p>Recursion is a pattern where a function calls itself. Some computations are more intuitive using this approach. However, it is also possible to create infinite calls which will drain memory and raise a stack overflow exception.</p> <pre><code>def Fibonacci( number ):\n    if( number &lt;= 1 ): return number\n    return ( Fibonacci( number - 1 ) +\n             Fibonacci( number - 2 ) )\n\ndef StackOverflow( value ):\n    return StackOverflow( value + 1 )\n</code></pre>"},{"location":"programming/functions/#nesting","title":"Nesting","text":"<p>Functions can be nested by placing one definition inside another. This feature is not so commonly used. The intent is to contain functions that have only local use within a scope.</p> <pre><code>def GlobalUse( a, b ):\n    def LocalUse( a, b ):\n        return a ** 2 + b ** 2\n    return math.sqrt( LocalUse( a, b ) )\n</code></pre>"},{"location":"programming/functions/#lambdas","title":"Lambdas","text":"<p>Since functions are like values, it is possible to define them without names. Those are known as anonymous or lambda functions. The example below shows two functions with equivalent logic defined using the <code>def</code> and      <code>lambda</code> syntax.</p> <pre><code>def Add( a, b ): return a + b\n\nAdd = lambda a, b: a + b\n</code></pre> <p>Note that lambdas do not allow defining local variables unlike regular functions. They are used for passing inline a function like a predicate to filter or sort a list for instance, see ordering lists.</p> <pre><code>def Select( items, predicate ):\n    return [item\n        for item in items\n            if( predicate( item ) )]\n\nevens = Select( range( 10 ),\n    lambda a : ( a % 2 ) == 0 )\n\nodds = Select( range( 10 ),\n    lambda a : ( a &amp; 1 ) == 1 )\n</code></pre>"},{"location":"programming/functions/#patching","title":"Patching","text":"<p>If multiple definitions of a function with the same name are encountered, the latest one is overwrites the previous. In the example below, the <code>Apply</code> function perform subtraction because it overwrote the earlier definition that performs addition.</p> <pre><code>def Apply( a, b ):\n    return a + b\n\ndef Apply( a, b ):\n    return a - b\n</code></pre> <p>This can be used for overriding or patching functions. In the example below the builtin <code>print( )</code> function is redefined to prefix each message with a status code. The original function is stored in a global variable <code>builtin_print</code> and the new definition will overwrite the default.</p> <pre><code>class Status:\n    Message = 'Message'\n    Failure = 'Failure'\n    Warning = 'Warning'\n\nbuiltin_print = print\ndef print( message, status = Status.Message ):\n    builtin_print( '{}: {}'.format( status, message ) )\n    return status\n\nprint( 'Success', Status.Message )\nprint( 'Possible issue', Status.Warning )\n</code></pre>"},{"location":"programming/functions/#generators","title":"Generators","text":"<p>Python supports a special style of functions known as generators. Instead of returning a single value, generators can be used to produce sequences of values. Their main use is in for-loop enumerations, where they provide iterable / enumerable sequences of values. The <code>range( )</code> function is the most commonly used generator in python extensively used in <code>for index in range( count )</code> enumerations.</p> <p>Note that the result of a generator function is a sequence of values created and returned one by one. It is not values that are first constructed, then packaged in a list and then enumerated. Because generators do not construct lists but return values on-the-fly they are more efficient in memory terms.</p> <pre><code>\"\"\" Even though these work the same,\n    range does not construct a list!\n\"\"\"\nfor index in [0, 1, 2, 3]:\n    print( index )\n\nfor index in range( 4 ):\n    print( index )\n\n\"\"\" The result of range is not a list\n    but an enumerator object\n\"\"\"\nenumeration = range( 10 )\n\n\"\"\" Enumerator objects can be converted\n    to lists using the expression below\n\"\"\"\nnumbers = list( enumeration )\n</code></pre> <p>Generators can be identified easily because instead of using the <code>return</code> keyword they instead use <code>yield</code>. While <code>return</code> exits the function permanently passing back a result, yield does not exit the function but just places a value in a notional conveyor belt and suspends until the next value is requested or sequence ends whereby the function runs out of scope.</p> <p>The example below demonstrates two usage-wise equivalent functions for generating a sequence of squared numbers. The key difference is that <code>ListOfSquares</code> constructs a list of numbers, while the <code>EnumOfSquares</code> returns one at a time without inserting them in a collection.</p> <pre><code>def ListOfSquares( count ):\n    result = []\n    for index in range( count ):\n        result.append( index ** 2 )\n    return result\n\ndef EnumOfSquares( count ):\n    for index in range( count )\n        yield index ** 2\n\n\"\"\" Usage\n\"\"\"\nfor square in ListOfSquares( 10 ):\n    print( square )\n\nfor square in EnumOfSquares( 10 ):\n    print( square )\n</code></pre> <p>The following example demonstrates a more useful application for generators. The objective of the <code>PolySides( )</code> function is given a sequence of points, to produce all the consecutive pairs which represent the line segments of a polygon's or polyline's sides.</p> <p>This is achieved using the patterning strategy presented earlier to yield-return each pair of points one by one. The <code>wrap</code> parameter is for controlling whether the function treats the sequence of points as an open polyline or a closed polygon, in which case the last-to-first side must also be returned.</p> <pre><code>\"\"\" Polyline's Sides Enumeration\n\"\"\"\ndef PolySides( points, wrap = False ):\n    for a, b in zip( points[:-1], points[1:] ):\n        yield ( a, b )\n    if( wrap ): yield points[-1], points[0]\n\n\"\"\" Point list\n\"\"\"\npoints = [Point3d( 0.0, 0.0, 0.0 ),\n          Point3d( 1.0, 0.0, 0.0 ),\n          #-- more points\n          Point3d( 0.0, 1.0, 0.0 )]\n\n\"\"\" Usage\n\"\"\"\nfor a, b in PolySides( points ):\n    print( a, b )\n</code></pre>"},{"location":"programming/objects/","title":"Python Objects","text":"<p>This section presents python classes and objects and some common use cases. The concept of objects and classes is permeating computing and it is often referred to as an object-oriented-programming paradigm.</p>"},{"location":"programming/objects/#definition","title":"Definition","text":"<p>Classes represent aggregations of various data type values capturing some semantic concept. Classes are templates from which object instances are constructed. They are defined by using the <code>class</code> keyword followed by the name of the class. By convention, class names start with upper-case letters and objects with lower-case.</p> <p>The special function <code>__init__( )</code> is known as a constructor. The first parameter <code>self</code> is special because it is used for defining and accessing the data items, or member variables, stored within an object. It must appear first before any additional parameters. Additionally, it is not possible to return a value from a constructor because the result value is the new object itself by convention.</p> <p>The following syntax is used for declaring a <code>Triangle</code> class. Geometrically we can define a triangle by three points in space or in the plane. The class' name is used as a function for constructing triangle objects. The parameters are passed to the <code>__init__( )</code> method and the new object is returned.</p> <pre><code>\"\"\" Declaring a triangle class\n\"\"\"\nclass Triangle:\n    \"\"\" Constructor\n    \"\"\"\n    def __init__( self, pa, pb, pc ):\n        self.PointA = pa\n        self.PointB = pb\n        self.PointC = pc\n\n\"\"\" Constructing a triangle object\n\"\"\"\ntriangle = Triangle(\n    Point3d( 0.0, 0.0, 0.0 ),\n    Point3d( 1.0, 0.0, 0.0 ),\n    Point3d( 0.0, 1.0, 0.0 ) )\n\n\"\"\" Getting member values\n\"\"\"\nprint( triangle.PointA   )\nprint( triangle.PointA.X )\n\n\"\"\" Setting member values\n\"\"\"\ntriangle.PointB = Point3d( 2.0, 0.0, 0.0 )\ntriangle.PointC.X = 3.0\n</code></pre> <p>Member variables can be accessed using the object-dot-name syntax. Note that member variables can be objects themselves, therefore it is not uncommon to encounter consecutive applications of the object-dot-name convention for accessing values in a hierarchical manner.</p>"},{"location":"programming/objects/#methods","title":"Methods","text":"<p>Apart from packaging values using member variables, classes may also contain functions which express various semantically relevant operations. Those are declared as functions within the class definition. Functions that belong to classes and objects are also known as member methods. Methods require their first parameter to be the keyword <code>self</code> which enables accessing an object's members within the function's body.</p> <p>In the example below triangle objects now support translation using the <code>Translate( )</code> method. The object-dot-method syntax is used for calling such functions. Note that the translation method is modifying the triangle itself or in-place instead of creating a new translated copy.</p> <pre><code>\"\"\" Declaring a triangle class\n\"\"\"\nclass Triangle:\n    def __init__( self, pa, pb, pc ):\n        self.PointA = pa\n        self.PointB = pb\n        self.PointC = pc\n\n    \"\"\" Translate Method\n    \"\"\"\n    def Translate( self, direction ):\n        self.PointA += direction\n        self.PointB += direction\n        self.PointC += direction\n        return self\n\n\"\"\" Constructing a triangle object\n\"\"\"\ntriangle = Triangle(\n    Point3d( 0.0, 0.0, 0.0 ),\n    Point3d( 1.0, 0.0, 0.0 ),\n    Point3d( 0.0, 1.0, 0.0 ) )\n\n\"\"\" Calling the translation method\n\"\"\"\ntriangle.Translate( Vector3d( 0.0, 0.0, 1.0 ) )\n</code></pre> <p>It is common to return the object itself <code>return self</code> if there is no other meaningful thing to return. This is because this idiom allows chaining operations using the dot syntax such as <code>triangle.Translate( ).Rotate( ).Scale( ).AndSoOn( )</code>. This is possible exactly because the result of each operation is the object itself. However, if nothing or a value other than self was returned, then we could not have used this chaining style of writing expressions.</p>"},{"location":"programming/objects/#get-and-set","title":"Get and Set","text":"<p>Instead of modifying an object's member variables it is often preferred to provide special access methods known as getters and setters. This approach is used for keeping some form of isolation between the internal state and the outside world world, as well as for introducing computation logic associated with an object's attributes.</p> <p>In the example below, the <code>GetCentroid( )</code> method computes the triangle's centroid from its points. The notion  a triangle's centroid computed as the mean of its points is mathematically objective and unambiguous.</p> <p>The <code>SetCentroid( )</code> method requires a centroid to be passed as a parameter such that the triangle is modified accordingly. This operation requires some assumptions such as the area of triangle should not change and/or it should only be transformed in a rigid manner without rotation etc.</p> <p>The implementation below uses the current (computed) and desired (passed as parameter) centroids to form a vector and translate the triangle.</p> <pre><code>class Triangle:\n    def __init__( self, pa, pb, pc ):\n        self.PointA = pa\n        self.PointB = pb\n        self.PointC = pc\n\n    \"\"\" Centroid Getter\n    \"\"\"\n    def GetCentroid( self ):\n        return ( self.PointA +\n                 self.PointB +\n                 self.PointC ) / 3\n\n    \"\"\" Centroid Setter\n    \"\"\"\n    def SetCentroid( self, centroid ):\n        return self.Translate(\n            self.GetCentroid( ) - centroid )\n\ntriangle = Triangle(\n    Point3d( 0.0, 0.0, 0.0 ),\n    Point3d( 1.0, 0.0, 0.0 ),\n    Point3d( 0.0, 1.0, 0.0 ) )\n\n\"\"\" Getting the triangle's centroid\n\"\"\"\ncentroid = triangle.GetCentroid( )\nprint( centroid )\n\n\"\"\" Setting the triangle's centroid\n\"\"\"\ntriangle.SetCentroid( Point3d.Origin )\n</code></pre>"},{"location":"programming/objects/#properties","title":"Properties","text":"<p>Class properties are supported in python version &gt;= 3 and Rhino &gt;= 8. They provide a stylistic improvement over getter and setter methods, such that object properties look and feel like member variables even though they are methods.</p> <p>Property getters must be annotated using the <code>@property</code> symbol before their definition and setters using the <code>@PropertyName.setter</code>, here <code>@Centroid.setter</code> symbol as seen below. Thereafter, the centroid property can be accessed as it was a member variable.</p> <pre><code>class Triangle:\n    def __init__( self, pa, pb, pc ):\n        self.PointA = pa\n        self.PointB = pb\n        self.PointC = pc\n\n    \"\"\" Centroid Property Getter\n    \"\"\"\n    @property\n    def Centroid( self ):\n        return ( self.PointA +\n                 self.PointB +\n                 self.PointC ) / 3\n\n    \"\"\" Centroid Property Setter\n    \"\"\"\n    @Centroid.setter\n    def Centroid( self, centroid ):\n        self.Translate(\n            self.GetCentroid( ) - centroid )\n\ntriangle = Triangle(\n    Point3d( 0.0, 0.0, 0.0 ),\n    Point3d( 1.0, 0.0, 0.0 ),\n    Point3d( 0.0, 1.0, 0.0 ) )\n\n\"\"\" Getting the triangle's centroid property\n\"\"\"\ncentroid = triangle.Centroid\nprint( centroid )\n\n\"\"\" Setting the triangle's centroid property\n\"\"\"\ntriangle.Centroid = Point3d.Origin\n</code></pre> <p>Note that we don't need to use the GetSomething and SetSomething style anymore. In addition, the setter methods by convention must require a new value passed as a parameter and cannot return a value themselves.</p> <p>However, it is not required to provide both getters and setters for every property. Some properties may just support only getting their value. This is conceptually equivalent to being read-only.</p> <pre><code>class Triangle:\n    def __init__( self, pa, pb, pc ):\n        self.PointA = pa\n        self.PointB = pb\n        self.PointC = pc\n\n    \"\"\" Read-Only Property\n    \"\"\"\n    @property\n    def Area( self ):\n        return Vector3d.CrossProduct(\n            self.PointB - self.PointA,\n            self.PointC - self.PointA ).Length / 2\n\ntriangle = Triangle(\n    Point3d( 0.0, 0.0, 0.0 ),\n    Point3d( 1.0, 0.0, 0.0 ),\n    Point3d( 0.0, 1.0, 0.0 ) )\n\n\"\"\" Getting the triangle's area\n\"\"\"\nprint( triangle.Area )\n</code></pre>"},{"location":"programming/objects/#statics","title":"Statics","text":"<p>Classes can define member variables that are shared among all objects instantiated. They are known as class members or static members as opposed to object members. The are defined outside methods and for accessing them the name of the class must be used with the dot syntax instead of the object's name or the <code>self</code> keyword.</p> <p>In the example below we tag each triangle created with a serial number. In order to do so we need to keep track for how many objects have been constructed. We can use a static variable named <code>SerialNumbers</code> representing the next available serial number. Every time a new triangle is created its <code>SerialNumber</code> is assigned by looking up what is the next available serial number. But since we used the currently available we also need to increment the static member.</p> <pre><code>''' Triangle class declared -&gt; S/N = 0\n'''\nclass Triangle:\n    \"\"\" Shared Static Member\n    \"\"\"\n    SerialNumbers = 0\n\n    def __init__( self, pa, pb, pc ):\n        self.PointA = pa\n        self.PointB = pb\n        self.PointC = pc\n\n        \"\"\" Read and Update Static\n        \"\"\"\n        self.SerialNumber = Triangle.SerialNumbers\n        Triangle.SerialNumbers += 1\n\n''' Triangle created -&gt; S/N = 0 -&gt; S/N += 1\n'''\na = Triangle(\n    Point3d( 0.0, 0.0, 0.0 ),\n    Point3d( 1.0, 0.0, 0.0 ),\n    Point3d( 0.0, 1.0, 0.0 ) )\n\n''' Triangle created -&gt;  S/N = 1 -&gt; S/N += 2\n'''\nb = Triangle(\n    Point3d( 0.0, 1.0, 0.0 ),\n    Point3d( 1.0, 0.0, 1.0 ),\n    Point3d( 0.0, 1.0, 0.0 ) )\n\nprint( a.SerialNumber ) ''' 0 '''\nprint( b.SerialNumber ) ''' 1 '''\n</code></pre> <p>Static class methods are commonly used for (a) performing operations that are semantically relevant to the concept captured by the class but without creating new objects, and (b) for defining alternative methods of construction. Static methods must be annotated with the <code>@staticmethod</code> symbol prior to their definition.</p> <p>The example below demonstrates these use cases. The <code>AreaFromPoints( )</code> can be used without first constructing a triangle from three points only to just measure its area using the <code>Area</code> property. Additionally, the <code>Equilateral( )</code> methods provides a shortcut for constructing a specialized form of a triangle by passing in only its side's length.</p> <p>Note that static methods do not support the <code>self</code> keyword because there is no object constructed and thus cannot be referenced.</p> <pre><code>class Triangle:\n    def __init__( self, pa, pb, pc ):\n        self.PointA = pa\n        self.PointB = pb\n        self.PointC = pc\n\n    \"\"\" Static Utility Method\n    \"\"\"\n    @staticmethod\n    def ComputeArea( pa, pb, pc ):\n        return Vector3d.CrossProduct(\n            pb - pa, pc - pa ).Length / 2\n\n    @property\n    def Area( self ):\n        return Triangle.ComputeArea(\n            self.PointA,\n            self.PointB,\n            self.PointC )\n\n    \"\"\" Static Construction Method\n    \"\"\"\n    @staticmethod\n    def Equilateral( alpha ):\n        return Triangle(\n            Point3d( 0.0, 0.0, 0.0 ),\n            Point3d( alpha, 0.0, 0.0 ),\n            Point3d( alpha / 2, math.sqrt( 3 ) * alpha / 2, 0.0 ) )\n\na = Point3d( 0.0, 0.0, 0.0 )\nb = Point3d( 1.0, 0.0, 0.0 )\nc = Point3d( 0.0, 1.0, 0.0 )\n\n\"\"\" Computing the area\n\"\"\"\narea = Triangle( a, b, c ).Area\n#-- equivalent without construction\narea = Triangle.ComputeArea( a, b, c )\n\n\"\"\" Constructing an equilateral triangle\n\"\"\"\nequilateral = Triangle.Equilateral( 100.0 )\n</code></pre>"},{"location":"programming/objects/#overloading","title":"Overloading","text":"<p>Operator overloading enables (re)defining how arithmetics are performed with object values. Typical mathematical operators such as addition <code>+</code>, subtraction <code>-</code>, multiplication <code>*</code> etc can be overloaded by implementing a special member method, namely <code>__add__</code>, <code>__sub__</code> and <code>__mul__</code>, respectively. Complete list of all operators is available by python documentation.</p> <p>In the example below the addition operation between a triangle and vector is associated with performing translation. Note that by convention operators should return a new value instead of modifying and existing one, hence constructing a new translated triangle.</p> <pre><code>class Triangle:\n    def __init__( self, pa, pb, pc ):\n        self.PointA = pa\n        self.PointB = pb\n        self.PointC = pc\n\n    \"\"\" Operator self + other -&gt; new result\n    \"\"\"\n    def __add__( self, direction ):\n        return Triangle(\n            self.PointA + direction,\n            self.PointB + direction,\n            self.PointC + direction )\n\n\"\"\" Constructing a triangle\n\"\"\"\na = Triangle(\n    Point3d( 0.0, 0.0, 0.0 ),\n    Point3d( 1.0, 0.0, 0.0 ),\n    Point3d( 0.0, 1.0, 0.0 ) )\n\n\"\"\" A translated copy of a\n\"\"\"\nb = a + Vector3d( 0.0, 0.0, 1.0 )\n</code></pre>"},{"location":"programming/objects/#indexing","title":"Indexing","text":"<p>The <code>__getitem__</code>, <code>__setitem__</code> and <code>__len__</code> methods when defined by a class allow to make objects behave like collections of data values such as lists or dictionaries. The example below presents a scenario where a triangle's points can be read or written using the same notation as with lists, namely the square brackets notation with an index.</p> <pre><code>class Triangle:\n    def __init__( self, pa, pb, pc ):\n        self.PointA = pa\n        self.PointB = pb\n        self.PointC = pc\n\n    \"\"\" Operator len( self )\n    \"\"\"\n    def __len__( self ):\n        return 3\n\n    \"\"\" Operator self[index] -&gt; value\n    \"\"\"\n    def __getitem__( self, index ):\n        if( index == 0 ): return self.PointA\n        if( index == 1 ): return self.PointB\n        if( index == 2 ): return self.PointC\n        raise IndexError( 'Index Out of Range' )\n\n    \"\"\" Operator self[index] &lt;- value\n    \"\"\"\n    def __setitem__( self, index, point ):\n        if( index == 0 ):\n            self.PointA = point\n        elif( index == 1 ):\n            self.PointB = point\n        elif( index == 2 ):\n            self.PointC = point\n        else:\n            raise IndexError( 'Index Out of Range' )\n\ntriangle = Triangle(\n    Point3d( 0.0, 0.0, 0.0 ),\n    Point3d( 1.0, 0.0, 0.0 ),\n    Point3d( 0.0, 1.0, 0.0 ) )\n\n\"\"\" The triangle works with len( )\n\"\"\"\nprint( 'The triangle has {} points'.format( len( triangle ) ) )\n\n\"\"\" Getting corner point by index\n\"\"\"\npoint = triangle[0]\n\n\"\"\" Setting corner point by index\n\"\"\"\ntriangle[0] = Point3d( 1.0, 1.0, 1.0 )\n\n\"\"\" Indexed enumeration\n\"\"\"\nfor index in range( len( triangle ) ):\n    print( triangle[index] )\n</code></pre>"},{"location":"programming/objects/#enumerating","title":"Enumerating","text":"<p>We can make object behave like enumerable collections using generator methods. This allows using them in standard for-loops without the <code>range( len( ) )</code> syntax. Note that generators are supported in python version &gt;= 3 and Rhino &gt;= 8.</p> <pre><code>class Triangle:\n    def __init__( self, pa, pb, pc ):\n        self.PointA = pa\n        self.PointB = pb\n        self.PointC = pc\n\n    \"\"\" Enumerator Property\n    \"\"\"\n    @property\n    def Points( self ):\n        yield self.PointA\n        yield self.PointB\n        yield self.PointC\n\ntriangle = Triangle(\n    Point3d( 0.0, 0.0, 0.0 ),\n    Point3d( 1.0, 0.0, 0.0 ),\n    Point3d( 0.0, 1.0, 0.0 ) )\n\n\"\"\" Using the Points property in a loop\n\"\"\"\nfor point in triangle.Points:\n    print( point )\n</code></pre>"},{"location":"programming/objects/#dumping","title":"Dumping","text":"<p>Classes may define a special method named <code>__repr__</code> which is used for expressing an object's data in a text string representation. This is useful for development purposes because such objects can be dumped into the terminal with the builtin <code>print( )</code> function, or in general converted to strings.</p> <pre><code>class Triangle:\n    def __init__( self, pa, pb, pc ):\n        self.PointA = pa\n        self.PointB = pb\n        self.PointC = pc\n\n    \"\"\" Operator self -&gt; str\n    \"\"\"\n    def __repr__( self ):\n        return 'Triangle A:[{}] B:[{}] C:[{}]'.format(\n            self.PointA,\n            self.PointB,\n            self.PointC )\n\ntriangle = Triangle(\n    Point3d( 0.0, 0.0, 0.0 ),\n    Point3d( 1.0, 0.0, 0.0 ),\n    Point3d( 0.0, 1.0, 0.0 ) )\n\n\"\"\" Automatically calls __repr__\n\"\"\"\nprint( triangle )\n</code></pre>"},{"location":"programming/objects/#inheriting","title":"Inheriting","text":"<p>Classes are often used for creating hierarchies via the concept of inheritance. The idea is that concepts can be extended by reusing some existing, instead of rewriting, code. To create a derived class, the type of the base class must be provided parenthesised next to the class' name. Additionally, the constructor typically calls the base class' constructor and initializes any additional member variables. A derived class automatically inherits all of the base class' member variables and methods. Those can be extended or redefined.</p> <p>In the example below a triangular prism extends the base triangle class providing semantics for an extruded solid object with a triangular profile. In this scenario apart from the three points that define the profile we also need an extrusion height, therefore the constructor requires four parameters. Inside the constructor the base class is first initialized using only the points and then the member <code>Height</code> is stored. As an example of how the derived class can use its parent's methods, the <code>Volume</code> property is defined, whereby the result is computed as the product of the triangle's area property times its extrusion height.</p> <pre><code>class ExtrudedTriangle( Triangle ):\n    def __init__( self, pa, pb, pc, height ):\n        \"\"\" Construct parent class\n        \"\"\"\n        Triangle.__init__( self, pa, pb, pc )\n\n        \"\"\" Store additional members\n        \"\"\"\n        self.Height = height\n\n    \"\"\" Use parent class methods\n    \"\"\"\n    @property\n    def Volume( self ):\n        return self.Area * height\n</code></pre>"},{"location":"programming/objects/#interfaces","title":"Interfaces","text":"<p>Another very useful and commonly used feature of classes is known as interface inheritance or polymorphism or dynamic dispatch. The idea is to establish a certain set of rules or behaviors that derived classes must comply with, as in they must implement, such that we can use them without caring about the internals or having to deal with differences between their types. Therefore, interfaces describe the common features between classes.</p> <p>In the example below the <code>Shape</code> interface is defined. It establishes the requirement whereby all derived classes must define a method <code>CenterOfMass( )</code> that returns the center of mass. Next we can derive specific shapes, such as lines and circles, and implement <code>CenterOfMass( )</code> appropriately. Then we can process collections of shapes knowing that they all support this feature.</p> <pre><code>\"\"\" Shape requires CenterOfMass( )\n\"\"\"\nclass Shape:\n    def CenterOfMass( self ):\n        pass\n\n\"\"\" Line extends Shape\n\"\"\"\nclass Line( Shape ):\n    def __init__( self, source, target ):\n        self.Source = source\n        self.Target = target\n\n    \"\"\" Line implements Shape\n    \"\"\"\n    def CenterOfMass( self ):\n        return ( self.Source + self.Target ) / 2\n\n\"\"\" Circle extends Shape\n\"\"\"\nclass Circle( Shape ):\n    def __init__( self, center, radius ):\n        self.Center = center\n        self.Radius = radius\n\n    \"\"\" Circle implements Shape\n    \"\"\"\n    def CenterOfMass( self ):\n        return self.Center\n\n\"\"\" Create a list containing different shapes\n\"\"\"\nshapes = [  Line( Point3d( 0.0, 0.0, 0.0 ),\n                  Point3d( 1.0, 0.0, 0.0 ) ),\n          Circle( Point3d( 1.0, 1.0, 0.0 ), 1.0 )]\n\n\"\"\" Since all shapes implement the Shape interface\n    we can call their CenterOfMass method safely\n\"\"\"\nfor shape in shapes:\n    \"\"\" Dynamic Dispatch\n    \"\"\"\n    point = shape.CenterOfMass( )\n    print( point )\n</code></pre>"}]}